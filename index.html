<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="tjjsjwhj的个人空间~">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="tjjsjwhj的个人空间~">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="tjjsjwhj">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>tjjsjwhj的个人空间~</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">tjjsjwhj的个人空间~</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">自由，从这里开始</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/10/invest-pratice-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tjjsjwhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tjjsjwhj的个人空间~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/10/invest-pratice-1/" class="post-title-link" itemprop="url">财务自由实证#1</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-10 23:20:05" itemprop="dateCreated datePublished" datetime="2020-10-10T23:20:05+08:00">2020-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-11 20:03:57" itemprop="dateModified" datetime="2020-10-11T20:03:57+08:00">2020-10-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2/" itemprop="url" rel="index">
                    <span itemprop="name">投资理财</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这个系列的第零篇是 <a href="https://tjjsjwhj.me/2020/07/18/invest-pratice-0/" target="_blank" rel="noopener">财务自由实证#0</a>，原本打算每月一篇，没想到这都过去两个月了。过去的就不补了，从10月份开始，立个flag，每月1篇。</p>
<h2 id="实证进展"><a href="#实证进展" class="headerlink" title="实证进展"></a>实证进展</h2><p>先看下当前进展。</p>
<img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/demonstration1.png" width="50%" height="50%">

<p>当前进展 1.69%，本周上涨：无。图中记录的软件是且慢小账本（微信小程序），纯手动记录，由于开始几次记录的不完整，收益率等指标可能有偏差，等多记录几次就好了。</p>
<p>虽然这个实证计划最近才开始，但是实际上投资计划已经开始一年多了，不能完全算从0开始。开始投资的时候，还没有通过投资实现财务自由的想法，纯粹就是希望不贬值，能涨一些就更好。所以当前的账户体系比较混乱，有自己的养老金，也有小孩的教育金，还有一时冲动跟投的不同的投资组合。具体有以下几块：</p>
<table>
<thead>
<tr>
<th>计划</th>
<th>投资平台</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>长赢计划-150</td>
<td>且慢</td>
<td>主理人E大的公开计划，跟投</td>
</tr>
<tr>
<td>养老金计划</td>
<td>且慢</td>
<td>定投，不同指数基金的组合，瞎折腾</td>
</tr>
<tr>
<td>教育金计划</td>
<td>且慢</td>
<td>定投，不同指数基金的组合，瞎折腾</td>
</tr>
<tr>
<td>日积月累</td>
<td>蛋卷</td>
<td>主理人Alex的公开计划，跟投</td>
</tr>
<tr>
<td>2020短期计划</td>
<td>且慢</td>
<td>瞎折腾，指数基金</td>
</tr>
<tr>
<td>其它组合跟投</td>
<td>且慢</td>
<td>如云长进取等组合</td>
</tr>
</tbody></table>
<p>这两天重新梳理了下，觉得将非教育金计划的其它计划都归入到500万的目标中比较合理。因此当前以及之后的统计中均不会包含教育金计划。上文的截图就是除教育金计划之外的总额。</p>
<h2 id="如何开始自己的自由计划"><a href="#如何开始自己的自由计划" class="headerlink" title="如何开始自己的自由计划"></a>如何开始自己的自由计划</h2><blockquote>
<p>在真正重要的事情面前，我们一定要慎重，不能轻易的下决定，尤其是涉及到投资的时候。</p>
</blockquote>
<p>如果我们在买衣服甚至买菜的时候能花上半小时和老板讨价还价，并为节省下来的几十、几百暗爽不已，那么在面对投资的时候，就更有必要慢下来好好规划自己手上本就为数不多的本金了。</p>
<p>目前我的投资体系还在摸索中，同时参考其他人的方法，可以初步分为以下几个步骤：</p>
<ul>
<li>彻底了解自己</li>
<li>规划紧急备用金</li>
<li>规划必要的保险</li>
<li>规划3年内要用的钱</li>
<li>建立长期投资组合</li>
</ul>
<h3 id="彻底了解自己"><a href="#彻底了解自己" class="headerlink" title="彻底了解自己"></a>彻底了解自己</h3><p>这一步有3个目标：摸清自己手上有多少资金、平均每月支出多少、平均每月结余多少。</p>
<p>这一步看起来容易，却也不太容易。相信没有多少人能在10分钟内给出答案。然而这一步也是进行后面几步的前提。如果大家平时有记账习惯的话，这一步就很容易，没有的话，支付宝、微信、各银行软件等都有账本功能，能比较容易的统计出来。</p>
<p>所以到这，大家不妨先花时间好好梳理下，看下手里有多少钱，每月平均支出多少，又有多少结余。</p>
<h3 id="规划紧急备用金"><a href="#规划紧急备用金" class="headerlink" title="规划紧急备用金"></a>规划紧急备用金</h3><p>开启投资第一步，规划家庭紧急备用金。</p>
<p>这一步是投资新手们极易忽略却又是十分重要的一步。是否规划了紧急备用金直接关系着后面的长期投资组合能否顺利进行。</p>
<p>投资路上，难免会遇到各种各样的意外。小到去个急诊，大到忽然失业等。相信经历了2020年上半年之后，大家对意外情况能有一个更深的认识。</p>
<p>紧急备用金的作用就是当你真的突然需要用钱的时候，可以无视当前的市场行情，坦然渡过。经常有投资的朋友说，自己清楚的知道当前市场处于谷底，也清楚的知道此时正是需要坚持的时候，但是因为这样或者那样的无奈，必须把用于长期投资的资金提取出来，十分可惜。</p>
<p>一般而言，家庭紧急备用金需要能覆盖6个月的支出。也就是如果一家人忽然没有任何收入来源，仍然能维持当前生活水平继续生活6个月。注意，这里的支出是要全方位的覆盖，比如常规生活支出、房贷、房租、社保、医保等。</p>
<p>紧急备用金的要求是安全和随存随取。安全意味着比较合适的投资途径就是货币基金、国债或者银行存款。随存随取意味着比较合适的途径就是货币基金（余额宝等）和银行存款（短期存款，）了。</p>
<h3 id="规划必要的保险"><a href="#规划必要的保险" class="headerlink" title="规划必要的保险"></a>规划必要的保险</h3><p>保险的重要性怎么强调都不为过。哪怕你没有实现财务自由的计划和想法，也需要给自己和家人配置一份完善的保险。</p>
<p>大多数人家里都没矿，并且谁也不能保证不会遇到重大疾病或者事故。而且但凡遇到，就不是紧急备用金能解决的，甚至把家底掏空都有可能。所以在配置了紧急备用金之后，一定要尽快的把必要的保险都配置上，这样才能在投资长跑中没有后顾之忧</p>
<p>但是也不能本末倒置，保险的作用是为我们在实现既定目标的路上，保驾护航，保险并不是我们的目标。因此这部分配置完善即可，不需要过度配置。</p>
<h3 id="规划3年内要用的钱"><a href="#规划3年内要用的钱" class="headerlink" title="规划3年内要用的钱"></a>规划3年内要用的钱</h3><p>这一步的作用和紧急备用金的作用类似，都是为了防止突然从长期组合中取钱而影响收益。</p>
<p>不一样的是如果出现了需要用紧急备用金的情况，意味着这个钱是立马就需要用的，而如果是3年内要用的钱，通常都有缓冲的余地，不用立刻筹集。此外，3年内要用的钱不像紧急备用金那样可以准确估算，常见的开销有买房、买车、结婚、装修、生小孩等，所以这一步的估算大家只能根据自己的实际情况尽可能的估计了。</p>
<p>3年内要用的钱意味着它的流动性要求没有那么高，比较合适的投资方式就是定期理财和债券基金。如果持有事件超过半年，一般是债券基金收益更高，更推荐。</p>
<h3 id="建立长期投资组合"><a href="#建立长期投资组合" class="headerlink" title="建立长期投资组合"></a>建立长期投资组合</h3><p>在我的计划里，长期投资组合的目标就是财务自由的目标。所以以后每一期公布的实证进展就是长期投资组合的进展。</p>
<p>前面几步都是一次性配置，之后就不用管了，而长期投资组合这部分是最耗精力的。这一步，你有各种各样的选择，可以投资股票、基金、债券、黄金等，也可以投资各种股票基金、债券基金，亦或是无脑跟投你信任的主理人的组合。</p>
<p>关于如何建立长期投资组合，这一块需要讲述的很多。在后续的文章中我会结合我自己的经验，慢慢的展开。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>第一期实证，暂时先讲这么多。之后的实证计划中，我会详细的介绍我当前的组合，并分析优劣。希望在这个过程中，能不断的提升自己的认知，进一步完善自己的长期投资组合，同时也能向你们证明，工薪族仅仅依靠工资是能实现财务自由的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/19/faq-bot-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tjjsjwhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tjjsjwhj的个人空间~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/19/faq-bot-1/" class="post-title-link" itemprop="url">FAQBot 实践系列#1 —— 从开源语料入手</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-19 15:26:31 / 修改时间：15:30:47" itemprop="dateCreated datePublished" datetime="2020-09-19T15:26:31+08:00">2020-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NLP/" itemprop="url" rel="index">
                    <span itemprop="name">NLP</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="语料"><a href="#语料" class="headerlink" title="语料"></a>语料</h2><p>FAQBot构建的基础是有一份高质量的问答语料。通过不断的搜索和查找，找到一份 <code>保险行业</code> 的问答语料：<a href="https://github.com/chatopera/insuranceqa-corpus-zh" target="_blank" rel="noopener">insuranceqa-corpus-zh</a></p>
<h3 id="语料背景"><a href="#语料背景" class="headerlink" title="语料背景"></a>语料背景</h3><p>该语料库包含从网站 <a href="https://www.insurancelibrary.com/" target="_blank" rel="noopener">Insurance Library</a> 收集的问题和答案。<br>以下是官方介绍：</p>
<blockquote>
<ul>
<li><p>该语料库的内容由现实世界的用户提出，高质量的答案由具有深度领域知识的专业人士提供。 所以这是一个具有真正价值的语料，而不是玩具。</p>
</li>
<li><p>在上述论文中，语料库用于答复选择任务。 另一方面，这种语料库的其他用法也是可能的。 例如，通过阅读理解答案，观察学习等自主学习，使系统能够最终拿出自己的看不见的问题的答案。</p>
</li>
<li><p>数据集分为两个部分“问答语料”和“问答对语料”。问答语料是从原始英文数据翻译过来，未经其他处理的。问答对语料是基于问答语料，又做了分词和去标去停，添加label。所以，”问答对语料”可以直接对接机器学习任务。如果对于数据格式不满意或者对分词效果不满意，可以直接对”问答语料”使用其他方法进行处理，获得可以用于训练模型的数据。</p>
</li>
</ul>
</blockquote>
<h3 id="语料格式"><a href="#语料格式" class="headerlink" title="语料格式"></a>语料格式</h3><p>训练数据之前，我们先仔细看下语料的格式。</p>
<h4 id="原始语料"><a href="#原始语料" class="headerlink" title="原始语料"></a>原始语料</h4><p>原始语料的目录是 <code>/corpus/pool</code>。 </p>
<p><strong>问题</strong></p>
<p>train，test，valid 是存放问题的文件，分别对应着训练集、测试集和验证集。对应的 txt 文件中是中英对照的问题，json 文件中的信息比较全，包含了中英对照的问题，问题的领域（类别），对应的答案以及错误的答案（负样本）。示例如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"0"</span>: &#123;</span><br><span class="line">        <span class="attr">"zh"</span>: <span class="string">"医疗保险拿起公司支付吗？"</span>,</span><br><span class="line">        <span class="attr">"en"</span>: <span class="string">"Does  Medicare  Pick  Up  Co  Pays?"</span>,</span><br><span class="line">        <span class="attr">"domain"</span>: <span class="string">"medicare-insurance"</span>,</span><br><span class="line">        <span class="attr">"answers"</span>: [</span><br><span class="line">            <span class="string">"4436"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"negatives"</span>: [</span><br><span class="line">            <span class="string">"1650"</span>,</span><br><span class="line">            <span class="string">"14016"</span>,</span><br><span class="line">            <span class="string">"24487"</span>,</span><br><span class="line">            <span class="string">"18224"</span>,</span><br><span class="line">            <span class="string">"15953"</span>,</span><br><span class="line">            <span class="string">"16740"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>zh</code> 是根据答案原文翻译过来的，翻译质量一般。比如示例中英文的意思其实是问【医疗保险会承担挂号费吗】（ <code>co-pay</code> 是看医生前需要支付的定额费用，类似挂号费），如果直接看翻译就不知所云了。<code>answers</code> 和 <code>negatives</code> 中的数字表示对应答案的id，下面会提到。</p>
<p><strong>答案</strong></p>
<p><code>answers</code> 中包含了答案的id和答案的中英文对照。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"0"</span>: &#123;</span><br><span class="line">        <span class="attr">"zh"</span>: <span class="string">" 汽车跟随着。示例1：如果你被给了一辆汽车（借给），那辆车没有保险，你可以在汽车上买保险，你的保险将是主要的。另一个选择，有人帮你买车。例如，您的信用评分不足以融资，因此您的朋友在您的贷款下签署了主要付款人。您可以根据您的姓名获得保险，甚至将您的朋友列为保险单，作为损失赔偿人。在这种情况下，我们总是建议您获得贷款差距：汽车的实际现金价值与其仍然拥有的金额之间的差额。例2：你借的车有保险。您可以以您的名义购买政策，列出该政策的车辆，如果发生事故，您的政策将成为次要或超额。一旦主要汽车保险的限制用尽，您的保险将踢入，并希望支付其余费用。我特意用了这个词，因为每个事故都是独一无二的，没有实际的索赔情况就很难解释这个覆盖面。即使在给定的索赔情况下，有时索赔有两个可能的结果。"</span>,</span><br><span class="line">        <span class="attr">"en"</span>: <span class="string">" Coverage follows the car. Example 1: If you were given a car (loaned) and the car has no insurance, you can buy insurance on the car and your insurance will be primary. Another option, someone helped you to buy a car. For example your credit score isn't good enough to finance, so a friend of yours signed under your loan as a primary payor. You can get insurance under your name and even list your friend on the policy as a loss payee. In this case, we always suggest you get a loan gap coverage: the difference between the car's actual cash value and the amount still owned on it. Example 2: The car you are loaned has insurance. You can buy a policy under your name, list the car on that policy and in case of the accident, your policy will become a secondary or excess. Once the limits of the primary car insurance are exhausted, your coverage would kick in and hopefully pay for the rest. I specifically used the word hopefully, because each accident is unique and it's hard to interpret the coverage without the actual claim scenario. And even with a given claim scenario, sometimes there are 2 possible outcomes of a claim."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="加工语料"><a href="#加工语料" class="headerlink" title="加工语料"></a>加工语料</h4><blockquote>
<p>使用原始语料，还需要做很多工作才能进入机器学习的模型，比如分词，去停用词，去标点符号，添加label标记。所以，在原始语料的基础上，，insuranceqa-corpus-zh提供了一个使用HanLP分词和去标，去停，添加label的数据集，这个数据集完全是基于原始语料</p>
</blockquote>
<p>加工语料的目录是：<code>corpus/pairs</code></p>
<p><strong>词表</strong><br><code>vocab_data</code> 包含<code>word2id</code> (dict, 从word到id), <code>id2word</code> (dict, 从id到word),<code>tf</code> (dict, 词频统计)和 <code>total</code> (单词总数)。 其中，未登录词的标识为 <code>UNKNOWN</code>，未登录词的id为0。</p>
<p><strong>数据格式</strong><br>train、test、valid中的数据格式一直。示例中 <code>qid</code> 对应原始语料中问题的 <code>id</code>。 <code>question</code> 中的数值表示分词后，该词对应的<code>id</code>，即 <code>word2id</code> 的查表结果。<code>utterance</code> 是回复，<code>label</code> 如果是 <code>[1,0]</code> 代表回复是正确答案，<code>[0,1]</code> 代表回复不是正确答案，所以 <code>utterance</code> 包含了正例和负例的数据。每个问题含有10个负例和1个正例。该项目并没有说明负样本的采集方式。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"qid"</span>:<span class="string">"344"</span>,</span><br><span class="line">    <span class="attr">"question"</span>:[</span><br><span class="line">        <span class="number">2462</span>,<span class="number">3206</span>,<span class="number">8878</span>,<span class="number">17449</span>,<span class="number">11331</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"utterance"</span>:[</span><br><span class="line">        <span class="number">8878</span>,<span class="number">17449</span>,<span class="number">11331</span>,<span class="number">3206</span>,<span class="number">9757</span>,<span class="number">21338</span>,<span class="number">4757</span>,<span class="number">11331</span>,<span class="number">13381</span>,<span class="number">10310</span>,<span class="number">10114</span>,<span class="number">6069</span>,<span class="number">5231</span>,<span class="number">13346</span>,<span class="number">4185</span>,<span class="number">12750</span>,<span class="number">6568</span>,<span class="number">5425</span>,<span class="number">3206</span>,<span class="number">10114</span>,<span class="number">11705</span>,<span class="number">6194</span>,<span class="number">13402</span>,<span class="number">23991</span>,<span class="number">11273</span>,<span class="number">8231</span>,<span class="number">490</span>,<span class="number">10299</span>,<span class="number">9757</span>,<span class="number">9843</span>,<span class="number">18157</span>,<span class="number">13334</span>,<span class="number">23611</span>,<span class="number">1907</span>,<span class="number">10099</span>,<span class="number">6568</span>,<span class="number">7344</span>,<span class="number">1704</span>,<span class="number">16818</span>,<span class="number">2311</span>,<span class="number">6683</span>,<span class="number">12268</span>,<span class="number">7197</span>,<span class="number">9757</span>,<span class="number">11869</span>,<span class="number">23800</span>,<span class="number">10617</span>,<span class="number">1134</span>,<span class="number">22430</span>,<span class="number">23810</span>,<span class="number">9843</span>,<span class="number">14297</span>,<span class="number">10227</span>,<span class="number">14005</span>,<span class="number">5526</span>,<span class="number">12360</span>,<span class="number">13467</span>,<span class="number">16917</span>,<span class="number">22724</span>,<span class="number">22086</span>,<span class="number">24346</span>,<span class="number">20333</span>,<span class="number">12268</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"label"</span>:[<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="语料统计"><a href="#语料统计" class="headerlink" title="语料统计"></a>语料统计</h3><table>
<thead>
<tr>
<th>语料集</th>
<th>类别（Q/A）</th>
<th>最大长度</th>
<th>平均长度</th>
</tr>
</thead>
<tbody><tr>
<td>train</td>
<td>Q</td>
<td>42</td>
<td>5</td>
</tr>
<tr>
<td>train</td>
<td>A</td>
<td>878</td>
<td>162</td>
</tr>
<tr>
<td>test</td>
<td>Q</td>
<td>33</td>
<td>5</td>
</tr>
<tr>
<td>test</td>
<td>A</td>
<td>878</td>
<td>161</td>
</tr>
<tr>
<td>valid</td>
<td>Q</td>
<td>31</td>
<td>5</td>
</tr>
<tr>
<td>878</td>
<td>A</td>
<td>878</td>
<td>165</td>
</tr>
</tbody></table>
<h2 id="Baseline复现"><a href="#Baseline复现" class="headerlink" title="Baseline复现"></a>Baseline复现</h2><h3 id="环境准备-训练"><a href="#环境准备-训练" class="headerlink" title="环境准备+训练"></a>环境准备+训练</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// git <span class="built_in">clone</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:chatopera/insuranceqa-corpus-zh.git</span><br><span class="line"></span><br><span class="line">// 安装环境依赖</span><br><span class="line">pip install -r Requirements.txt</span><br><span class="line"></span><br><span class="line">// 更新数据处理的代码</span><br><span class="line">pip install --upgrade insuranceqa_data</span><br><span class="line"></span><br><span class="line">// 模型训练</span><br><span class="line">python3 deep_qa_1/network.py</span><br></pre></td></tr></table></figure>

<p>训练的过程中可能会出现以下错误：</p>
<ol>
<li>ssl.SSLError 问题<ul>
<li>原因是 insuranceqa_data 加载数据的时候，读取数据的路径是绝对路径，读不到数据文件，触发下载，需要修改 insuranceqa_data 中的加载路径为：<code>curdir = os.getcwd()</code> </li>
<li>本质原因是 Python3 请求https时，会对ssl进行校验，要么安装证书，要么关闭校验，具体方法百度即可。</li>
</ul>
</li>
<li>ImportError: Python is not installed as a framework. <ul>
<li>mac 下使用matplotlib画图可能会出现这个问题。根据报错提示，在涉及画图的代码中加上 <code>import matplotlib; matplotlib.use(&#39;TkAgg&#39;)</code> 即可</li>
</ul>
</li>
</ol>
<h3 id="训练结果"><a href="#训练结果" class="headerlink" title="训练结果"></a>训练结果</h3><p><strong>主要训练参数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hidden_layers &#x3D; [100, 50]</span><br><span class="line">question_max_length &#x3D; 20</span><br><span class="line">utterance_max_length &#x3D; 99</span><br><span class="line">lr &#x3D; 0.001</span><br><span class="line">epoch &#x3D; 50</span><br><span class="line">batch_size &#x3D; 100</span><br></pre></td></tr></table></figure>

<p><strong>准确率</strong></p>
<p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/insuranceqa_baseline_accuracy.png" alt="accuracy"></p>
<p><strong>loss变化</strong></p>
<p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/insuranceqa_baseline_loss.png" alt="loss"></p>
<p>可以看到，准确率到了0.9之后几乎就不变了，loss开始下降的很快，之后在0.8附近剧烈波动，说明这个时候再进行更多的迭代训练并不会对准确率的提升有显著的效果，baseline的方法已经到了极限，需要寻找更好的算法了。</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>至此，baseline 已经复现完毕。接下来的文章准备以此为基础，不断优化算法，在此基础之上尽可能的提高准确率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/18/invest-pratice-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tjjsjwhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tjjsjwhj的个人空间~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/18/invest-pratice-0/" class="post-title-link" itemprop="url">财务自由实证#0</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-18 15:28:09" itemprop="dateCreated datePublished" datetime="2020-07-18T15:28:09+08:00">2020-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-11 20:01:34" itemprop="dateModified" datetime="2020-10-11T20:01:34+08:00">2020-10-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2/" itemprop="url" rel="index">
                    <span itemprop="name">投资理财</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>受公众号 <code>【也谈钱】</code> 的影响，以及互联网加班的摧残，觉得有必要早早的开始梳理家庭的财务状况，并且制定财务自由的目标和方案，为自由而奋斗。</p>
<h2 id="财务自由的目标"><a href="#财务自由的目标" class="headerlink" title="财务自由的目标"></a>财务自由的目标</h2><p>设置 <strong>财务自由</strong> 的目标前，首先需要知道财务自由的定义，明确自己需要实现的是哪种等级的财务自由，才能以此为依据，制定出切实可行的计划，并开始行动。</p>
<p>这里我拍脑袋定了一个目标：</p>
<ul>
<li><strong>目标</strong>：500万（流动性资产）</li>
<li><strong>期限</strong>：25年</li>
</ul>
<p>下面详细解释下这个脑袋是怎么拍的。</p>
<h3 id="什么是财务自由？"><a href="#什么是财务自由？" class="headerlink" title="什么是财务自由？"></a>什么是财务自由？</h3><p>经常能看到一些标题党文章如 <a href="https://www.sohu.com/a/309461248_120139549" target="_blank" rel="noopener">2.9亿？！《2019北京财务自由等级图鉴》出炉！</a> 等等，看完之后瞬间觉得财务自由此生无望。。。</p>
<p><strong>实际上</strong></p>
<blockquote>
<p>财务自由是指你无需为生活开销而努力为钱工作的状态。简单地说，你的资产产生的被动收入必须至少要等于或超过你的日常开支。–<a href="https://zh.wikipedia.org/wiki/%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1" target="_blank" rel="noopener">wikipedia</a></p>
</blockquote>
<p>根据上面的定义，实现了被动收入大于日常开支就能实现财务自由。听起来很简单有没有~~</p>
<p>被动收入的等级无法衡量，但是日常支出是可以衡量的。结合近几年财务自由越来越丰富的内涵，财务自由的等级可以戏分如下：</p>
<ul>
<li>外卖自由</li>
<li>打车自由</li>
<li>商场自由</li>
<li>租房自由</li>
<li>旅游自由</li>
<li>辞职自由</li>
<li>买车自由</li>
<li>买房自由<br>……</li>
</ul>
<p>我这里使用的并且希望达到的目标就是财务自由最原本的定义，即日常生活开销的自由。</p>
<h2 id="财务自由的可行性"><a href="#财务自由的可行性" class="headerlink" title="财务自由的可行性"></a>财务自由的可行性</h2><p>理论上被动收入没有上限，但是实现的难度也成指数上升，因此这里通过对日常生活开销的预估来倒推需要多少被动收入。</p>
<h3 id="日常开销预估"><a href="#日常开销预估" class="headerlink" title="日常开销预估"></a>日常开销预估</h3><p>因为实现财务自由一定是很多很多年后，我们需要根据当前的生活水平来推断20年甚至30年之后的日常开支水平。下面尝试通过一些数据的分析来预估25年后的日常开销。</p>
<h4 id="通货膨胀"><a href="#通货膨胀" class="headerlink" title="通货膨胀"></a>通货膨胀</h4><p>一说到财务自由的具体目标，很多小伙伴都会想到通货膨胀，说你现在定这么一个目标，多少年之后，钱早就不值钱了，有什么用？</p>
<p>确实，通货膨胀的因素不能不考虑。</p>
<blockquote>
<p>在实践中，一般不直接、也不可能计算通货膨胀率，而是通过价格指数的年增长率来间接表示。</p>
</blockquote>
<blockquote>
<p>由于居民消费价格是反映商品经过流通各环节形成的最终价格，它最全面地反映了商品流通对货币的需要量，因此，居民消费价格指数是最能充分、全面反映通货膨胀率的价格指数。目前，世界各国基本上均用居民消费价格指数，也就是CPI来反映通货膨胀的程度。</p>
</blockquote>
<p>看下几个主要国家居民消费价格指数(CPI)年率（同比）数据。</p>
<p><strong>中国居民消费价格指数年率</strong><br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/China_cpi_year.png" alt="中国居民消费价格指数年率"></p>
<p><strong>日本居民消费价格指数年率</strong><br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/Japan_cpi_year.png" alt="日本居民消费价格指数年率"></p>
<p><strong>美国居民消费价格指数年率</strong><br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/USA_cpi_year.png" alt="美国居民消费价格指数年率"></p>
<p><strong>英国居民消费价格指数年率</strong><br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/UK_cpi_year.png" alt="英国居民消费价格指数年率"></p>
<p><strong>德国居民消费价格指数年率</strong><br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/German_cpi_year.png" alt="德国居民消费价格指数年率"></p>
<p>对比5个国家发现，中国在2000年前，CPI年率有过两次高峰，2012年后，CPI年率基本稳定在3%附近，2020年初则是因为疫情的影响又高了起来。</p>
<p>其它4个国家都是发达国家，日本在1995年后，CPI年率一直稳定在1.3%下面，2015附近年有过一次波峰，和2010附近的波谷正好抵消。美国自1993年之后，CPI年率一直在3%下面，但整体高于日本；英国自1993年之后，CPI年率基本在3%下面，但是它的波动较大，其中一半的时间CPI年率都在2%下面；德国1996年之后绝大部分时间都在2%下面。</p>
<p>中国由于改革开放，造就了此后30年经济的高速增长，这也是工资、物价飞速增长的30年。但是近些年，我们能明显的感受到，经济的增长速度慢了下来，嗯，也叫经济新常态。之后还可能会进一步降低，降低到和老牌发达国家一样的低增速水平，这也意味着在接下来的一个较长的时期内，CPI年率会一直处于3%以下，并且大部分时间都达不到3%的水平。</p>
<p>假设当前的物价是1，那么以3%的CPI年率计算，25年后，物价是2.1，翻了一倍，也就是说，同等数量的钱，25年后购买力降低了一半。</p>
<h4 id="支出项预估"><a href="#支出项预估" class="headerlink" title="支出项预估"></a>支出项预估</h4><p>上面从宏观层面分析了未来20、30年物价可能出现的增长情况，这部分是我们作为个体所无法控制或者较难控制的。我们唯一能控制的就是日常支出。</p>
<p>然而这一部分也是最难预估的一部分。就目前而言，每月固定开销就有房租、房贷、保险、日常消费等，再过几年还会会有小孩的教育费用等各种无法预料的支出。</p>
<p>日常开支里，日常生活开销的其实占比很小，大头还是房贷、教育支出等。因此这部分思路如下：将人生分为两个阶段，目标完成前和目标完成后，分别考虑支出。</p>
<table>
<thead>
<tr>
<th>支出项</th>
<th>25年期间</th>
<th>25年之后</th>
</tr>
</thead>
<tbody><tr>
<td><strong>房贷</strong></td>
<td>有（较大）</td>
<td>无（房贷25年）</td>
</tr>
<tr>
<td><strong>子女教育支出</strong></td>
<td>有（较大）</td>
<td>无</td>
</tr>
<tr>
<td><strong>大病支出</strong></td>
<td>保险覆盖</td>
<td>保险覆盖</td>
</tr>
<tr>
<td>赡养</td>
<td>有（较低）</td>
<td>有（稍大）</td>
</tr>
<tr>
<td>保险支出</td>
<td>有</td>
<td>少量</td>
</tr>
<tr>
<td>日常家庭开支</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>其它</td>
<td>有</td>
<td>有</td>
</tr>
</tbody></table>
<p>这里面真正大头的是房贷、子女教育支出和大病支出。除掉这三块之后，其它的其实没有多少。也就是说，相同的钱，在这25年里和25年后，所带来的幸福感是完全不同的。</p>
<p>那么在一线城市，25年后，在没有房贷和子女教育费用的情况下，一年需要需要多少收入能过的比较幸福呢？</p>
<p>我的答案是50万。</p>
<p>换算到现在，依据当前物价水平，在年被动收入25万且没有房贷和子女教育支出的情况下可以过的的比较幸福。一般消费都能支撑的起，还能偶尔奢侈一把。</p>
<p>考虑到25年后，自己可能还在工作，或者领取退休金，所以实际的生活幸福感会更高。</p>
<p><strong>注：这里不考虑疾病支出是因为这部分的支出可以通过一个完备的保险计划来覆盖掉。关于如何配置好家庭保险，之后会单独拎出来介绍。</strong></p>
<h3 id="500万的目标是否合理"><a href="#500万的目标是否合理" class="headerlink" title="500万的目标是否合理"></a>500万的目标是否合理</h3><h4 id="500万够不够？"><a href="#500万够不够？" class="headerlink" title="500万够不够？"></a>500万够不够？</h4><p>根据上面的拍脑袋，25年后被动收入50万就能完全覆盖家庭的日常开支。</p>
<p>每年50万的被动收入，本金500万的情况下，需要的年化收益率是10%。这个收益率的要求是比较高的，因为那个时候，我们对资产配置的要求已经从获取超额收益变成了获取稳定收益，能承受的风险水平大大降低，相应的收益率水平也会降低。</p>
<p>但是假设25年后，立即退休，开始领取养老金，社保交25年对应的养老金的替代率能达到50%，有这笔收入作为补充，需要实现的稳定收益率会大大降低，大约6%-7%附近，还是可行的。</p>
<p>这么一看，500万的目标是合理的。</p>
<h4 id="能不能通过工资实现？"><a href="#能不能通过工资实现？" class="headerlink" title="能不能通过工资实现？"></a>能不能通过工资实现？</h4><p>同居民消费价格指数一样，未来20、30年，在不出现科技突破导致生产力水平再一次突飞猛进的情况下，工资水平大概率会以一个较低的增长率水平缓慢增长。</p>
<p>以美国为例，看一下1990年-2018年这28年间 <a href="https://www.statista.com/statistics/200838/median-household-income-in-the-united-states/" target="_blank" rel="noopener">美国家庭收入中位数</a> 的变化，最低是1993年的52334，最高是2018年63179，也就是说，这28年间工资的最大增幅才20%。</p>
<p>当然，如果再去看一下1990年-2018年间 <a href="https://www.ceicdata.com/zh-hans/indicator/united-states/annual-household-income-per-capita" target="_blank" rel="noopener">美国家庭人均收入</a> 的变化，你会惊讶的发现其呈稳定增长趋势。结合上面的美国家庭收入中位数几乎不变的事实，可以得出这样一个结论：美国的贫富差距正在迅速扩大。</p>
<p>中国大概率也会进入这样的状态，当然，考虑到未来一段时间内，中国的经济增长水平仍然会维持在一个中低速增长的水平，因此工资水平还是会有一段时间的中低速的增长，只是不可能会像改革开放之后30年内，出现隔一段时间就翻一番的场景了。</p>
<p>低速增长的工资水平和物价水平相抵消，意味着很难通过工资实现资本的快速积累，但同时这也意味着在相当长的一段时间内，我们可以维持一个相对稳定的储蓄率。</p>
<h4 id="能不能攒到500万？"><a href="#能不能攒到500万？" class="headerlink" title="能不能攒到500万？"></a>能不能攒到500万？</h4><p>假设初始金额为0，目标500万，不同期限下每月投入金额和需要的年化收益率的对应关系如下：</p>
<table>
<thead>
<tr>
<th>每月投入金额</th>
<th>年复合收益率（15年）</th>
<th>年复合收益率（20年）</th>
<th>年复合收益率（25年）</th>
<th>年复合收益率（30年）</th>
</tr>
</thead>
<tbody><tr>
<td>500</td>
<td>47.141%</td>
<td>31.252%</td>
<td>22.936%</td>
<td>17.879%</td>
</tr>
<tr>
<td>1000</td>
<td>39.033%</td>
<td>25.719%</td>
<td>18.724%</td>
<td>14.469%</td>
</tr>
<tr>
<td>1500</td>
<td>34.374%</td>
<td>22.492%</td>
<td>16.243%</td>
<td>12.445%</td>
</tr>
<tr>
<td>2000</td>
<td>31.095%</td>
<td>20.198%</td>
<td><strong>14.467%</strong></td>
<td>10.987%</td>
</tr>
<tr>
<td>2500</td>
<td>28.561%</td>
<td>18.411%</td>
<td>13.075%</td>
<td>9.840%</td>
</tr>
<tr>
<td>3000</td>
<td>26.493%</td>
<td>16.943%</td>
<td>11.926%</td>
<td>8.890%</td>
</tr>
<tr>
<td>5000</td>
<td>20.693%</td>
<td>12.772%</td>
<td>8.632%</td>
<td>6.143%</td>
</tr>
</tbody></table>
<p>综合考虑自己的个人情况，认为每月投入2000，实现15%的年化收益率这种方案比较适合自己。这里面每月投入2000很简单，但是实现15%的收益率不太容易，需要持续不断的投入精力学习各种理财知识。</p>
<p>那么实现接近15%的年化收益率，难度高吗？这里以沪深300指数为例，沪深300指数基日是2004年12月31日，基点是1000点，2020年1月3号是4144点，折算成年化收益率是9.941%。如果配合一定的策略，完全是可以获取更高的收益率水平的。</p>
<p>因此，如何构建自己的投资体系，实现15%的超额收益，也是<code>【财务自由实证系列】</code>的一个目标之一。</p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>本篇算是 <code>【财务自由实证系列】</code> 的一个序，之后这个系列会定期公开自己财务自由计划的进展，记录自己在实现这个目标过程中的点点滴滴，同时证明这样的一个财务自由计划是完全有可能实现的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/27/Go-Modules-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tjjsjwhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tjjsjwhj的个人空间~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/27/Go-Modules-md/" class="post-title-link" itemprop="url">Go Modules 简介</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-27 19:16:55 / 修改时间：19:24:22" itemprop="dateCreated datePublished" datetime="2020-06-27T19:16:55+08:00">2020-06-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>In Go 1.14, module support is considered ready for production use, and all users are encouraged to migrate to modules from other dependency management systems.</p>
</blockquote>
<p>在go1.14中，模块支持被认为已经可以在生产环境中使用，因此鼓励所有用户将项目中的依赖管理系统都迁移到Go Mudules中。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="Go-版本升级"><a href="#Go-版本升级" class="headerlink" title="Go 版本升级"></a>Go 版本升级</h3><p><strong>查看Go版本</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env</span><br></pre></td></tr></table></figure>

<p>如果显示版本低于1.14，则需要升级。</p>
<p><strong>下载Go最新版本</strong></p>
<p>官网地址：<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a> ，下载对应版本。这里以 <code>go1.14.4.darwin-amd64.tar.gz</code> 为例。</p>
<p><strong>删除旧版本</strong></p>
<ul>
<li>通过 <code>go env</code> 获取安装路径（即 <code>GOROOT</code> ），一般是 <code>/usr/local/go</code> 。</li>
<li><code>rm -rf /usr/local/go</code> </li>
</ul>
<p><strong>安装新版本</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -C /usr/<span class="built_in">local</span> -xzf go1.14.4.darwin-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p>至此，Go1.14 升级完成，so easy~</p>
<h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><p>由于一些原因，下载Go的各种依赖包的时候，速度很慢，通过一些镜像网站下载的话，可以获得如丝滑般的下载体验。</p>
<p><strong>常见的Go Modules镜像网站：</strong><br>1、<a href="https://proxy.golang.org/" target="_blank" rel="noopener">https://proxy.golang.org/</a><br>GOPROXY 的默认值，这是一个在大陆无法访问的地址。。<br>2、<a href="https://goproxy.io/" target="_blank" rel="noopener">https://goproxy.io/</a><br>一个开源的为 Go Modules 而生的全球代理。国内开发者使用的较多，维护者是个人。<br>3、<a href="https://goproxy.cn/" target="_blank" rel="noopener">https://goproxy.cn/</a><br>Goproxy 中国，最初开发者是 <a href="https://aofeisheng.com/" target="_blank" rel="noopener">@盛傲飞</a>，目前是七牛云托管和维护。你甚至可以像 goproxy.baidu.com 一样将该服务用作上游代理。</p>
<p><strong>如何设置</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>

<p><strong>趣闻</strong>：<a href="https://github.com/goproxy/goproxy.cn/issues/61" target="_blank" rel="noopener">goproxy.io 和 goproxy.cn 是什么关系?</a></p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><blockquote>
<p>如果使用 Go Modules 来管理依赖，那么你的项目就没有必要在 <code>GOPATH</code> 中了。</p>
</blockquote>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>1、随便创建一个项目目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /tmp/scratchpad/repo</span><br><span class="line"><span class="built_in">cd</span> /tmp/scratchpad/repo</span><br></pre></td></tr></table></figure>
<p>2、go mod 准备</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init xxx/repo</span><br></pre></td></tr></table></figure>
<p>其中 <code>xxx</code> 是你项目托管的目录。如果是在github上，则是 <code>github.com/yourname/repo</code> 。</p>
<p>3、测试代码</p>
<p>repo 下 main.go 中添加如下测试代码</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	</span><br><span class="line">	<span class="string">"github.com/labstack/echo"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e := echo.New()</span><br><span class="line">	e.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c echo.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c.String(http.StatusOK, <span class="string">"Hello, World!"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	e.Logger.Fatal(e.Start(<span class="string">":1323"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、go mod xxx 相关命令</p>
<table>
<thead>
<tr>
<th>xxx</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>download</td>
<td>download modules to local cache</td>
</tr>
<tr>
<td>edit</td>
<td>edit go.mod from tools or scripts</td>
</tr>
<tr>
<td>graph</td>
<td>print module requirement graph</td>
</tr>
<tr>
<td>init</td>
<td>initialize new module in current directory</td>
</tr>
<tr>
<td>tidy</td>
<td>add missing and remove unused modules</td>
</tr>
<tr>
<td>vendor</td>
<td>make vendored copy of dependencies</td>
</tr>
<tr>
<td>verify</td>
<td>verify dependencies have expected content</td>
</tr>
<tr>
<td>why</td>
<td>explain why packages or modules are needed</td>
</tr>
</tbody></table>
<h3 id="日常工作流程"><a href="#日常工作流程" class="headerlink" title="日常工作流程"></a>日常工作流程</h3><p>使用 go mod 之后，你的<strong>日常工作流程</strong>应该是这样：</p>
<ol>
<li>在代码文件中写好 <code>import</code> 语句</li>
<li>执行 <code>go run</code> or <code>go build</code> or <code>go test</code>，或者一些其它的标准命令时，会自动下载依赖以及更新 <code>go.mod</code> 文件。</li>
<li>当你需要指定依赖的版本的时候，你可以使用命令 <code>go get foo@v1.2.3</code>， <code>go get foo@master</code> ，<code>go get foo@e3702bed2</code> 直接下载指定版本（这些命令都会直接更新go.mod），或者直接修改 go.mod 文件。</li>
</ol>
<p>一些你可能会用到的其它功能：</p>
<ol>
<li><code>go list -m all</code> – 查看全部直接或者间接的依赖</li>
<li><code>go list -u -m all</code> – 查看全部直接或者间接的依赖版本及最新版本</li>
<li><code>go get -u ./...</code> or <code>go get -u=patch ./...</code> ,，更新全部直接或者间接依赖到最新 <code>minor</code> 版本或者 <code>patch</code> 版本</li>
<li><code>go build ./...</code> or <code>go test ./...</code></li>
<li><code>go mod tidy</code> 精简不必要的依赖，同时增加任何必要的依赖。</li>
<li><code>go mod vendor</code> — 创建 vendor 目录，并复制依赖到其中。 </li>
</ol>
<h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><blockquote>
<p>A module is a collection of related Go packages that are versioned together as a single unit.</p>
</blockquote>
<p>仓库（repository）、模块（module）和 包（package）之间的关联：</p>
<ul>
<li>一个仓库包含了一个或多个 Go Modules</li>
<li>每个模块包含了一个或多个 Go Packages</li>
<li>每个包 包含了某个路径下的一个或多个 Go Source 文件</li>
</ul>
<p>Modules 必须被语义版本化 （遵循 <a href="https://semver.org/" target="_blank" rel="noopener">semver</a> 协议），其版本描述格式如 <code>v(major).(minor).(patch)</code> </p>
<blockquote>
<ol>
<li>major (主版本号)：当你做了不兼容的 API 修改，</li>
<li>minor (次版本号)：当你做了向下兼容的功能性新增</li>
<li>patch (修订号)：当你做了向下兼容的问题修正</li>
</ol>
</blockquote>
<h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h3><p><code>go.mod</code> 文件中有4个命令：<code>module</code>， <code>require</code>，<code>replace</code>，<code>exclude</code>。</p>
<p><strong>example</strong></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module github.com/my/thing</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com/some/dependency v1<span class="number">.2</span><span class="number">.3</span></span><br><span class="line">    github.com/another/dependency/v4 v4<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>module</code> 命令声明了当前模块的名称以及导入路径。</p>
<p><code>require</code> 命令标明了当前模块所依赖的模块。</p>
<p><code>replace</code> 和 <code>exclude</code> 命令仅对当前模块生效，即 build 主模块时，其它依赖模块中的 <code>replace</code> 和 <code>exclude</code> 命令都会被忽略掉。</p>
<h3 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h3><p>如果当前模块依赖的一个模块名是 M，当你还没有将 M 添加到 <code>go.mod</code> 中的时候，如果执行 <code>go build</code> 或者 <code>go test</code> 等命令，会自动拉取 M 并将其添加到 <code>go.mod</code> 中，拉取规则如下：</p>
<ul>
<li>拉取 M 最新的发行版本 v1.2.3，如果没有发行版本，则拉取最新的master的commit</li>
<li>如果当前模块中的依赖 A 依赖 M v1.0.0，B 依赖 M v1.2.3，那么会选择 M v1.2.3 (最小版本选择算法)</li>
</ul>
<h3 id="语义导入版本控制"><a href="#语义导入版本控制" class="headerlink" title="语义导入版本控制"></a>语义导入版本控制</h3><p>这里说的是导入模块的时候，包的路径应该与模块版本相符。</p>
<p>具体规则如下：</p>
<ul>
<li>模块的版本命令应该遵从 <a href="https://semver.org/" target="_blank" rel="noopener">semver</a> 协议。</li>
<li>如果该模块的版本是 v2 或者更高，那么 <code>go.mod</code> 中声明该模块的时候，需要加上 <code>/v2</code> 的后缀，如 <code>module github.com/my/mod/v2</code> 或者 <code>require github.com/my/mod/v2 v2.0.1</code>。这种用法也被用在 <code>go get</code> 命令中，如 <code>go get github.com/my/mod/v2@v2.0.1</code></li>
</ul>
<h2 id="FAQs"><a href="#FAQs" class="headerlink" title="FAQs"></a>FAQs</h2><p><strong>1、go.mod 中模块被标记成 <code>incompatible</code> 是什么意思</strong></p>
<p><strong>答：</strong> 如果 <code>Module</code> 的名字没有遵循 Golang 的规范，即在模块名中附带版本信息，那这就是一个不规范的模块，就会提示 <code>incompatible</code>。以 <code>github.com/labstack/echo</code> 为例，如果其当前版本是 <code>v3.3.10</code> ，那么 go.mod 中会这样显示：<code>github.com/labstack/echo v3.3.10+incompatible</code> 。</p>
<p>想象一下，如果 <code>github.com/labstack/echo</code> 更新到了 <code>v4.1.1</code> ，如果你的模块依赖它，并且执行了更新全部依赖的命令会怎么样？ <code>github.com/labstack/echo</code> 会更新到 <code>v4.1.1</code>，但是根据 <a href="https://semver.org/" target="_blank" rel="noopener">semver</a> 协议，v4 是不兼容 v3 的，这个时候你的模块就会出问题。如果依赖符合规范，如 <code>github.com/labstack/echo/v3</code> ，那你更新全部依赖后，也只是将版本更新到 <code>v3.9.9</code> 或者小于 <code>v4</code> 的最大一个版本，不会出现兼容性的问题。</p>
<p>当模块的版本小于等 v1 的时候，模块名默认不需附带版本信息。</p>
<p><strong>2、为什么 <code>go mod tidy</code> 会记录 <code>inderect</code> （非直接）依赖和测试依赖？</strong></p>
<p><strong>答：</strong> <code>go mod dity</code> 会尽可能的反应出所需要的全部环境下（有可能是系统、处理器架构或者build tags）的依赖，而 <code>go build</code> 和 <code>go test</code> 仅仅是更新 <code>go.mod</code> ，添加当前环境的依赖。</p>
<p><strong>3、如何在不支持 Module 的模块 A 中导入支持 Module 的 v2+ 的 模块 B?</strong></p>
<p><strong>答：</strong> 这需要看 module B 是如何发布 v2+ module 的。</p>
<ol>
<li>如果是在主分支，在 go.mod 中通过 <code>module</code> 声明 <code>/v3</code> <ul>
<li>模块 A 中不需要修改导入路径 （即使改了编译的时候也会忽略路径中的版本信息），在 <code>GOPATH</code> 模式下运行的时候，会选择 <code>GOPATH</code> 中的模块 B 的版本编译。</li>
</ul>
</li>
<li>如果 B 是在 子目录中创建了一个 <code>./v3</code> 目录，然后将 <code>go.mod</code> 文件放在 <code>./v3</code> 中<ul>
<li>A 中使用 <code>import github.com/xxx/B/v3</code> 是没有问题的。</li>
</ul>
</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">Go Modules 官方文档</a></li>
<li><a href="https://juejin.im/post/5d8ee2db6fb9a04e0b0d9c8b" target="_blank" rel="noopener">干货满满的 Go Modules 和 goproxy.cn</a></li>
<li><a href="https://rainbowmango.gitbook.io/go/chapter12/3-foreword/3.7-module-incompatible" target="_blank" rel="noopener">Go 专家编程-incompatible</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/21/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tjjsjwhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tjjsjwhj的个人空间~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/21/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">MySQL之索引</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-21 16:00:28 / 修改时间：16:08:53" itemprop="dateCreated datePublished" datetime="2020-06-21T16:00:28+08:00">2020-06-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么需要索引"><a href="#为什么需要索引" class="headerlink" title="为什么需要索引"></a>为什么需要索引</h2><p>索引就像书籍的目录一样，可以更快的查找数据。</p>
<h2 id="常见的索引模型"><a href="#常见的索引模型" class="headerlink" title="常见的索引模型"></a>常见的索引模型</h2><blockquote>
<p>innodb 索引模型选用B+树是由MySQL的应用场景（等值区间查找、插入删除等操作频繁）及机械磁盘的特点（寻址耗时）决定的。像Redis等一些Nosql数据库，他们的索引模型就是哈希表、跳表等。</p>
</blockquote>
<ul>
<li>数组<ul>
<li>等值查询很快（数组有序排列的情况下，二分查找）</li>
<li>区间查询很快</li>
<li>数据的插入删除很慢</li>
</ul>
</li>
<li>哈希表<ul>
<li>等值查询极快</li>
<li>插入删除极快</li>
<li>区间查询很慢（只能一个个的查找）</li>
</ul>
</li>
<li>搜索树（链表）<ul>
<li>二叉搜索树<ul>
<li>等值查询、区间查询很快，效率等于数组的二分查找</li>
<li>插入删除效率logN，需要树的再平衡，再平衡的效率也是logN</li>
</ul>
</li>
<li>多叉搜索树树<ul>
<li>相比于二叉树，多叉树一次寻址能取出更多的数据，能大大减少寻址次数</li>
<li>一个节点下面，叶子节点的个数取决于硬盘上数据块的大小</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>MySQL的应用场景中，等值查询和区间查询是很高频的场景，插入删除操作也十分频繁，因此综合考虑，搜索树最适合作为底层的存储引擎。又因为机械硬盘时代，磁盘寻址的时间成本很高，因此 innodb 底层的那存储引擎选用的索引模型是B+树。</p>
<p>本文后续主要介绍innodb的索引。</p>
<h2 id="Innodb中的索引"><a href="#Innodb中的索引" class="headerlink" title="Innodb中的索引"></a>Innodb中的索引</h2><h3 id="主键索引和非主键索引"><a href="#主键索引和非主键索引" class="headerlink" title="主键索引和非主键索引"></a>主键索引和非主键索引</h3><p><strong>主键索引：</strong> 主键索引的叶子结点（最后一层）存储的是数据库的行数据。</p>
<p><strong>非主键索引：</strong> 非主键索引的叶子节点（最后一层）存储的是主键索引。</p>
<p>对于一个查询操作，查询条件如果是主键索引，则直接返回结果；如果是非主键索引，则先返回主键，然后根据主键查询主键索引树，再返回结果。</p>
<p><em>查询原则：尽量使用主键索引查询。</em></p>
<h3 id="索引类别"><a href="#索引类别" class="headerlink" title="索引类别"></a>索引类别</h3><p>innodb中不同索引类别的特点如下：</p>
<ul>
<li>普通索引<ul>
<li>没有任何限制</li>
</ul>
</li>
<li>唯一索引<ul>
<li>索引列的值唯一</li>
<li>允许有空值</li>
<li>组合索引，列值必须唯一</li>
</ul>
</li>
<li>主键索引<ul>
<li>只能作用于一个列上</li>
<li>键值唯一</li>
<li>不能为空</li>
</ul>
</li>
</ul>
<p>业务上，如果只有一个索引，并且是唯一索引，可以直接用该字段建立索引（<strong>尽量使用主键索引查询原则</strong>）</p>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>插入数据或者删除数据，都涉及到索引表的调整。</p>
<p>插入数据的时候，有可能会导致叶子节点数据的挪动，也可能导致数据页的分裂。(对性能的影响需要结合B+树的增删改查操作)</p>
<p>删除数据的时候，一般只是对数据标记下删除，并不会立即调整索引树，除非索引树中被删除的数据过多，浪费了大量的空间，则需要重建索引树。</p>
<p><strong>自增主键的优势</strong></p>
<ul>
<li>主键自增，索引树不需要维护主键的有序性</li>
<li>自增ID占空间较小，非主键索引树占用的空间更小</li>
</ul>
<p>索引从性能和存储上考虑，自增ID都是更好的选择。</p>
<blockquote>
<p>想象以下，一个用户信息表，如果索引选择身份证号码，那每次新增一条数据，为了保证索引有序，都有可能导致一个数据块上数据重新排列，也能导致一个数据块分裂，显然更耗时。</p>
<p>如果这个用户信息表还有其它非主键索引树，那它的叶子节点存储的都是18位的身份证号码，显然消耗的空间相较于自增ID要更多</p>
</blockquote>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><blockquote>
<p>覆盖索引只是一种场景，或者一种现象，构造出这种现象有利于提高查询性能。</p>
</blockquote>
<p>先看一个查询的例子。如果我们有如下的一张表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0, </span><br><span class="line">s varchar(16) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">index k(k))</span><br><span class="line">engine&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line">insert into T values(100,1, &#39;aa&#39;),(200,2,&#39;bb&#39;),(300,3,&#39;cc&#39;),(500,5,&#39;ee&#39;),(600,6,&#39;ff&#39;),(700,7,&#39;gg&#39;);</span><br></pre></td></tr></table></figure>

<p>如果执行如下语句，需要查询几次？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T where k between 3 and 5;</span><br></pre></td></tr></table></figure>
<p>答：查询非主键索引树3次，回表2次。</p>
<p>同样如果执行下面的语句，需要查询几次？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from T where k between 3 and 5;</span><br></pre></td></tr></table></figure>
<p>答：查询非主键索引树3次，不需要回表。</p>
<p>如果索引树的查询结果已经包含了我们需要的结果，不需要回表，这种情况就称为覆盖索引。<strong>覆盖索引</strong>是常用的一种性能优手段。</p>
<h3 id="联合索引和最左前缀原则"><a href="#联合索引和最左前缀原则" class="headerlink" title="联合索引和最左前缀原则"></a>联合索引和最左前缀原则</h3><p>联合索引和最左前缀原则并没有什么必然的联系，这里放在一起讨论是因为联合索引的查找过程会应用到最左前缀原则。</p>
<h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><blockquote>
<p>B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</p>
</blockquote>
<p>查询的时候，如果查询条件是索引的最左N个字段，或者最左N个字符，都能用上索引，加快查询速度。</p>
<h4 id="如何安排联合索引的顺序"><a href="#如何安排联合索引的顺序" class="headerlink" title="如何安排联合索引的顺序"></a>如何安排联合索引的顺序</h4><p>联合索引是按照索引项的顺序建立索引的，如（A，B），建立索引的时候，是先按A排序，然后对同一个A，再按B排序，检索的顺序也是如此，先检索A，再检索B。所以建立联合索引的时候，一定要考虑索引的复用 程度。复用程度越高，越要放前面。</p>
<p>显然如果建立了联合索引（A，B），索引A是不需要单独建立索引的。</p>
<p>回到之前的覆盖索引，如果有个高频的需求是根据用户的身份证查询姓名，那有必要建立身份证号和姓名的联合索引吗？答案是不考虑索引维护的成本下是有必要的。</p>
<p>建立了身份证和姓名的联合索引之后，只需要查询联合索引树，就能直接返回查询结果而不需要回表，大大提高查询性能。</p>
<p>当然，索引的维护是有代价的。因此建立冗余的索引来实现覆盖索引就需要权衡考虑了。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p><strong>题目</strong>：对于如下表，由于历史原因，联合索引（a, b）是必须的，那这里面有不必要的索引吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;geek&#96; (</span><br><span class="line">  &#96;a&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;b&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;c&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;d&#96; int(11) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;a&#96;,&#96;b&#96;),</span><br><span class="line">  KEY &#96;c&#96; (&#96;c&#96;),</span><br><span class="line">  KEY &#96;ca&#96; (&#96;c&#96;,&#96;a&#96;),</span><br><span class="line">  KEY &#96;cb&#96; (&#96;c&#96;,&#96;b&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure>

<p><strong>答</strong>：ca是不必要的索引。</p>
<p>对于联合索引（a，b），其内部的组织是先根据a排序，再根据b排序，因此索引树c的内容其实是cab，即先根据c排序，再根据a排序，再根据b排序的一个B+数据。索引树（c，a）的叶子节点实际上是b，树的内容也是cab，和索引树c是一致的，因此ca索引树是不必要的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/mysql%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tjjsjwhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tjjsjwhj的个人空间~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/mysql%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7/" class="post-title-link" itemprop="url">MySQL之事务的隔离性</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 23:22:43" itemprop="dateCreated datePublished" datetime="2020-05-31T23:22:43+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-21 16:08:45" itemprop="dateModified" datetime="2020-06-21T16:08:45+08:00">2020-06-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一提到事务，我们就会想到事务的4个特性ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性和持久性）。本篇文章，主要讲的就是隔离性。</p>
<p>mysql里面并不是所有的存储引擎都支持事务，因此本文中针对事务的讨论都是基于存储引擎innodb。</p>
<h2 id="一、隔离级别"><a href="#一、隔离级别" class="headerlink" title="一、隔离级别"></a>一、隔离级别</h2><h3 id="1-1-“隔离级别”的概念"><a href="#1-1-“隔离级别”的概念" class="headerlink" title="1.1 “隔离级别”的概念"></a>1.1 “隔离级别”的概念</h3><blockquote>
<p>脏读（dirty read）: A 事务可以读到B事务未提交的数据，就叫脏读。<br>不可重复读（no-repeatable read）: 事务A开始时只能看到其它事务已经提交的修改。换句话说，事务A的两次查询可能看到不同的结果。（其它事务中途提交修改）。不可重复读针对的是单条记录。<br>幻读（phantom read）:当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）。</p>
</blockquote>
<p>当数据库上有多个事务 <strong>并行执行</strong> 的时候，会出现脏读（dirty read）、不可重复读（no-repeatable read）、幻读（phanton read)的问题，为了解决这些问题，就出现了”隔离级别”的概念。</p>
<h3 id="1-2-不同的隔离级别"><a href="#1-2-不同的隔离级别" class="headerlink" title="1.2 不同的隔离级别"></a>1.2 不同的隔离级别</h3><p>在谈隔离级别之前，我们首先要直到，你隔离的越严实，效率就会越低。因此很多时候，我们需要在二者之间寻找一个平衡点。</p>
<p>标准的事务隔离级别有以下几种：</p>
<ol>
<li><strong>读未提交</strong>（read uncommited）: 一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li><strong>读提交</strong>（read commited）: 一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li><strong>可重复读</strong>（repeatable read）: 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li><strong>串行化</strong>（sirializable）: 对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ol>
<h3 id="1-3-隔离级别的修改"><a href="#1-3-隔离级别的修改" class="headerlink" title="1.3 隔离级别的修改"></a>1.3 隔离级别的修改</h3><p><strong>隔离级别的查看</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%transaction_isolation%&quot;;</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| Variable_name         | Value           |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| transaction_isolation | REPEATABLE-READ |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>隔离级别的修改</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set [ global | session ] transaction isolation level [ Read uncommitted  | Read committed | Repeatable read | Serializable ];</span><br></pre></td></tr></table></figure>
<p>注：<code>[]</code> 表示可选。</p>
<h3 id="1-4-可重复读隔离级别的演示"><a href="#1-4-可重复读隔离级别的演示" class="headerlink" title="1.4 可重复读隔离级别的演示"></a>1.4 可重复读隔离级别的演示</h3><p>由于mysql默认的隔离级别是可重复读，因此这里就以可重复读为例进行演示，其它情况可通过修改隔离级别模拟。</p>
<p>步骤1：创建测试表，插入测试数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(c int) engine&#x3D;InnoDB;</span><br><span class="line">insert into T(c) values(1);</span><br></pre></td></tr></table></figure>

<p>步骤2：起2个事务模仿并发的情况，以下是两个事务中不同操作的执行顺序。</p>
<p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/repeatable%20read.png" alt="可重复读"></p>
<p>从图中可以看到，右边的事务无论是执行 update 操作，还是提交事务，左边的事务都是看不到的。当左边的事务提交之后，再次查询，才能看到更新之后的数据。完美契合可重复读的定义：事务执行期间看到数据可事务开启时看到的数据一致。</p>
<p>其它隔离级别读者可自行实验。</p>
<p><strong>提示</strong> </p>
<ul>
<li>如果是读未提交，那在上图第5步的时候，会发现数据发生变化</li>
<li>如果是读提交，那在上图第7步的时候，会发现数据发生变化</li>
<li>如果是串行化，那在执行第4步的时候，会失败，必须等左边的事务提交，右边的事务才能继续执行。</li>
</ul>
<h3 id="1-5-事务隔离的实现"><a href="#1-5-事务隔离的实现" class="headerlink" title="1.5 事务隔离的实现"></a>1.5 事务隔离的实现</h3><p>实现上，数据库会创建一个视图，访问的时候以视图的逻辑结果为准（<strong><em>注：此视图实为一致性读视图 consistend read view，不是MySQL中特指查询结果的那个视图</em></strong>）。不同时刻启动的事务，会有不同的视图，这意味着不同视图里面的同一条数据会有不同的版本，这就是数据库多版本并发控制（MVCC）。</p>
<p>“读未提交”隔离级别下，直接读取的最新数据，没有视图的概念；”读提交”隔离级别下，事务中每次执行查询语句前，都会新建一个视图；”可重复读”隔离级别下，事务启动的时候，会创建一个视图，整个事务执行期间都用这个视图；”串行化”隔离级别下，直接用加锁的方式来避免并行访问。</p>
<p><strong>以可重复读为例:</strong></p>
<p>在可重复读隔离级别下，不同事务在启动的时候，就拍了不同的”快照”: 一个基于整个库的快照。我们先来看下这个快照是怎么实现的。</p>
<p>Innodb中每个事务都有一个transaction id，这个id是在事务开始的时候向系统申请的，是按申请顺序严格递增的。</p>
<p>数据库中的每行数据有多个版本，每一个版本都是和一个transaction id绑定的。比如分别有事务trx_id_1，trx_id_2，trx_id_3 对某行数据进行更新，更新过程中该行数据产生了3个版本v1，v2，v3，记录的时候就会这样记：（v1, trx_id_1），（v2, trx_id_2），（v3, trx_id_3）。实际存储的时候，数据库只会记录最新的记录（v3, trx_id_3）,之前的记录则是通过undo日志计算出来的。</p>
<p>有了transaction id和多版本的概念，快照的实现方式可以这样描述：</p>
<ol>
<li>InnoDB 为每个事务构造了一个<strong>数组</strong>，用来保存这个事务启动瞬间，当前正在<strong>活跃</strong>的所有事务 ID。“活跃”指的就是，启动了但还没提交。</li>
<li>数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。(<strong>注意：这里的ID的最大值是已经创建过的所有事务ID的最大值</strong>)</li>
</ol>
<p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p>
<p>数据版本的可见性规则，就是基于数据的 trx_id 和这个一致性视图的对比结果得到的。</p>
<p>假设数据版本对应的事务id为trx_id，则可见性规则如下：</p>
<ol>
<li>如果trx_id小于低水位，则数据可见。</li>
<li>如果trx_id大于高水位，则数据不可见</li>
<li>如果trx_id在高低水位之间，有两种可能：<ol>
<li>如果trx_id在数组里，则数据不可见</li>
<li>如果trx_id不在数组里，则数据可见</li>
</ol>
</li>
</ol>
<p><strong>此外，如果是这个事务自己更新的数据，它自己还是要认的。</strong> </p>
<p>假设事务A启动的时候，当前系统中活跃的事务ID为[trx_id_1, trx_id_2, trx_id_3]，最小事务ID为trx_id_1，系统里已经创建过的事务ID的最大值加1为trx_id_max，当前数据版本为（V4，trx_id_x4）。</p>
<p>如果trx_id_x4 &gt; trx_id_max，就认为当前V4不可见，数据版本根据undolog回退到上一个版本（V3，trx_id_x3），如果trx_id_x3在高低水位之间，并且在数组里面，仍然认为V3不可见，在根据undolog回退到上一个版本(V2，trx_id_x2)，如果trx_id_x2小于低水位，认为数据可见。那么当前事务A在整个事务期间看到的这一行数据的版本都是V2。</p>
<p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p>
<ul>
<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li>
<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li>
</ul>
<p>InnoDB 正是利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</p>
<h3 id="1-5-不同隔离级别的应用场景"><a href="#1-5-不同隔离级别的应用场景" class="headerlink" title="1.5 不同隔离级别的应用场景"></a>1.5 不同隔离级别的应用场景</h3><h2 id="二、事务到底是隔离的还是非隔离的"><a href="#二、事务到底是隔离的还是非隔离的" class="headerlink" title="二、事务到底是隔离的还是非隔离的"></a>二、事务到底是隔离的还是非隔离的</h2><p>上面介绍的不同的隔离级别下看到的数据版本针对的是当前事务的操作是纯读的情况，如果当前事务事务中存在更新操作，那会是什么情况呢？</p>
<p>当然，串行化的隔离级别下，无论读写，都会加锁，并等待锁的释放，所以这种情况下和原来一样。其它三种级别下，事务执行过程中，如果出现update操作，就会应用这样一条规则：</p>
<p><strong>更新数据都是先读后写的，而这个读，只能读当前最新版本的值，称为当前读（current read）</strong></p>
<p>读未提交隔离级别下，一直都是读的最新版本值，所以这条规则实际影响的是 <strong>读提交</strong> 和 <strong>可重复读</strong>。</p>
<p>在可重复读的事务过程中，如果出现了update操作，会等其它事务的update完成，释放行锁，然后读取当前值，在执行update语句。在这之后的select语句的执行结果都是更新后的值，因为1.5中：</p>
<p><strong>此外，如果是这个事务自己更新的数据，它自己还是要认的。</strong> </p>
<h2 id="三、尽量避免使用长事务"><a href="#三、尽量避免使用长事务" class="headerlink" title="三、尽量避免使用长事务"></a>三、尽量避免使用长事务</h2><p>事务的隔离中用到一致性视图，而一致性视图需要用到回滚日志undolog。那回滚日志什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p>
<p>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 read-view 的时候。</p>
<p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。</p>
<p>因此建议总是使用 set autocommit=1, 通过显式语句的方式来启动事务(<strong>这样之前挂起的事务会被隐式提交</strong>)。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/06/2020%E5%B9%B4%E5%BA%A6%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tjjsjwhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tjjsjwhj的个人空间~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/06/2020%E5%B9%B4%E5%BA%A6%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">2020年度规划</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-06 01:38:37" itemprop="dateCreated datePublished" datetime="2020-05-06T01:38:37+08:00">2020-05-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%9F%E6%B4%BB/" itemprop="url" rel="index">
                    <span itemprop="name">生活</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>临近春节，工作上没有那么忙了，正好把2020年的年度计划整理下，定上几个小目标。</p>
<p>为了提高计划的完成度，下面制定计划的时候，会尽可能的给出相应的时间节点和比较可行的操作步骤。</p>
<h3 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h3><p>19年在专业技能上的完成度比较差，所以这一部分先列出来，以体现其重要性。</p>
<p>对于目前的自己来说，有两个方向，一个是后端开发，另一个是算法（NLP方向）。从行业的发展来看，后端开发的需求量大，技术更新迭代较快，但是在企业，绝大部分的开发内容都是业务逻辑实现，可替代性较强，且工作强度较大，不利于工作和生活的平衡；算法（NLP方向）的数学基础要求较高，门槛高，可替代性较弱，但是随着各种开发工具的完善，算法模型的实现难度在迅速下降，并且NLP发展到今天，已经达到了一个瓶颈，距离真正的自然语言理解还很遥远。</p>
<p>考虑到自己的兴趣点，以及2-3年之后的职业规划，我在专业技能上的目标是成为一个具有较强的开发能力的自然语言处理算法工程师（算法工程师）。</p>
<p>以此为基准，2020年的专业技能提升计划如下：</p>
<ul>
<li>开发<ul>
<li>Redis深度历险：核心原理与应用实践<ul>
<li>目标：完成该书的重读和总结</li>
<li>时间：Q1季度结束之前</li>
<li>完成形式：至少三篇技术博客</li>
</ul>
</li>
<li>Go语言编程<ul>
<li>目标：完成该书的阅读</li>
<li>时间：Q2季度结束之前</li>
<li>完成形式：至少四篇技术博客</li>
</ul>
</li>
<li>mysql<ul>
<li>目标：完成极客时间的mysql实战</li>
<li>时间：Q2季度之前</li>
<li>完成形式：至少4篇技术博客</li>
</ul>
</li>
<li>其它相关知识<ul>
<li>目标：完成工作上一些技术设计的总结</li>
<li>时间：全年</li>
<li>完成形式：至少4篇技术博客</li>
</ul>
</li>
</ul>
</li>
<li>算法（NLP）<ul>
<li>自然语言处理入门<ul>
<li>目标：每月完成一章</li>
<li>时间：2020年</li>
<li>完成形式：完整的阅读完，并且能针对其中部分章节形成4-5篇技术博客</li>
</ul>
</li>
<li>机器学习实战<ul>
<li>目标：完成整本书的代码实现</li>
<li>时间：2020年</li>
<li>完成形式：每月完成一个章节算法的github提交</li>
</ul>
</li>
<li>数据结构、算法与应用<ul>
<li>目标：用Python和Go实现相应的数据结构及算法</li>
<li>时间：2020年</li>
<li>完成形式：每2周一篇技术博库</li>
</ul>
</li>
<li>其它<ul>
<li>leetcode刷题<ul>
<li>目标：完成200道题目，每周4道题</li>
<li>时间：2020年</li>
<li>完成形式：200道题目过关</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="非核心能力"><a href="#非核心能力" class="headerlink" title="非核心能力"></a>非核心能力</h2><h3 id="投资"><a href="#投资" class="headerlink" title="投资"></a>投资</h3><h4 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h4><ul>
<li>逃不开的经济周期</li>
<li>哈利·布朗的永久投资组合</li>
</ul>
<h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><ul>
<li>投资实证公开</li>
<li>专业知识整理汇总，逐步形成自己系统的投资知识体系</li>
<li>开始研究量化投资，争取完成相关代码的开发</li>
</ul>
<h3 id="欧洲史"><a href="#欧洲史" class="headerlink" title="欧洲史"></a>欧洲史</h3><p>为明年去欧洲旅行提前做准备，哈哈~~</p>
<h4 id="阅读-1"><a href="#阅读-1" class="headerlink" title="阅读"></a>阅读</h4><ul>
<li>极简欧洲史</li>
<li>企鹅欧洲史</li>
</ul>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>之前写2020年规划的时候，才刚过完年来北京。回过头去看，当时指定的目标绝大部分都没有按计划执行。果然自己的自制力还是比较差。今天重新回顾了了下之前的计划，并对其中的部分内容做了删减，感觉又有动力了！</p>
<hr>
<p><strong>一个月后见进展~~</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/13/mysql%E4%B9%8Bredolog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tjjsjwhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tjjsjwhj的个人空间~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/13/mysql%E4%B9%8Bredolog/" class="post-title-link" itemprop="url">MySQL 日志之 redolog</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-13 01:55:06" itemprop="dateCreated datePublished" datetime="2020-04-13T01:55:06+08:00">2020-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-21 16:08:59" itemprop="dateModified" datetime="2020-06-21T16:08:59+08:00">2020-06-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、redolog-概述"><a href="#一、redolog-概述" class="headerlink" title="一、redolog 概述"></a>一、redolog 概述</h2><p><code>mysql</code> 有多种日志，每种日志都有其特定的用途。 <code>redolog</code> 是 <code>mysql</code> 存储引擎为 <code>innodb</code> 时，特有的日志。 <code>innodb</code> 是 <code>mysql</code> 最常用的存储引擎，它的事务的持久性就是通过 <code>redolog</code>保证的。</p>
<h2 id="二、redolog-介绍"><a href="#二、redolog-介绍" class="headerlink" title="二、redolog 介绍"></a>二、redolog 介绍</h2><p>为了更清晰的将 <code>redolog</code> 讲清楚，本文会围绕以下几个方面逐层展开。</p>
<ul>
<li><code>redolog</code> 是什么？</li>
<li><code>redolog</code> 存储形式</li>
<li><code>redolog</code> 是怎么产生的？</li>
<li><code>redolog</code> 的格式</li>
<li>为什么用 <code>redolog</code> 来保证事务的持久性？</li>
</ul>
<h3 id="2-1-redolog-是什么"><a href="#2-1-redolog-是什么" class="headerlink" title="2.1 redolog 是什么"></a>2.1 redolog 是什么</h3><p><code>redolog</code> 是存储引擎 <code>innodb</code> 特有的、在引擎层生成的（ <code>binlog</code> 是在 <code>server</code> 层产生的，不管用任何引擎都会生成），用于保证事务持久性的日志。 <code>redolog</code> 采用了 <code>WAL</code> ( <code>Write-Ahead Logging</code> ) 机制，即日志优先落盘，也就是说，一个事务发生之后， <code>innodb</code> 会先将数据页的变动写到 <code>redolog</code> 中，而不是实际的数据文件中，一旦 <code>redolog</code> 写入完成，就认为这个事务的操作记录完成了。之后mysql会有一套更新机制，定期的将 <code>redolog</code> 中的内容写入到数据文件中。</p>
<p>在 <code>mysql</code> 中， <code>redolog</code> 不会用来做物理上的主从复制，它主要的应用场景是 <code>crash-recovery</code> (崩溃恢复).</p>
<p>无论mysql有没有发生异常，重新启动的时候，mysql都会通过 <code>redolog</code> 恢复，确保数据没有问题。</p>
<h3 id="2-2-redolog-的存储形式"><a href="#2-2-redolog-的存储形式" class="headerlink" title="2.2 redolog 的存储形式"></a>2.2 redolog 的存储形式</h3><p>我们可以执行如下 <code>mysql</code> 命令查看 <code>redolog</code> 相关的部分信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &quot;%innodb_log%”;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------+----------+</span><br><span class="line">| Variable_name                      | Value    |</span><br><span class="line">+------------------------------------+----------+</span><br><span class="line">| innodb_log_buffer_size             | 16777216 |</span><br><span class="line">| innodb_log_checksums               | ON       |</span><br><span class="line">| innodb_log_compressed_pages        | ON       |</span><br><span class="line">| innodb_log_file_size               | 50331648 |</span><br><span class="line">| innodb_log_files_in_group          | 2        |</span><br><span class="line">| innodb_log_group_home_dir          | .&#x2F;       |</span><br><span class="line">| innodb_log_spin_cpu_abs_lwm        | 80       |</span><br><span class="line">| innodb_log_spin_cpu_pct_hwm        | 50       |</span><br><span class="line">| innodb_log_wait_for_flush_spin_hwm | 400      |</span><br><span class="line">| innodb_log_write_ahead_size        | 8192     |</span><br><span class="line">+------------------------------------+----------+</span><br></pre></td></tr></table></figure>

<p>一些参数的解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">innodb_log_buffer_size: redolog缓存区的大小，即16m</span><br><span class="line">innodb_log_file_size: redolog文件的大小，即48m</span><br><span class="line">innodb_log_files_in_group: 日志文件组中文件数量</span><br><span class="line">innodb_log_group_home_dir: 日志文件组路径即 mysql&#x2F;data</span><br></pre></td></tr></table></figure>

<p>如果 <code>mysql</code> 的安装路径是默认路径，那么：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql</span><br><span class="line">ls data</span><br></pre></td></tr></table></figure>

<p>形如 <code>ib_logfile0</code>、 <code>ib_logfile1</code> 之类的文件就是 <code>redolog file</code>。为什么这里会出现两个 <code>ib_logfile</code> ？这是因为 <code>redolog file</code> 其实指的是一个文件组，由多个 <code>ib_logfile</code> 合并起来共同表示。</p>
<p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/redolog_checkpoint.png" alt="redolog checkpoint"></p>
<p><code>redolog</code> 的大小是在配置中设置好的，不能无限制写入。 <code>innodb</code> 采用了循环写入的方式，图中 <code>checkpoint</code> 和 <code>writepos</code> 就是用来区分哪些数据已经从日志文件中刷新到数据文件中。<code>writepos</code> -&gt; <code>checkpoint</code> 之间的数据是已经写入到数据文件中的，是可以删除的，<code>checkpoint</code> -&gt; <code>writepos</code> 之间的数据是已经写入到日志文件中，但是还没有写入到数据文件中，是不可以擦除的。</p>
<p>如果有新的数据写入到日志文件上，<code>writepos</code> 的位置就会顺时钟挪动，如果发现超过了 <code>checkpoint</code> 的位置，就会强制将一部分 <code>checkpoint</code> 右边的数据刷如磁盘中的数据文件上，然后将 <code>checkpoint</code> 顺时针移动一定的位置。</p>
<h3 id="2-3-redolog-是怎么产生的"><a href="#2-3-redolog-是怎么产生的" class="headerlink" title="2.3 redolog 是怎么产生的"></a>2.3 redolog 是怎么产生的</h3><h4 id="2-3-1-事务的执行引起-redolog-的更新"><a href="#2-3-1-事务的执行引起-redolog-的更新" class="headerlink" title="2.3.1 事务的执行引起 redolog 的更新"></a>2.3.1 事务的执行引起 redolog 的更新</h4><p><code>redolog</code> 更新的依据是事务的执行。每一次事务执行完毕之后，所引起的数据页的变化都会先写到 <code>redolog</code> 中（当然，如果事务中是先 <code>insert</code> 再 <code>delete</code>，实际不对数据页做出改变的话， <code>redolog</code> 是不会更新的）。</p>
<p><em>注：<code>innodb</code> 中 <code>insert</code> 或者 <code>update</code> 语句默认都是事务。</em></p>
<h4 id="2-3-2-redolog-的写入流程"><a href="#2-3-2-redolog-的写入流程" class="headerlink" title="2.3.2 redolog 的写入流程"></a>2.3.2 redolog 的写入流程</h4><p>并不是事务一执行，数据页就被写入到 <code>redolog</code> 中。 <code>redolog</code> 本身是文件，频繁的写文件，会导致性能的降低，所以 <code>redolog</code> 的写入流程如下，以一个 update 操作为例：</p>
<p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/redolog_wiriting_process.png" alt="redolog 刷新流程"></p>
<p>在最后一步，将数据从缓存刷入文件的时候，其实中间还有一步，缓存中的数据会先刷到 <code>linux</code> 的文件缓存中，然后才会再被刷入到日志文件中。如果 <code>Linux</code> 机器忽然重启，就有可能丢失这部分数据， <code>redolog file</code> 就会更新失败。</p>
<p><code>redolog buffer</code> 何时刷入日志文件，是否需要强制刷新 <code>Linux</code> 文件缓存？ <code>innodb</code> 主要通过下面这两个参数控制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------------+-------+</span><br><span class="line">| Variable_name                  | Value |</span><br><span class="line">+--------------------------------+-------+</span><br><span class="line">| innodb_flush_log_at_timeout    | 1     |</span><br><span class="line">| innodb_flush_log_at_trx_commit | 1     |</span><br><span class="line">+--------------------------------+-------+</span><br></pre></td></tr></table></figure>

<p><code>innodb_flush_log_at_trx_commit</code> 配置的详细说明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Controls the balance between strict ACID compliance for commit operations and higher performance that is possible when commit-related I&#x2F;O operations are rearranged and done in batches. You can achieve better performance by changing the default value but then you can lose transactions in a crash.</span><br><span class="line">* The default setting of 1 is required for full ACID compliance. Logs are written and flushed to disk at each transaction commit.</span><br><span class="line">* With a setting of 0, logs are written and flushed to disk once per second. Transactions for which logs have not been flushed can be lost in a crash.</span><br><span class="line">* With a setting of 2, logs are written after each transaction commit and flushed to disk once per second. Transactions for which logs have not been flushed can be lost in a crash.</span><br><span class="line">* For settings 0 and 2, once-per-second flushing is not 100% guaranteed. Flushing may occur more frequently due to DDL changes and other internal InnoDB activities that cause logs to be flushed independently of the innodb_flush_log_at_trx_commit setting, and sometimes less frequently due to scheduling issues. If logs are flushed once per second, up to one second of transactions can be lost in a crash. If logs are flushed more or less frequently than once per second, the amount of transactions that can be lost varies accordingly.</span><br><span class="line">* Log flushing frequency is controlled by innodb_flush_log_at_timeout, which allows you to set log flushing frequency to N seconds (where N is 1 ... 2700, with a default value of 1). However, any mysqld process crash can erase up to N seconds of transactions.</span><br><span class="line">* DDL changes and other internal InnoDB activities flush the log independently of the innodb_flush_log_at_trx_commit setting.</span><br><span class="line">* InnoDB crash recovery works regardless of the innodb_flush_log_at_trx_commit setting. Transactions are either applied entirely or erased entirely.</span><br></pre></td></tr></table></figure>

<p>根据上面的解释，<code>innodb_flush_log_at_trx_commit = 1</code> 时， <code>logbuffer</code> 实时刷入，且系统缓存也会实时刷入文件，此时数据库的四大特性：ACID 能够严格保证。 <code>innodb_flush_log_at_trx_commit</code> 等于其它值的时候，可以通过 <code>innodb_flush_log_at_timeout</code> 来控制缓存刷新的频率。</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_flush_log_at_timeout" target="_blank" rel="noopener">相关配置的详细解释</a></p>
<h3 id="2-4-redolog-文件格式"><a href="#2-4-redolog-文件格式" class="headerlink" title="2.4 redolog 文件格式"></a>2.4 redolog 文件格式</h3><h4 id="2-4-1-redolog-文件存储地址"><a href="#2-4-1-redolog-文件存储地址" class="headerlink" title="2.4.1 redolog 文件存储地址"></a>2.4.1 redolog 文件存储地址</h4><p>根据上文中 <code>innodb_log</code> 的配置 <code>innodb_log_group_home_dir = ./</code> (这里的当前目录即mysql的数据文件目录，如果你是安装在默认路径，一般数据文件目录为 <code>/usr/local/mysql/data</code> )，文件目录如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">drwxr-x---   12 _mysql  _mysql       384 Mar 13 00:31 #innodb_temp</span><br><span class="line">drwxr-x---    3 _mysql  _mysql        96 Apr  4 22:10 appengine_common</span><br><span class="line">-rw-r-----    1 _mysql  _mysql        56 Aug 28  2019 auto.cnf</span><br><span class="line">-rw-r-----    1 _mysql  _mysql      7062 Mar  6 20:58 binlog.000014</span><br><span class="line">-rw-r-----    1 _mysql  _mysql       178 Mar  7 01:47 binlog.000015</span><br><span class="line">-rw-r-----    1 _mysql  _mysql       178 Mar  7 02:10 binlog.000016</span><br><span class="line">-rw-r-----    1 _mysql  _mysql       178 Mar  7 02:34 binlog.000017</span><br><span class="line">-rw-r-----    1 _mysql  _mysql       178 Mar 12 11:24 binlog.000018</span><br><span class="line">-rw-r-----    1 _mysql  _mysql       178 Mar 12 12:25 binlog.000019</span><br><span class="line">-rw-r-----    1 _mysql  _mysql       178 Mar 13 00:31 binlog.000020</span><br><span class="line">-rw-r-----    1 _mysql  _mysql  51286298 Apr  4 22:26 binlog.000021</span><br><span class="line">-rw-r-----    1 _mysql  _mysql       128 Mar 13 00:31 binlog.index</span><br><span class="line">-rw-------    1 _mysql  _mysql      1680 Aug 28  2019 ca-key.pem</span><br><span class="line">-rw-r--r--    1 _mysql  _mysql      1112 Aug 28  2019 ca.pem</span><br><span class="line">-rw-r--r--    1 _mysql  _mysql      1112 Aug 28  2019 client-cert.pem</span><br><span class="line">-rw-------    1 _mysql  _mysql      1680 Aug 28  2019 client-key.pem</span><br><span class="line">-rw-r-----    1 _mysql  _mysql      4110 Mar 13 00:31 ib_buffer_pool</span><br><span class="line">-rw-r-----    1 _mysql  _mysql  50331648 Apr  4 22:26 ib_logfile0</span><br><span class="line">-rw-r-----    1 _mysql  _mysql  50331648 Apr  4 22:26 ib_logfile1</span><br><span class="line">-rw-r-----    1 _mysql  _mysql  12582912 Apr  4 22:26 ibdata1</span><br><span class="line">-rw-r-----    1 _mysql  _mysql  12582912 Mar 13 00:31 ibtmp1</span><br><span class="line">drwxr-x---    8 _mysql  _mysql       256 Nov  8 23:52 mysql</span><br><span class="line">-rw-r-----    1 _mysql  _mysql  24117248 Apr  4 22:26 mysql.ibd</span><br><span class="line">-rw-r-----    1 _mysql  _mysql     19195 Mar 13 00:31 mysqld.local.err</span><br><span class="line">-rw-r-----    1 _mysql  _mysql         4 Mar 13 00:31 mysqld.local.pid</span><br><span class="line">drwxr-x---  105 _mysql  _mysql      3360 Nov  8 23:52 performance_schema</span><br><span class="line">-rw-------    1 _mysql  _mysql      1680 Aug 28  2019 private_key.pem</span><br><span class="line">-rw-r--r--    1 _mysql  _mysql       452 Aug 28  2019 public_key.pem</span><br><span class="line">-rw-r--r--    1 _mysql  _mysql      1112 Aug 28  2019 server-cert.pem</span><br><span class="line">-rw-------    1 _mysql  _mysql      1676 Aug 28  2019 server-key.pem</span><br><span class="line">drwxr-x---    3 _mysql  _mysql        96 Nov  8 23:52 sys</span><br><span class="line">drwxr-x---    3 _mysql  _mysql        96 Mar 30 23:15 test</span><br><span class="line">-rw-r-----    1 _mysql  _mysql  12582912 Apr  4 22:26 undo_001</span><br><span class="line">-rw-r-----    1 _mysql  _mysql  12582912 Apr  4 22:26 undo_002</span><br></pre></td></tr></table></figure>

<p>其中前缀是 <code>ib_logfile</code> 的文件就是。</p>
<p>如果你想看一下文件中的具体内容，可以通过命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings ib_logfile0</span><br></pre></td></tr></table></figure>

<p>大概感知一下。在文件中，我们能搜到诸如 <code>thread_id</code>，<code>space_id</code> 之类的字段。</p>
<h4 id="2-4-2-redolog-格式简介"><a href="#2-4-2-redolog-格式简介" class="headerlink" title="2.4.2 redolog 格式简介"></a>2.4.2 redolog 格式简介</h4><p>尽管一个 <code>redolog</code> 有多个文件，但是每个文件的格式是一致的，只是有一些数据只会存在第一个文件中。</p>
<p>第一个文件 <code>ib_logfile0</code> 的格式如下：</p>
<p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/indb_file0_overview.png" alt="ib_logfile0"></p>
<p>从图中可以看到，日志文件中包含了文件头信息和具体的日志信息，这些日志信息分别写在每一个日志块中。</p>
<p>其它文件 <code>ib_logfile*</code> 的格式如下：</p>
<p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/indb_file1_overview.png" alt="ib_logfile*"></p>
<p>其它的日志文件内容格式基本一样，主要区别在 <code>checkpoint</code> 信息（ <code>checkpoint</code> 记录的是已经更新到数据文件中的 LSN）。</p>
<p>在深刻理解 <code>checkpoint</code> 的含义前，首先需要理解 <code>LSN</code>（ <code>og sequence number</code> ）的概念。</p>
<p><strong>什么是LSN？</strong></p>
<p><code>LSN</code> 表示日志记录创建开始到特定的日志记录已经写入的字节数。 <code>mysql</code> 通过 <code>LSN</code> 来判断是否需要刷新 <code>buffer</code> 到 <code>redolog</code> 上以及是否需要将 <code>redolog</code> 写到磁盘上。<code>LSN</code> 是单调递增的。</p>
<p>以我本地的数据库为例。</p>
<p>第一步，查看 <code>innodb</code> 的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status\G;</span><br></pre></td></tr></table></figure>
<p>部分结果如下(后面的数据就是 <code>LSN</code> )：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number          85755920</span><br><span class="line">Log buffer assigned up to    85755920</span><br><span class="line">Log buffer completed up to   85755920</span><br><span class="line">Log written up to            85755920</span><br><span class="line">Log flushed up to            85755920</span><br><span class="line">Added dirty pages up to      85755920</span><br><span class="line">Pages flushed up to          85755920</span><br><span class="line">Last checkpoint at           85755920</span><br></pre></td></tr></table></figure>

<p>然后我删除了 <code>MySQL</code> 中的一个数据库，再次查看 innodb 的状态，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number          85755974</span><br><span class="line">Log buffer assigned up to    85755974</span><br><span class="line">Log buffer completed up to   85755974</span><br><span class="line">Log written up to            85755974</span><br><span class="line">Log flushed up to            85755974</span><br><span class="line">Added dirty pages up to      85755974</span><br><span class="line">Pages flushed up to          85755920</span><br><span class="line">Last checkpoint at           85755920</span><br></pre></td></tr></table></figure>
<p>可以看到， <code>buffer</code> 中的 <code>LSN</code> 已经更新了，<code>redolog</code> 中日志记录的 <code>LSN</code> 也已经更新到最新，但是 <code>checkpoint</code> 还是之前的记录，因为 <code>checkpoint</code> 小于 <code>redolog</code> 最新的 <code>LSN</code> ，所以 <code>mysql</code> 认为需要将 <code>checkpoint</code> 之后的数据继续更新到数据文件中。</p>
<p>继续查看 <code>innodb</code> 的状态，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number          85755974</span><br><span class="line">Log buffer assigned up to    85755974</span><br><span class="line">Log buffer completed up to   85755974</span><br><span class="line">Log written up to            85755974</span><br><span class="line">Log flushed up to            85755974</span><br><span class="line">Added dirty pages up to      85755974</span><br><span class="line">Pages flushed up to          85755974</span><br><span class="line">Last checkpoint at           85755974</span><br></pre></td></tr></table></figure>

<p>这次可以看到，<code>checkpoin</code>t 已经更新成最新的 <code>LSN</code> 了，这表明之前没来的及更新到数据文件中 <code>redolog</code> 也已经更新进去了。所以最终全部的 <code>LSN</code> 是保持一致的。</p>
<p>再细的日志格式就不在这里展开了，我看的也不深，如果你想更深入的了解，一是可以去参考 <code>mysql</code> 的源码，或者参考下面的这两篇文章。</p>
<p><strong>注</strong>：这一节内容主要参考了文章 <a href="https://blog.51cto.com/wangwei007/2287431" target="_blank" rel="noopener">MySQL InnoDB redo Log 浅析</a> 和 <a href="http://mysql.taobao.org/monthly/2017/09/07/" target="_blank" rel="noopener">MySQL · 源码分析 · Innodb 引擎Redo日志存储格式简介</a>。</p>
<h3 id="2-5-为什么用-redolog-来保证事务的持久性？"><a href="#2-5-为什么用-redolog-来保证事务的持久性？" class="headerlink" title="2.5 为什么用 redolog 来保证事务的持久性？"></a>2.5 为什么用 redolog 来保证事务的持久性？</h3><blockquote>
<p>事务的持久性是指事务一旦提交就会永久生效</p>
</blockquote>
<p><code>redolog</code> 采用的机制是 <code>WAL</code> (Write-Ahead Logging) 机制，因此事务的持久性是通过日志的持久性实现的，即每次事务提交，在持久化一个数据页的时候，首先将数据页内容持久化到日志中。</p>
<p>为什么要采用 <code>WAL</code> 机制？因为将数据页写到日志中的时间要远远快于写到数据存储文件中。我们知道，<code>innodb</code> 底层的存储实现是 <code>B+Tree</code>，对数据页的寻址是通过指针决定的。如果执行多条 <code>update</code> 语句，影响的数据页在不同的磁盘块上，那么对计算机来说磁盘块的寻址会消耗很多时间；而如果是将这些数据页的变动直接写到日志文件中，因为是顺序写入，消耗的时间远远小于前者。</p>
<p>从 IO 次数来说，<code>WAL</code> 刷新是少量 IO，DaTa 刷新是大量 IO， <code>WAL</code> 刷新次数少得多；<br>从 IO 花销来说， <code>WAL</code> 刷新是连续IO，Data 刷新是随机IO， <code>WAL</code> 刷新花销小得多.</p>
<p>因此WAL机制在保证事务持久性和数据完整性的同时，成功地提升了系统性能。</p>
<p><strong>Tips</strong></p>
<p>redolog 除了用来保证事务的持久性，它所采用的 <strong>两阶段提交</strong> 机制也保证了事务的一致性。<strong>两阶段提交</strong> 涉及到 <code>binlog</code>，后续讲 <code>binlog</code> 的时候，会重点讲解下。</p>
<p>参考课程：<a href="https://time.geekbang.org/column/intro/100020801?code=rNEW29DDq73FD01HP-2AEicuNieaJ24KUQ9tYhCk1Ow%3D" target="_blank" rel="noopener">https://time.geekbang.org/column/intro/100020801?code=rNEW29DDq73FD01HP-2AEicuNieaJ24KUQ9tYhCk1Ow%3D</a></p>
<h2 id="三、结语"><a href="#三、结语" class="headerlink" title="三、结语"></a>三、结语</h2><p>相信经过上面的讲解，你应该对 <code>redolog</code> 的概念、用处有了一个清晰的认识，并且能根据不同的生产环境对相关的配置做出合适的调整。如果你希望对 <code>redolog</code> 的具体格式以及实现有更深入的理解，可以结合上文提到文章和源码继续深入了解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/openssl%E5%8D%87%E7%BA%A7%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tjjsjwhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tjjsjwhj的个人空间~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/openssl%E5%8D%87%E7%BA%A7%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">openssl升级教程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-09 01:23:21" itemprop="dateCreated datePublished" datetime="2020-01-09T01:23:21+08:00">2020-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-21 12:34:37" itemprop="dateModified" datetime="2020-06-21T12:34:37+08:00">2020-06-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/php/" itemprop="url" rel="index">
                    <span itemprop="name">php</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>openssl版本号的含义</strong></p>
<blockquote>
<p>OpenSSL version numbers are formatted as n1.n2.n3x, where n1-3 are numbers and x, if present, is one or more letters. These can change depending on the release type:</p>
<p>Major releases that change one/both of the first two digits, which can break compatibility with previous versions</p>
<p>Minor releases that change the last digit, e.g. 1.1.0 vs. 1.1.1, can and are likely to contain new features, but in a way that does not break binary compatibility. This means that an application compiled and dynamically linked with 1.1.0 does not need to be recompiled when the shared library is updated to 1.1.1. It should be noted that some features are transparent to the application such as the maximum negotiated TLS version and cipher suites, performance improvements and so on. There is no need to recompile applications to benefit from these features.</p>
<p>Letter releases, such as 1.0.2a, exclusively contain bug and security fixes and no new features.</p>
</blockquote>
<p>后面的字母表示bug的修复记录，那显然选字母越靠后，版本越稳定。</p>
<h2 id="openssl升级步骤"><a href="#openssl升级步骤" class="headerlink" title="openssl升级步骤"></a>openssl升级步骤</h2><h4 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h4><p><a href="https://www.openssl.org/source/" target="_blank" rel="noopener">下载地址</a></p>
<h4 id="解压编译"><a href="#解压编译" class="headerlink" title="解压编译"></a>解压编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf openssl-1.1.1d.tar.gz</span><br><span class="line"><span class="built_in">cd</span> openssl-1.1.1d</span><br><span class="line"><span class="comment"># --prefix是安装路径，--openssl是配置文件路径</span></span><br><span class="line">./config shared --prefix=/opt/openssl --openssldir=/usr/<span class="built_in">local</span>/ssl -D_GNU_SOURCE</span><br><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p><code>-D_GNU_SOURCE</code>并不是必须的，只有当出现错误提示 <code>&#39;pthread_mutex_recursive&#39; undeclared (first use in this function)</code> 才需要带上，这个一般是因为系统太老。(<a href="https://github.com/openssl/openssl/issues/2261" target="_blank" rel="noopener">相关问题链接</a>)</p>
<h4 id="检查动态链接"><a href="#检查动态链接" class="headerlink" title="检查动态链接"></a>检查动态链接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd /opt/openssl/bin/openssl</span><br></pre></td></tr></table></figure>
<p><strong>如果提示</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">libssl.so.1.1 =&gt; not found</span><br><span class="line">libcrypto.so.1.1 =&gt; not found</span><br><span class="line">libdl.so.2 =&gt; /lib64/libdl.so.2 (0x0000003f0b300000)</span><br><span class="line">libpthread.so.0 =&gt; /lib64/tls/libpthread.so.0 (0x0000003f0b900000)</span><br><span class="line">libc.so.6 =&gt; /lib64/tls/libc.so.6 (0x0000003f0b000000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x0000003f0ae00000)</span><br></pre></td></tr></table></figure>
<p>说明 <code>libssl.so.1.1</code> 等没有链接上，执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /opt/openssl/lib/libssl.so.1.1 /usr/lib64/libssl.so.1.1</span><br><span class="line">sudo ln -s /opt/openssl/lib/libcrypto.so.1.1 /opt/openssl/lib/libcrypto.so.1.1</span><br></pre></td></tr></table></figure>

<h4 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h4><p>执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/openssl/bin/openssl version</span><br></pre></td></tr></table></figure>
<p>显示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OpenSSL 1.1.1d  10 Sep 2019</span><br></pre></td></tr></table></figure>

<h2 id="PHP下升级openssl"><a href="#PHP下升级openssl" class="headerlink" title="PHP下升级openssl"></a>PHP下升级openssl</h2><p><strong>php下添加openss扩展有两种方式</strong></p>
<ol>
<li>PHP源码编译安装的时候，带上 <code>--with-openssl[=DIR]</code> ,</li>
<li>如果php已经安装完成了，不支持openssl，但是又不想重新编译，可以下载对应版本的php源码，解压进入到php/ext/openssl目录，执行 php/bin/phpize，生成configure文件，然后指定编译配置 <code>./configure --with-openssl[=DIR] --with-php-config=/php/bin/php-config</code>，<code>make</code>编译，生成 openssl.so，再在php.ini中开启即可。</li>
</ol>
<h2 id="PHP如何实现SM3签名算法？"><a href="#PHP如何实现SM3签名算法？" class="headerlink" title="PHP如何实现SM3签名算法？"></a>PHP如何实现SM3签名算法？</h2><blockquote>
<p>SM2、SMS3等加密签名算法是国密算法，openssl从1.1.1版本开始支持</p>
</blockquote>
<p>由于希望能在PHP中实现<code>SM3</code>算法，想着能否通过升级openssl的方式实现，调研了一天发现，仅通过<code>openssl</code>的升级，无法快速实现。</p>
<p><strong>原因如下</strong></p>
<blockquote>
<p>openssl1.1.1d的安装只是说在系统层面增加了openssl这个工具，安转完之后即可通过命令行的方式实现各种加密算法</p>
<p>php实现openssl扩展，其原理是通过php/ext/openssl下面的源码，编译实现从openssl工具到php中使用的加密函数的一个映射，检查php/ext/openssl下面的openssl.c文件发现，并没有包含openssl源码中实现SMS3等算法的头文件，所以不管怎么编译，生成的php下的openssl扩展都没有SM3函数</p>
</blockquote>
<p><strong>那如何实现在PHP中使用SMS3算法？</strong></p>
<ol>
<li>修改php/ext/openssl下面的代码，增加SM3等算法的映射，重新编译生成openssl.so （工程量较大，需要熟悉源码）</li>
<li>使用openssl的一个分支版本Gmssl。Gmssl在openssl的基础上实现了对一般国密算法的支持，同时提供了用于编译openssl.so的php/ext/openssl源码，编译生成openssl.so即可 (<strong>该方法尚未验证成，怀疑和PHP版本有关</strong>)</li>
<li>安装完openssl工具后，在PHP代码中直接执行linux命令：<code>echo -n &quot;abc&quot; | /opt/openssl/bin/openssl dgst -SM3</code> </li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/06/%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9A%84%E5%85%B3%E9%94%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tjjsjwhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tjjsjwhj的个人空间~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/06/%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9A%84%E5%85%B3%E9%94%AE/" class="post-title-link" itemprop="url">价值投资的关键</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-06 02:13:22" itemprop="dateCreated datePublished" datetime="2020-01-06T02:13:22+08:00">2020-01-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2/" itemprop="url" rel="index">
                    <span itemprop="name">投资理财</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="投资中最重要的事"><a href="#投资中最重要的事" class="headerlink" title="投资中最重要的事"></a>投资中最重要的事</h2><p><strong>认知和格局</strong></p>
<p>你能看到多么大的趋势，就能看到多少机会。你接触的人和信息，决定你有着怎样的视野，以及你看到的是怎样的一个世界。</p>
<p><strong>逻辑驱动买入，逻辑驱动卖出</strong></p>
<p>不要有偏见，一切以数据、和数据推演出的逻辑为准。以前涨不涨和以后涨不涨没关系，关注涨跌背后的逻辑，不要被个股波动的表象所影响。</p>
<h2 id="能力圈原则"><a href="#能力圈原则" class="headerlink" title="能力圈原则"></a>能力圈原则</h2><p><strong>清楚自己的能力圈</strong></p>
<p>围绕真正了解的企业画一个圈，排除不合格的企业。</p>
<p><strong>能力圈在精不在多</strong></p>
<p>对自己的能力圈拉爱说，最重要的不是能力圈的范围大小，而是你如何能够确定能力圈的便捷所在。</p>
<p><strong>坚守能力圈</strong></p>
<p>明白自己到底不知道什么，固收于自己相信和了解的公司。</p>
<p><strong>如何践行能力圈原则</strong></p>
<ol>
<li>清楚自己的状态</li>
<li>把自己变成行业专家</li>
<li>识别哪些是自己看得懂的机会（时长有时候是疯狂的，但不代表我们看不懂的东西都是疯狂的）</li>
</ol>
<p>具体而言，即：</p>
<ol>
<li>清楚自己能圈而行业知识和周期（均值回归，在股票市场上的应用，就是股价长期围绕价值中暑波动，涨多了跌，跌多了涨）</li>
<li>坚持一种风格</li>
<li>左做减法（三五个行业，十几家公司）</li>
<li>坚持自己的交易准则</li>
</ol>
<h2 id="完美的投资体系"><a href="#完美的投资体系" class="headerlink" title="完美的投资体系"></a>完美的投资体系</h2><ol>
<li>正确的方向和理念</li>
<li>寻找和听取能力圈公司的各种负面问题（好的公司、以及诚实的管理层非常稀缺，对于重仓持有的公司，我们尤其要挺别人的犀利观点，尤其是那些不看好的、负面的）</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tjjsjwhj</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/tjjsjwhj" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tjjsjwhj" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:tjjsjwhj@126.com" title="E-Mail → mailto:tjjsjwhj@126.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tjjsjwhj</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
