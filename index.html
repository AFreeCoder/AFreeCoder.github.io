<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="tjjsjwhj的个人空间~">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="tjjsjwhj的个人空间~">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="tjjsjwhj">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>tjjsjwhj的个人空间~</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">tjjsjwhj的个人空间~</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">自由，从这里开始</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/06/go-benchmark-pprof/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tjjsjwhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tjjsjwhj的个人空间~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/06/go-benchmark-pprof/" class="post-title-link" itemprop="url">Golang:一次结合benchmark和pprof的性能优化经历</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-06 18:44:15 / 修改时间：19:01:26" itemprop="dateCreated datePublished" datetime="2020-12-06T18:44:15+08:00">2020-12-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>testing 是go自带的一个轻量级的测试框架，主要有三个用途：单元测试(Test)，基准测试(Benchmark)以及示例测试(Example)。</p>
</blockquote>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>写go也有几个月了，一直没太关注类似 <code>benchmark</code> 之类的性能分析工具，只知道埋头写业务代码。直到前几天，工作上的一个项目遇到了性能瓶颈，需要分析一下原因，就用到了 <code>benchmark</code>。一顿分析，终于发现了程序中的”性能消耗大户“，颇有成就感。</p>
<h2 id="测试case准备"><a href="#测试case准备" class="headerlink" title="测试case准备"></a>测试case准备</h2><p>平时写代码的过程中，会经常写一些 <code>print</code> 或者 <code>debug</code> 函数，谁又能想到，这些 <code>print</code> 偷偷摸摸的消耗了多少 <code>CPU</code> 和 内存资源呢？</p>
<p>AES对称加密是业务代码中经常会用到的一种加密方式，但是编码习惯如果不好，或者测试代码忘了删，就会导致加密性能急剧下降。</p>
<p><strong>大师兄写的AES加密函数</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AesEncryptA</span><span class="params">(aesKey, IV, origin []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	block, err := aes.NewCipher(aesKey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	blocksize := block.BlockSize()</span><br><span class="line">	blockMode := cipher.NewCBCEncrypter(block, IV)</span><br><span class="line">	originData := PKCS5Pading(origin, blocksize)</span><br><span class="line">	crypted := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(originData))</span><br><span class="line">	blockMode.CryptBlocks(crypted, originData)</span><br><span class="line">	<span class="keyword">return</span> crypted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二师兄写的AES加密函数</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AesEncryptB</span><span class="params">(aesKey, IV, origin []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	block, err := aes.NewCipher(aesKey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	blocksize := block.BlockSize()</span><br><span class="line">	blockMode := cipher.NewCBCEncrypter(block, IV)</span><br><span class="line">	originData := PKCS5Pading(origin, blocksize)</span><br><span class="line">	crypted := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(originData))</span><br><span class="line">	blockMode.CryptBlocks(crypted, originData)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把加密结果打印到日志看看</span></span><br><span class="line">	f, _ := os.Create(<span class="string">"temp.log"</span>)</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	log.SetOutput(f)</span><br><span class="line">	log.Println(fmt.Sprintf(<span class="string">"encrypt res is %s"</span>, base64.StdEncoding.EncodeToString(crypted)))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> crypted</span><br></pre></td></tr></table></figure>

<p>乍一看，大师兄和二师兄写的差不多，只是二师兄多了一个把加密结果写到日志中的操作。</p>
<p><strong><em>就这么一点点的区别，性能能差多少呢?让我们把悬念留到最后。</em></strong></p>
<h2 id="benchmark-实施"><a href="#benchmark-实施" class="headerlink" title="benchmark 实施"></a>benchmark 实施</h2><p>假设当前项目中的代码就是二师兄写的，我们就来分析一下，当前的性能瓶颈到底在什么地方。</p>
<h3 id="benchmark编写"><a href="#benchmark编写" class="headerlink" title="benchmark编写"></a>benchmark编写</h3><p><strong>写benchmark几个注意点</strong>：</p>
<ul>
<li>文件名以 <code>_test.go</code> 结尾，如 <code>practice_test.go</code></li>
<li>函数名统一以 <code>Benchmark</code> 开头，参数是 <code>*testing.B</code></li>
<li>对于要测试的函数，函数外面套上一个 for 循环，for 循环次数的上限是 <code>b.N</code></li>
<li>为了排除其它流程的干扰，一般会在 for 循环前加上 <code>b.ResetTimer</code></li>
</ul>
<p><strong>对二师兄的加密函数写个基准测试</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAesEncryptB</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	aesKey := []<span class="keyword">byte</span>(<span class="string">"1234567890abcdef"</span>)</span><br><span class="line">	IV := []<span class="keyword">byte</span>(<span class="string">"7878676756564545"</span>)</span><br><span class="line"></span><br><span class="line">	originData := bytes.Repeat([]<span class="keyword">byte</span>&#123;<span class="number">28</span>&#125;, <span class="number">1</span>&lt;&lt;<span class="number">29</span>)</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		AesEncryptB(aesKey, IV, originData)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了更加明显的对比，这里我们测试的加密数据的大小是512MB（即 1&lt;&lt; 29）</p>
<h3 id="执行benchmark命令"><a href="#执行benchmark命令" class="headerlink" title="执行benchmark命令"></a>执行benchmark命令</h3><blockquote>
<p>testing 框架下的基准测试依赖 <code>go test</code> 工具</p>
</blockquote>
<p><strong>benchmark 命令示例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench BenchmarkAesEncryptB -run none -benchmem -cpuprofile cpuprofile.out -memprofile memprofile.out</span><br></pre></td></tr></table></figure>

<p>这个命令中的参数比较多，我们一个个的解释。</p>
<ul>
<li><code>-bench</code> 表示执行哪些基准测试函数，后面可以加需要执行的基准测试函数名称，也可以加 <code>.</code>，表示执行全部的基准测试函数。（其实 <code>-bench</code> 后面可以加正则表达式）</li>
<li><code>-run</code> 表示执行哪些单元测试和示例测试函数，一般会加none，表示都不执行</li>
<li><code>-benchmen</code> 表示打印函数执行过程中的内存分配</li>
<li><code>-cpuprofile</code> 表示将全过程的 <code>CPU</code> 的一些概要数据写到文件 <code>cpuprofile.out</code> 中</li>
<li><code>memprofile</code> 表示将全过程的内存的一些概要数据写到文件 <code>memprofile.out</code> 中</li>
</ul>
<p><strong>执行结果分析</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go_practice/benchmart_example</span><br><span class="line">BenchmarkAesEncryptB-8                 1        8570217455 ns/op        6218811264 B/op       55 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      go_practice/benchmart_example   9.985s</span><br></pre></td></tr></table></figure>

<p>从执行结果中能看到，for 循环每执行一次，耗时 8570217455 纳秒，同时会有55次内存分配操作，每次操作 6218811264 字节。</p>
<p>到这里，我们其实已经完成了基准测试的一个基本流程，也对二师兄的加密函数的性能和内存使用状况有了一个初步的认识。</p>
<p><strong>但是，我们还是不知道性能瓶颈在哪！！</strong></p>
<h2 id="终极杀器：benchmark-pprof"><a href="#终极杀器：benchmark-pprof" class="headerlink" title="终极杀器：benchmark + pprof"></a>终极杀器：benchmark + pprof</h2><blockquote>
<p>pprof 是 go 自带的 <code>CPU</code> 分析器，常用来分析性能瓶颈。</p>
</blockquote>
<p>在前面的基准测试中，我们生成了 <code>CPU</code> 概要文件 <code>cpuprofile.out</code> 以及内存概要文件 <code>memprofile.out</code>，现在可以派上大用场了。</p>
<p>pprof 既可以通过命令行交互的方式查看CPU（内存）的概要数据，也可以通过web的方式查看直观的图形化展示。这里我们主要通过web的方式来展示。</p>
<p><strong><em>当然，使用pprof工具前，你需要先安装 <code>graphviz</code>，如果是mac，执行 <code>brew install graphviz</code> 就行。</em></strong></p>
<h3 id="pprof-分析-CPU"><a href="#pprof-分析-CPU" class="headerlink" title="pprof 分析 CPU"></a>pprof 分析 CPU</h3><p><strong>执行命令</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof -http=<span class="string">":8081"</span> cpuprofile.out</span><br></pre></td></tr></table></figure>

<p>通过地址 <code>http://localhost:8081/ui/</code> 能看到</p>
<p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/go-benchmark-pprof/cpuprofile.png" alt="cpuprofile.png"></p>
<p>从这个截图中，我们很容易看到，加密部分总共耗时5.11s，完全用在加密上的耗时才0.76s，其它时间都是用在日志打印上和字符串转化上，</p>
<h3 id="pprof-分析内存"><a href="#pprof-分析内存" class="headerlink" title="pprof 分析内存"></a>pprof 分析内存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof -http=<span class="string">":8081"</span> memprofile.out</span><br></pre></td></tr></table></figure>

<p>通过地址 <code>http://localhost:8081/ui/</code> 能看到</p>
<p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/go-benchmark-pprof/memprofile.png" alt="memprofile.png"></p>
<p>从这个截图图中，我们很容易看到，5930.71MB的内存使用，真正用在加密上的才512MB以及对原始字符串padding操作的640MB，其它内存都耗费在字符串转化和各种 <code>print</code> 操作上。</p>
<p>很直观的，我们就知道了二师兄的代码问题就在那一段日志打印的操作上。</p>
<h3 id="优化二师兄的代码"><a href="#优化二师兄的代码" class="headerlink" title="优化二师兄的代码"></a>优化二师兄的代码</h3><p>根据上面的分析，我们需要优化的就是日志打印的那部分代码。二师兄的代码优化后其实就是大师兄的代码。</p>
<p>我们把大师兄和二师兄的代码放一起跑一遍基准测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench . -run none -benchmem -cpuprofile cpuprofile.out -memprofile memprofile.out</span><br></pre></td></tr></table></figure>

<p><strong>得到</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go_practice/benchmart_example</span><br><span class="line">BenchmarkAesEncryptA-8                 1        1174023307 ns/op        1207968624 B/op       13 allocs/op</span><br><span class="line">BenchmarkAesEncryptB-8                 1        7496300203 ns/op        6218810296 B/op       50 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      go_practice/benchmart_example   9.508s</span><br></pre></td></tr></table></figure>

<p>从 <code>CPU</code> 耗时上看，大师兄的代码耗时只有二师兄的 1/7，单次内存消耗只有二师兄的 1/5，并且内存分配次数也只有二师兄的 1/4 左右。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>二师兄在追赶大师兄的道路上，又前进了一大步，可喜可贺~~</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://my.oschina.net/solate/blog/3034188" target="_blank" rel="noopener">go benchmark 性能测试</a></p>
<p>[2] <a href="https://golang.org/cmd/go/#hdr-Testing_flags" target="_blank" rel="noopener">go testing</a></p>
<p><strong><em>原创不易，欢迎关注我的公众号：码农的自由之路</em></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/02/go-file-lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tjjsjwhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tjjsjwhj的个人空间~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/02/go-file-lock/" class="post-title-link" itemprop="url">golang下文件锁的使用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-02 03:26:00 / 修改时间：03:35:09" itemprop="dateCreated datePublished" datetime="2020-12-02T03:26:00+08:00">2020-12-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>题目是golang下文件锁的使用，但本文的目的其实是通过golang下的文件锁的使用方法，来一窥文件锁背后的机制。</p>
<h2 id="为什么需要文件锁"><a href="#为什么需要文件锁" class="headerlink" title="为什么需要文件锁"></a>为什么需要文件锁</h2><blockquote>
<p>只有多线程/多进程这种并发场景下读写文件，才需要加锁，</p>
</blockquote>
<p><strong>场景1-读写并发</strong></p>
<p>读写并发场景下，如果不加锁，就会出现读到脏数据的情况。想象一下，读文件的进程，读到第500字节，有其它进程以覆盖写的方式向文件中写入1000字节，那读进程读到的后500字节就是脏数据。</p>
<p><strong>场景2-写写并发</strong></p>
<p>写写并发场景下，如果不加锁，假设A进程先写0-1000字节，B进程写0-900字节，以此类推，最后一个进程写0-100字节，那最终的文件内容就是每个进程前100个字节拼接起来的错乱的内容了。</p>
<h2 id="文件锁的几个概念"><a href="#文件锁的几个概念" class="headerlink" title="文件锁的几个概念"></a>文件锁的几个概念</h2><p><strong>共享锁</strong></p>
<p>共享锁，也叫读锁。某个进程首次获取共享锁后，会生成一个锁类型的变量L，类型标记为共享锁。其它进程获取读锁的时候，L中的计数器加1，表示又有一个进程获取到了共享锁。这个时候如果有进程来获取排它锁，会获取失败。</p>
<p><strong>排它锁</strong></p>
<p>排它锁，也叫写锁。某个进程首次获取排他锁后，会生成一个锁类型的变量L，类型标记为排他锁。其它进程获取任何类型的锁的时候，都会获取失败。</p>
<p><strong>阻塞</strong></p>
<p>阻塞的意思是说，新的进程发现当前的文件（数据）被加锁后，会一直处于等待状态，直到锁被释放，才会继续下一步的行为。</p>
<p><strong>非阻塞</strong></p>
<p>非阻塞的意思是说，新的进程发现当前的文件（数据）被加锁后，立即返回异常。业务上需要根据具体的业务场景对该异常进行处理。</p>
<p>阻塞和非阻塞其实是进程遇到锁的时候的两种处理模式。</p>
<h2 id="golang下如何使用文件锁"><a href="#golang下如何使用文件锁" class="headerlink" title="golang下如何使用文件锁"></a>golang下如何使用文件锁</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, err := os.Create(<span class="string">"example.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">"create file example.txt failed"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    <span class="comment">// 非阻塞模式下，加共享锁</span></span><br><span class="line">    <span class="keyword">if</span> err := syscall.Flock(<span class="keyword">int</span>(f.Fd()), syscall.LOCK_SH|syscall.LOCK_NB); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">"add share lock in no block failed"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里进行业务逻辑</span></span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">if</span> err := syscall.Flock(<span class="keyword">int</span>(f.Fd()), syscall.LOCK_UN); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">"unlock share lock failed"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例中 <code>LOCK_SH</code> 表示当前获取的是共享锁，如果是 <code>LOCK_EX</code>，则表示获取的是排他锁。而 <code>LOCK_NB</code> 表示当前获取锁的模式是非阻塞模式，如果需要阻塞模式，不加这个参数即可。<code>LOCK_UN</code> 则表示解锁，即释放锁。</p>
<p>golang 下这种文件锁的使用方式其实是Linux下的系统级调用，使用的是Linux的原生的文件锁的相关能力。</p>
<h3 id="使用flock的几个注意点"><a href="#使用flock的几个注意点" class="headerlink" title="使用flock的几个注意点"></a>使用flock的几个注意点</h3><p>1、只要fd指向的是同一个文件指针，那么加锁解锁的行为都是继承和覆盖的（这个可以看最后的解释）。</p>
<p>2、flock这种方式加的是建议性锁，也就是说新的进程一上来不管三七二十一，不去通过flock获取锁，就对文件各种操作，也是可以正常生效的。</p>
<h2 id="说一说Linux下面的flock和fcntl"><a href="#说一说Linux下面的flock和fcntl" class="headerlink" title="说一说Linux下面的flock和fcntl"></a>说一说Linux下面的flock和fcntl</h2><p>和flock一样，fcntl也是系统级调用，但是在具体的使用上却有很大不用，并且两种锁互不干扰，用flock加锁，fcntl无法感知，反之也一样。</p>
<h3 id="建议性锁和强制锁"><a href="#建议性锁和强制锁" class="headerlink" title="建议性锁和强制锁"></a>建议性锁和强制锁</h3><p>flock加的是建议性锁，而fcntl加的是强制性锁。</p>
<p>建议性锁，本质是一种协议，约定读写操作前都去检查一下该文件是否有被其它进程加锁。如果不遵守该协议，一上来就对文件进行操作，不检查有没有锁，程序执行上是没有任何问题的，能执行成功。</p>
<p>强制性锁，才更像真正意义上的锁。只要加了锁，其它进程是无法执行非允许的操作的。</p>
<p>其实一些利用redis做的分布式锁，都是建议性锁。锁机的机制要生效，需要大家共同遵守这个约定才行。</p>
<h3 id="全局锁和局部锁"><a href="#全局锁和局部锁" class="headerlink" title="全局锁和局部锁"></a>全局锁和局部锁</h3><p>对于一个文件，flock加锁的范围是整个文件内容，而fcntl能对文件的任意部分加锁。</p>
<h3 id="锁的持有者问题"><a href="#锁的持有者问题" class="headerlink" title="锁的持有者问题"></a>锁的持有者问题</h3><p>flock认为，锁的持有者是文件表（可以理解为文件指针），所以对于fork和dup操作，他们都对应同一个文件指针，所有的操作都会作用到这个文件上。具体表现：</p>
<ul>
<li>A进程加锁，A的子进程进程可以解锁，新的操作会覆盖之前的操作</li>
<li>A进程加锁，A进程复制fd，仍然是可以通过新的fd操作文件锁，新的操作会覆盖之前的操作</li>
</ul>
<p>fcntl 认为，锁的持有者是进程。加锁和解锁的行为都是跟着进程走，具体表现为：</p>
<ul>
<li>A进程加锁，B进程得等A进程消亡或者解锁才能加锁</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/25134841" target="_blank" rel="noopener">被遗忘的桃源——flock 文件锁</a></p>
<p>[2] <a href="https://www.cnblogs.com/charlesblc/category/914733.html" target="_blank" rel="noopener">Linux文件锁学习-flock, lockf, fcntl</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/23/invest-pratice-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tjjsjwhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tjjsjwhj的个人空间~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/invest-pratice-2/" class="post-title-link" itemprop="url">财务自由实证#2</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-23 01:53:36" itemprop="dateCreated datePublished" datetime="2020-11-23T01:53:36+08:00">2020-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-29 13:33:38" itemprop="dateModified" datetime="2020-11-29T13:33:38+08:00">2020-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2/" itemprop="url" rel="index">
                    <span itemprop="name">投资理财</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p><strong>财务自由实证</strong> 系列的第零篇是 <a href="https://tjjsjwhj.me/2020/07/18/invest-pratice-0/" target="_blank" rel="noopener">财务自由实证#0</a>。</p>
<p>追求财务自由，并不是希望大富大贵，而是希望自由之后，能更有底气的把生命浪费在更”美好“的事物上，而无须担心生计问题。</p>
<h2 id="实证进展"><a href="#实证进展" class="headerlink" title="实证进展"></a>实证进展</h2><p>先上进展：<br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/invest_demostration2.jpeg" width="50%" height="50%"></p>
<p>当前进度：1.88%。相比上个月增加0.19%，呃，听上去有些微不足道。如果仔细看下就会发现，这1个多月中，总资产增加近1万，但是实际新增投入不到6000，这么一看，很惊喜有没有。</p>
<h2 id="投资计划的一些调整"><a href="#投资计划的一些调整" class="headerlink" title="投资计划的一些调整"></a>投资计划的一些调整</h2><p>这一个月中投资的观念发生了一些变化，具体表现就是新增资金不再定投宽基指数，全部改成跟投基金组合。</p>
<p>关于基金组合：</p>
<blockquote>
<p>由基金主理人结合自己的投资理念选择投资基金与比例，提供符合该理念的投资方案，并进行长期持续仓位管理与方案调整的产品。</p>
</blockquote>
<p>组合的买卖调仓操作都会通过短信、APP、微信服务号发送通知，当然跟不跟还是看自己。我的建议是既然选择了相信，就无脑跟投。</p>
<p>常用的两个软件是<strong>且慢</strong>和<strong>蛋卷基金</strong>，主要跟投两个组合，一个是<strong>E大</strong>(ETF拯救世界)的<strong>长赢计划</strong>，一个是<strong>Alex</strong>的<strong>日积月累</strong>。</p>
<p><strong>长赢计划</strong>19年初开始跟投，目前收益率60%，比较满意，就是本金有点少，才10000，颇为遗憾。补充一下，因为进去的时间点比较巧，刚好在低点，组合中的绝大部分基金组合持仓成本都比主理人的持仓成本低，所以这个收益率比主理人还要高。</p>
<p><strong>日积月累</strong>是19年12月开始跟，每月大概跟投1000左右，目前收益率20%多（由于是定投，这个收益率其实是低于组合的实际收益率的，此外，该组合中途也有不少获利了结的，实际收益是更高的）。整体比较满意，没法和<strong>长赢</strong>比，没办法，相比年初，那个时候市场已经起来了。</p>
<p>很高兴，目前为止，这两个组合的收益率都跑赢了沪深300。</p>
<h3 id="之前我是如何定投的"><a href="#之前我是如何定投的" class="headerlink" title="之前我是如何定投的"></a>之前我是如何定投的</h3><p>上一篇提到的养老金账户和教育金账户就是手动定投的，其中养老金账户归到了实证计划中，教育金账户另算。这两个账户的策略完全一致，都是按照低估值理论，定投沪深300、中证500和中证红利。</p>
<p>定投的策略依据的是低估值理论，月初执行定投（刚发完工资），具体执行的时候，会参考下蛋卷和且慢的指数估值，三个指数里面，谁低谁就多买一些（比例啥的，全都是拍脑袋），如此执行了大约1年多。</p>
<p>养老金的起投时间是2019年8月，截止目前收益率23.2%；教育金起投时间是2019年6月，截止目前收益率23.3%。粗看收益率还行，主要是因为上半年疫情的影响，指数大幅度下跌，那个时候除了严格的执行定投策略，还会不定期不定额的视市场情况，不断加仓。如果没有那段时间的频繁加仓，收益会逊色很多。</p>
<p>而且中间加仓的那段时间，天天看指数，每天都在想要不要加，加多少，后面又跌了怎么办，十分影响心情。</p>
<h3 id="调整方案"><a href="#调整方案" class="headerlink" title="调整方案"></a>调整方案</h3><p>基金组合的跟投有两种，一种是存量资金跟投，一种增量资金跟投（类似定投）。</p>
<p>打算已投部分全部调整到兴全基金管理的一个组合 <strong>兴全进取派选牛基</strong> 中，继续定投的组合还没想好，是且慢的 <strong>U定投</strong> 还是其它，等确定了，后续再公布。</p>
<h2 id="延迟退休"><a href="#延迟退休" class="headerlink" title="延迟退休"></a>延迟退休</h2><p>说一说最近比较火的《十四五规划建议》，该建议提出，实施渐进式延迟法定退休年龄。之前一直有传言的延迟退休，看这次是真的要落地了。</p>
<p>客观来说，延迟退休这个事迟早都是要来的，原因有三点：</p>
<p><strong>1. 人口预期寿命大幅增长</strong></p>
<p>当前退休年龄是上个世纪50年代指定的，那个时候人口平均预期寿命较低，才45岁左右，如今人口平均寿命大幅增加到77岁。退休年龄不变的情况下，养老金支出会迅猛增加。</p>
<p>假定一个人25岁开始工作，55岁退休，平均寿命是60岁，工作期间每年缴纳的养老金就是退休之后每年领取的退休金，那么一个劳动力能供养6个退休人员。但是如果平均寿命增加到77岁（2019年数据），那么一个劳动力仅能供养一个退休人员。何况一个劳动力每年缴纳的养老金远远少于之后每年领取的退休金，得多个劳动力才能供养一个退休人员。</p>
<p>所以说在不调整退休年龄的情况之下，如果平均寿命大幅增加，养老金压力会越来越大，但显而易见，平均寿命还会继续增加。</p>
<p><strong>2. 计划生育，中国提前步入老年化</strong></p>
<p>计划生育的一个影响是，新生儿出生率呈断崖式的下跌。这意味着劳动力人口的增长率页呈下跌趋势。</p>
<p>计划生育从70年代开始实施，70年代末后正式成为一项基本国策。以此推算，到2020年，实行计划生育之前出生的女性职工正式开始退休，到2030年，实行计划剩余之前的男性职工也开始正式退休。</p>
<p>目前，中国60岁以上的人口2.52亿，而1963年到1970年间出生的人口大约3亿，也就是说到2030年，60岁以上的人口将到5亿，这是很可怕的。</p>
<p>这么多的老年人口，对养老保险而言，是个很大很重的负担。</p>
<p><strong>3. 中国养老保险制度实施较晚</strong></p>
<p>中国的养老保险制度发展颇为曲折，直到1997年，才决定实施社会统筹和个人缴纳相结合的新的养老保险制度。</p>
<p>这就出现了养老保险的隐形债务问题。由于已经工作和退休的人员没有过去的积累，而他们又必须按新制度领取养老金，那么他们应得的，实际有没有缴纳的那部分，就是隐形的债务。</p>
<p>因为社会统筹的资金远远不够支付庞大的退休群体的需要。各省、市、县为了按时足额发放养老金，就挪用了本应是将来才能支付的现在在职职工个人账户的资金(社会统筹和个人账户没有分开管理)，从而造成了全国范围内养老金的有名无实，空账运行。</p>
<p>公开数据显示，我国养老保险个人账户空账规模已经超过1万多亿，虽然做实空账工作已经开展几年，但是空账规模扔在扩大。从债务关系来说，养老金的空账运转是现在向未来透支，是老一代向年轻一代的透支。长此下去必然蕴涵巨大的资金风险，</p>
<h3 id="如何应对延迟退休"><a href="#如何应对延迟退休" class="headerlink" title="如何应对延迟退休"></a>如何应对延迟退休</h3><p>首先我们要摒弃一个观念，即退休之后，完全靠退休金生活（体制内除外），不信，看下面各个年代的口号：</p>
<blockquote>
<p>1985年，宣传口号是”计划生育好，政府来养老”</p>
</blockquote>
<blockquote>
<p>1995年，宣传“只生一个好，政府帮养老”</p>
</blockquote>
<blockquote>
<p>2005年，宣传“养老不能全靠政府“</p>
</blockquote>
<blockquote>
<p>2012年，推出“推迟退休好，自己来养老”</p>
</blockquote>
<p>再过几年，会是啥口号呢，你猜~~</p>
<p>既然延迟退休是无法避免的趋势，那我们应该如何应对延迟退休呢？答案就是尽早开始自己的储蓄计划，无论是财务自由计划，还是养老金储蓄计划，都应该早早的开始。等到了真退休的时候，国家的每一笔退休金，都可以当成额外的收入，岂不美哉？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/10/invest-pratice-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tjjsjwhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tjjsjwhj的个人空间~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/10/invest-pratice-1/" class="post-title-link" itemprop="url">财务自由实证#1</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-10 23:20:05" itemprop="dateCreated datePublished" datetime="2020-10-10T23:20:05+08:00">2020-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-11 20:03:57" itemprop="dateModified" datetime="2020-10-11T20:03:57+08:00">2020-10-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2/" itemprop="url" rel="index">
                    <span itemprop="name">投资理财</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这个系列的第零篇是 <a href="https://tjjsjwhj.me/2020/07/18/invest-pratice-0/" target="_blank" rel="noopener">财务自由实证#0</a>，原本打算每月一篇，没想到这都过去两个月了。过去的就不补了，从10月份开始，立个flag，每月1篇。</p>
<h2 id="实证进展"><a href="#实证进展" class="headerlink" title="实证进展"></a>实证进展</h2><p>先看下当前进展。</p>
<img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/demonstration1.png" width="50%" height="50%">

<p>当前进展 1.69%，本周上涨：无。图中记录的软件是且慢小账本（微信小程序），纯手动记录，由于开始几次记录的不完整，收益率等指标可能有偏差，等多记录几次就好了。</p>
<p>虽然这个实证计划最近才开始，但是实际上投资计划已经开始一年多了，不能完全算从0开始。开始投资的时候，还没有通过投资实现财务自由的想法，纯粹就是希望不贬值，能涨一些就更好。所以当前的账户体系比较混乱，有自己的养老金，也有小孩的教育金，还有一时冲动跟投的不同的投资组合。具体有以下几块：</p>
<table>
<thead>
<tr>
<th>计划</th>
<th>投资平台</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>长赢计划-150</td>
<td>且慢</td>
<td>主理人E大的公开计划，跟投</td>
</tr>
<tr>
<td>养老金计划</td>
<td>且慢</td>
<td>定投，不同指数基金的组合，瞎折腾</td>
</tr>
<tr>
<td>教育金计划</td>
<td>且慢</td>
<td>定投，不同指数基金的组合，瞎折腾</td>
</tr>
<tr>
<td>日积月累</td>
<td>蛋卷</td>
<td>主理人Alex的公开计划，跟投</td>
</tr>
<tr>
<td>2020短期计划</td>
<td>且慢</td>
<td>瞎折腾，指数基金</td>
</tr>
<tr>
<td>其它组合跟投</td>
<td>且慢</td>
<td>如云长进取等组合</td>
</tr>
</tbody></table>
<p>这两天重新梳理了下，觉得将非教育金计划的其它计划都归入到500万的目标中比较合理。因此当前以及之后的统计中均不会包含教育金计划。上文的截图就是除教育金计划之外的总额。</p>
<h2 id="如何开始自己的自由计划"><a href="#如何开始自己的自由计划" class="headerlink" title="如何开始自己的自由计划"></a>如何开始自己的自由计划</h2><blockquote>
<p>在真正重要的事情面前，我们一定要慎重，不能轻易的下决定，尤其是涉及到投资的时候。</p>
</blockquote>
<p>如果我们在买衣服甚至买菜的时候能花上半小时和老板讨价还价，并为节省下来的几十、几百暗爽不已，那么在面对投资的时候，就更有必要慢下来好好规划自己手上本就为数不多的本金了。</p>
<p>目前我的投资体系还在摸索中，同时参考其他人的方法，可以初步分为以下几个步骤：</p>
<ul>
<li>彻底了解自己</li>
<li>规划紧急备用金</li>
<li>规划必要的保险</li>
<li>规划3年内要用的钱</li>
<li>建立长期投资组合</li>
</ul>
<h3 id="彻底了解自己"><a href="#彻底了解自己" class="headerlink" title="彻底了解自己"></a>彻底了解自己</h3><p>这一步有3个目标：摸清自己手上有多少资金、平均每月支出多少、平均每月结余多少。</p>
<p>这一步看起来容易，却也不太容易。相信没有多少人能在10分钟内给出答案。然而这一步也是进行后面几步的前提。如果大家平时有记账习惯的话，这一步就很容易，没有的话，支付宝、微信、各银行软件等都有账本功能，能比较容易的统计出来。</p>
<p>所以到这，大家不妨先花时间好好梳理下，看下手里有多少钱，每月平均支出多少，又有多少结余。</p>
<h3 id="规划紧急备用金"><a href="#规划紧急备用金" class="headerlink" title="规划紧急备用金"></a>规划紧急备用金</h3><p>开启投资第一步，规划家庭紧急备用金。</p>
<p>这一步是投资新手们极易忽略却又是十分重要的一步。是否规划了紧急备用金直接关系着后面的长期投资组合能否顺利进行。</p>
<p>投资路上，难免会遇到各种各样的意外。小到去个急诊，大到忽然失业等。相信经历了2020年上半年之后，大家对意外情况能有一个更深的认识。</p>
<p>紧急备用金的作用就是当你真的突然需要用钱的时候，可以无视当前的市场行情，坦然渡过。经常有投资的朋友说，自己清楚的知道当前市场处于谷底，也清楚的知道此时正是需要坚持的时候，但是因为这样或者那样的无奈，必须把用于长期投资的资金提取出来，十分可惜。</p>
<p>一般而言，家庭紧急备用金需要能覆盖6个月的支出。也就是如果一家人忽然没有任何收入来源，仍然能维持当前生活水平继续生活6个月。注意，这里的支出是要全方位的覆盖，比如常规生活支出、房贷、房租、社保、医保等。</p>
<p>紧急备用金的要求是安全和随存随取。安全意味着比较合适的投资途径就是货币基金、国债或者银行存款。随存随取意味着比较合适的途径就是货币基金（余额宝等）和银行存款（短期存款，）了。</p>
<h3 id="规划必要的保险"><a href="#规划必要的保险" class="headerlink" title="规划必要的保险"></a>规划必要的保险</h3><p>保险的重要性怎么强调都不为过。哪怕你没有实现财务自由的计划和想法，也需要给自己和家人配置一份完善的保险。</p>
<p>大多数人家里都没矿，并且谁也不能保证不会遇到重大疾病或者事故。而且但凡遇到，就不是紧急备用金能解决的，甚至把家底掏空都有可能。所以在配置了紧急备用金之后，一定要尽快的把必要的保险都配置上，这样才能在投资长跑中没有后顾之忧</p>
<p>但是也不能本末倒置，保险的作用是为我们在实现既定目标的路上，保驾护航，保险并不是我们的目标。因此这部分配置完善即可，不需要过度配置。</p>
<h3 id="规划3年内要用的钱"><a href="#规划3年内要用的钱" class="headerlink" title="规划3年内要用的钱"></a>规划3年内要用的钱</h3><p>这一步的作用和紧急备用金的作用类似，都是为了防止突然从长期组合中取钱而影响收益。</p>
<p>不一样的是如果出现了需要用紧急备用金的情况，意味着这个钱是立马就需要用的，而如果是3年内要用的钱，通常都有缓冲的余地，不用立刻筹集。此外，3年内要用的钱不像紧急备用金那样可以准确估算，常见的开销有买房、买车、结婚、装修、生小孩等，所以这一步的估算大家只能根据自己的实际情况尽可能的估计了。</p>
<p>3年内要用的钱意味着它的流动性要求没有那么高，比较合适的投资方式就是定期理财和债券基金。如果持有事件超过半年，一般是债券基金收益更高，更推荐。</p>
<h3 id="建立长期投资组合"><a href="#建立长期投资组合" class="headerlink" title="建立长期投资组合"></a>建立长期投资组合</h3><p>在我的计划里，长期投资组合的目标就是财务自由的目标。所以以后每一期公布的实证进展就是长期投资组合的进展。</p>
<p>前面几步都是一次性配置，之后就不用管了，而长期投资组合这部分是最耗精力的。这一步，你有各种各样的选择，可以投资股票、基金、债券、黄金等，也可以投资各种股票基金、债券基金，亦或是无脑跟投你信任的主理人的组合。</p>
<p>关于如何建立长期投资组合，这一块需要讲述的很多。在后续的文章中我会结合我自己的经验，慢慢的展开。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>第一期实证，暂时先讲这么多。之后的实证计划中，我会详细的介绍我当前的组合，并分析优劣。希望在这个过程中，能不断的提升自己的认知，进一步完善自己的长期投资组合，同时也能向你们证明，工薪族仅仅依靠工资是能实现财务自由的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/19/faq-bot-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tjjsjwhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tjjsjwhj的个人空间~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/19/faq-bot-1/" class="post-title-link" itemprop="url">FAQBot 实践系列#1 —— 从开源语料入手</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-19 15:26:31 / 修改时间：15:30:47" itemprop="dateCreated datePublished" datetime="2020-09-19T15:26:31+08:00">2020-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NLP/" itemprop="url" rel="index">
                    <span itemprop="name">NLP</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="语料"><a href="#语料" class="headerlink" title="语料"></a>语料</h2><p>FAQBot构建的基础是有一份高质量的问答语料。通过不断的搜索和查找，找到一份 <code>保险行业</code> 的问答语料：<a href="https://github.com/chatopera/insuranceqa-corpus-zh" target="_blank" rel="noopener">insuranceqa-corpus-zh</a></p>
<h3 id="语料背景"><a href="#语料背景" class="headerlink" title="语料背景"></a>语料背景</h3><p>该语料库包含从网站 <a href="https://www.insurancelibrary.com/" target="_blank" rel="noopener">Insurance Library</a> 收集的问题和答案。<br>以下是官方介绍：</p>
<blockquote>
<ul>
<li><p>该语料库的内容由现实世界的用户提出，高质量的答案由具有深度领域知识的专业人士提供。 所以这是一个具有真正价值的语料，而不是玩具。</p>
</li>
<li><p>在上述论文中，语料库用于答复选择任务。 另一方面，这种语料库的其他用法也是可能的。 例如，通过阅读理解答案，观察学习等自主学习，使系统能够最终拿出自己的看不见的问题的答案。</p>
</li>
<li><p>数据集分为两个部分“问答语料”和“问答对语料”。问答语料是从原始英文数据翻译过来，未经其他处理的。问答对语料是基于问答语料，又做了分词和去标去停，添加label。所以，”问答对语料”可以直接对接机器学习任务。如果对于数据格式不满意或者对分词效果不满意，可以直接对”问答语料”使用其他方法进行处理，获得可以用于训练模型的数据。</p>
</li>
</ul>
</blockquote>
<h3 id="语料格式"><a href="#语料格式" class="headerlink" title="语料格式"></a>语料格式</h3><p>训练数据之前，我们先仔细看下语料的格式。</p>
<h4 id="原始语料"><a href="#原始语料" class="headerlink" title="原始语料"></a>原始语料</h4><p>原始语料的目录是 <code>/corpus/pool</code>。 </p>
<p><strong>问题</strong></p>
<p>train，test，valid 是存放问题的文件，分别对应着训练集、测试集和验证集。对应的 txt 文件中是中英对照的问题，json 文件中的信息比较全，包含了中英对照的问题，问题的领域（类别），对应的答案以及错误的答案（负样本）。示例如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"0"</span>: &#123;</span><br><span class="line">        <span class="attr">"zh"</span>: <span class="string">"医疗保险拿起公司支付吗？"</span>,</span><br><span class="line">        <span class="attr">"en"</span>: <span class="string">"Does  Medicare  Pick  Up  Co  Pays?"</span>,</span><br><span class="line">        <span class="attr">"domain"</span>: <span class="string">"medicare-insurance"</span>,</span><br><span class="line">        <span class="attr">"answers"</span>: [</span><br><span class="line">            <span class="string">"4436"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"negatives"</span>: [</span><br><span class="line">            <span class="string">"1650"</span>,</span><br><span class="line">            <span class="string">"14016"</span>,</span><br><span class="line">            <span class="string">"24487"</span>,</span><br><span class="line">            <span class="string">"18224"</span>,</span><br><span class="line">            <span class="string">"15953"</span>,</span><br><span class="line">            <span class="string">"16740"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>zh</code> 是根据答案原文翻译过来的，翻译质量一般。比如示例中英文的意思其实是问【医疗保险会承担挂号费吗】（ <code>co-pay</code> 是看医生前需要支付的定额费用，类似挂号费），如果直接看翻译就不知所云了。<code>answers</code> 和 <code>negatives</code> 中的数字表示对应答案的id，下面会提到。</p>
<p><strong>答案</strong></p>
<p><code>answers</code> 中包含了答案的id和答案的中英文对照。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"0"</span>: &#123;</span><br><span class="line">        <span class="attr">"zh"</span>: <span class="string">" 汽车跟随着。示例1：如果你被给了一辆汽车（借给），那辆车没有保险，你可以在汽车上买保险，你的保险将是主要的。另一个选择，有人帮你买车。例如，您的信用评分不足以融资，因此您的朋友在您的贷款下签署了主要付款人。您可以根据您的姓名获得保险，甚至将您的朋友列为保险单，作为损失赔偿人。在这种情况下，我们总是建议您获得贷款差距：汽车的实际现金价值与其仍然拥有的金额之间的差额。例2：你借的车有保险。您可以以您的名义购买政策，列出该政策的车辆，如果发生事故，您的政策将成为次要或超额。一旦主要汽车保险的限制用尽，您的保险将踢入，并希望支付其余费用。我特意用了这个词，因为每个事故都是独一无二的，没有实际的索赔情况就很难解释这个覆盖面。即使在给定的索赔情况下，有时索赔有两个可能的结果。"</span>,</span><br><span class="line">        <span class="attr">"en"</span>: <span class="string">" Coverage follows the car. Example 1: If you were given a car (loaned) and the car has no insurance, you can buy insurance on the car and your insurance will be primary. Another option, someone helped you to buy a car. For example your credit score isn't good enough to finance, so a friend of yours signed under your loan as a primary payor. You can get insurance under your name and even list your friend on the policy as a loss payee. In this case, we always suggest you get a loan gap coverage: the difference between the car's actual cash value and the amount still owned on it. Example 2: The car you are loaned has insurance. You can buy a policy under your name, list the car on that policy and in case of the accident, your policy will become a secondary or excess. Once the limits of the primary car insurance are exhausted, your coverage would kick in and hopefully pay for the rest. I specifically used the word hopefully, because each accident is unique and it's hard to interpret the coverage without the actual claim scenario. And even with a given claim scenario, sometimes there are 2 possible outcomes of a claim."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="加工语料"><a href="#加工语料" class="headerlink" title="加工语料"></a>加工语料</h4><blockquote>
<p>使用原始语料，还需要做很多工作才能进入机器学习的模型，比如分词，去停用词，去标点符号，添加label标记。所以，在原始语料的基础上，，insuranceqa-corpus-zh提供了一个使用HanLP分词和去标，去停，添加label的数据集，这个数据集完全是基于原始语料</p>
</blockquote>
<p>加工语料的目录是：<code>corpus/pairs</code></p>
<p><strong>词表</strong><br><code>vocab_data</code> 包含<code>word2id</code> (dict, 从word到id), <code>id2word</code> (dict, 从id到word),<code>tf</code> (dict, 词频统计)和 <code>total</code> (单词总数)。 其中，未登录词的标识为 <code>UNKNOWN</code>，未登录词的id为0。</p>
<p><strong>数据格式</strong><br>train、test、valid中的数据格式一直。示例中 <code>qid</code> 对应原始语料中问题的 <code>id</code>。 <code>question</code> 中的数值表示分词后，该词对应的<code>id</code>，即 <code>word2id</code> 的查表结果。<code>utterance</code> 是回复，<code>label</code> 如果是 <code>[1,0]</code> 代表回复是正确答案，<code>[0,1]</code> 代表回复不是正确答案，所以 <code>utterance</code> 包含了正例和负例的数据。每个问题含有10个负例和1个正例。该项目并没有说明负样本的采集方式。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"qid"</span>:<span class="string">"344"</span>,</span><br><span class="line">    <span class="attr">"question"</span>:[</span><br><span class="line">        <span class="number">2462</span>,<span class="number">3206</span>,<span class="number">8878</span>,<span class="number">17449</span>,<span class="number">11331</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"utterance"</span>:[</span><br><span class="line">        <span class="number">8878</span>,<span class="number">17449</span>,<span class="number">11331</span>,<span class="number">3206</span>,<span class="number">9757</span>,<span class="number">21338</span>,<span class="number">4757</span>,<span class="number">11331</span>,<span class="number">13381</span>,<span class="number">10310</span>,<span class="number">10114</span>,<span class="number">6069</span>,<span class="number">5231</span>,<span class="number">13346</span>,<span class="number">4185</span>,<span class="number">12750</span>,<span class="number">6568</span>,<span class="number">5425</span>,<span class="number">3206</span>,<span class="number">10114</span>,<span class="number">11705</span>,<span class="number">6194</span>,<span class="number">13402</span>,<span class="number">23991</span>,<span class="number">11273</span>,<span class="number">8231</span>,<span class="number">490</span>,<span class="number">10299</span>,<span class="number">9757</span>,<span class="number">9843</span>,<span class="number">18157</span>,<span class="number">13334</span>,<span class="number">23611</span>,<span class="number">1907</span>,<span class="number">10099</span>,<span class="number">6568</span>,<span class="number">7344</span>,<span class="number">1704</span>,<span class="number">16818</span>,<span class="number">2311</span>,<span class="number">6683</span>,<span class="number">12268</span>,<span class="number">7197</span>,<span class="number">9757</span>,<span class="number">11869</span>,<span class="number">23800</span>,<span class="number">10617</span>,<span class="number">1134</span>,<span class="number">22430</span>,<span class="number">23810</span>,<span class="number">9843</span>,<span class="number">14297</span>,<span class="number">10227</span>,<span class="number">14005</span>,<span class="number">5526</span>,<span class="number">12360</span>,<span class="number">13467</span>,<span class="number">16917</span>,<span class="number">22724</span>,<span class="number">22086</span>,<span class="number">24346</span>,<span class="number">20333</span>,<span class="number">12268</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"label"</span>:[<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="语料统计"><a href="#语料统计" class="headerlink" title="语料统计"></a>语料统计</h3><table>
<thead>
<tr>
<th>语料集</th>
<th>类别（Q/A）</th>
<th>最大长度</th>
<th>平均长度</th>
</tr>
</thead>
<tbody><tr>
<td>train</td>
<td>Q</td>
<td>42</td>
<td>5</td>
</tr>
<tr>
<td>train</td>
<td>A</td>
<td>878</td>
<td>162</td>
</tr>
<tr>
<td>test</td>
<td>Q</td>
<td>33</td>
<td>5</td>
</tr>
<tr>
<td>test</td>
<td>A</td>
<td>878</td>
<td>161</td>
</tr>
<tr>
<td>valid</td>
<td>Q</td>
<td>31</td>
<td>5</td>
</tr>
<tr>
<td>878</td>
<td>A</td>
<td>878</td>
<td>165</td>
</tr>
</tbody></table>
<h2 id="Baseline复现"><a href="#Baseline复现" class="headerlink" title="Baseline复现"></a>Baseline复现</h2><h3 id="环境准备-训练"><a href="#环境准备-训练" class="headerlink" title="环境准备+训练"></a>环境准备+训练</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// git <span class="built_in">clone</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:chatopera/insuranceqa-corpus-zh.git</span><br><span class="line"></span><br><span class="line">// 安装环境依赖</span><br><span class="line">pip install -r Requirements.txt</span><br><span class="line"></span><br><span class="line">// 更新数据处理的代码</span><br><span class="line">pip install --upgrade insuranceqa_data</span><br><span class="line"></span><br><span class="line">// 模型训练</span><br><span class="line">python3 deep_qa_1/network.py</span><br></pre></td></tr></table></figure>

<p>训练的过程中可能会出现以下错误：</p>
<ol>
<li>ssl.SSLError 问题<ul>
<li>原因是 insuranceqa_data 加载数据的时候，读取数据的路径是绝对路径，读不到数据文件，触发下载，需要修改 insuranceqa_data 中的加载路径为：<code>curdir = os.getcwd()</code> </li>
<li>本质原因是 Python3 请求https时，会对ssl进行校验，要么安装证书，要么关闭校验，具体方法百度即可。</li>
</ul>
</li>
<li>ImportError: Python is not installed as a framework. <ul>
<li>mac 下使用matplotlib画图可能会出现这个问题。根据报错提示，在涉及画图的代码中加上 <code>import matplotlib; matplotlib.use(&#39;TkAgg&#39;)</code> 即可</li>
</ul>
</li>
</ol>
<h3 id="训练结果"><a href="#训练结果" class="headerlink" title="训练结果"></a>训练结果</h3><p><strong>主要训练参数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hidden_layers &#x3D; [100, 50]</span><br><span class="line">question_max_length &#x3D; 20</span><br><span class="line">utterance_max_length &#x3D; 99</span><br><span class="line">lr &#x3D; 0.001</span><br><span class="line">epoch &#x3D; 50</span><br><span class="line">batch_size &#x3D; 100</span><br></pre></td></tr></table></figure>

<p><strong>准确率</strong></p>
<p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/insuranceqa_baseline_accuracy.png" alt="accuracy"></p>
<p><strong>loss变化</strong></p>
<p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/insuranceqa_baseline_loss.png" alt="loss"></p>
<p>可以看到，准确率到了0.9之后几乎就不变了，loss开始下降的很快，之后在0.8附近剧烈波动，说明这个时候再进行更多的迭代训练并不会对准确率的提升有显著的效果，baseline的方法已经到了极限，需要寻找更好的算法了。</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>至此，baseline 已经复现完毕。接下来的文章准备以此为基础，不断优化算法，在此基础之上尽可能的提高准确率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/18/invest-pratice-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tjjsjwhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tjjsjwhj的个人空间~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/18/invest-pratice-0/" class="post-title-link" itemprop="url">财务自由实证#0</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-18 15:28:09" itemprop="dateCreated datePublished" datetime="2020-07-18T15:28:09+08:00">2020-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-11 20:01:34" itemprop="dateModified" datetime="2020-10-11T20:01:34+08:00">2020-10-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2/" itemprop="url" rel="index">
                    <span itemprop="name">投资理财</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>受公众号 <code>【也谈钱】</code> 的影响，以及互联网加班的摧残，觉得有必要早早的开始梳理家庭的财务状况，并且制定财务自由的目标和方案，为自由而奋斗。</p>
<h2 id="财务自由的目标"><a href="#财务自由的目标" class="headerlink" title="财务自由的目标"></a>财务自由的目标</h2><p>设置 <strong>财务自由</strong> 的目标前，首先需要知道财务自由的定义，明确自己需要实现的是哪种等级的财务自由，才能以此为依据，制定出切实可行的计划，并开始行动。</p>
<p>这里我拍脑袋定了一个目标：</p>
<ul>
<li><strong>目标</strong>：500万（流动性资产）</li>
<li><strong>期限</strong>：25年</li>
</ul>
<p>下面详细解释下这个脑袋是怎么拍的。</p>
<h3 id="什么是财务自由？"><a href="#什么是财务自由？" class="headerlink" title="什么是财务自由？"></a>什么是财务自由？</h3><p>经常能看到一些标题党文章如 <a href="https://www.sohu.com/a/309461248_120139549" target="_blank" rel="noopener">2.9亿？！《2019北京财务自由等级图鉴》出炉！</a> 等等，看完之后瞬间觉得财务自由此生无望。。。</p>
<p><strong>实际上</strong></p>
<blockquote>
<p>财务自由是指你无需为生活开销而努力为钱工作的状态。简单地说，你的资产产生的被动收入必须至少要等于或超过你的日常开支。–<a href="https://zh.wikipedia.org/wiki/%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1" target="_blank" rel="noopener">wikipedia</a></p>
</blockquote>
<p>根据上面的定义，实现了被动收入大于日常开支就能实现财务自由。听起来很简单有没有~~</p>
<p>被动收入的等级无法衡量，但是日常支出是可以衡量的。结合近几年财务自由越来越丰富的内涵，财务自由的等级可以戏分如下：</p>
<ul>
<li>外卖自由</li>
<li>打车自由</li>
<li>商场自由</li>
<li>租房自由</li>
<li>旅游自由</li>
<li>辞职自由</li>
<li>买车自由</li>
<li>买房自由<br>……</li>
</ul>
<p>我这里使用的并且希望达到的目标就是财务自由最原本的定义，即日常生活开销的自由。</p>
<h2 id="财务自由的可行性"><a href="#财务自由的可行性" class="headerlink" title="财务自由的可行性"></a>财务自由的可行性</h2><p>理论上被动收入没有上限，但是实现的难度也成指数上升，因此这里通过对日常生活开销的预估来倒推需要多少被动收入。</p>
<h3 id="日常开销预估"><a href="#日常开销预估" class="headerlink" title="日常开销预估"></a>日常开销预估</h3><p>因为实现财务自由一定是很多很多年后，我们需要根据当前的生活水平来推断20年甚至30年之后的日常开支水平。下面尝试通过一些数据的分析来预估25年后的日常开销。</p>
<h4 id="通货膨胀"><a href="#通货膨胀" class="headerlink" title="通货膨胀"></a>通货膨胀</h4><p>一说到财务自由的具体目标，很多小伙伴都会想到通货膨胀，说你现在定这么一个目标，多少年之后，钱早就不值钱了，有什么用？</p>
<p>确实，通货膨胀的因素不能不考虑。</p>
<blockquote>
<p>在实践中，一般不直接、也不可能计算通货膨胀率，而是通过价格指数的年增长率来间接表示。</p>
</blockquote>
<blockquote>
<p>由于居民消费价格是反映商品经过流通各环节形成的最终价格，它最全面地反映了商品流通对货币的需要量，因此，居民消费价格指数是最能充分、全面反映通货膨胀率的价格指数。目前，世界各国基本上均用居民消费价格指数，也就是CPI来反映通货膨胀的程度。</p>
</blockquote>
<p>看下几个主要国家居民消费价格指数(CPI)年率（同比）数据。</p>
<p><strong>中国居民消费价格指数年率</strong><br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/China_cpi_year.png" alt="中国居民消费价格指数年率"></p>
<p><strong>日本居民消费价格指数年率</strong><br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/Japan_cpi_year.png" alt="日本居民消费价格指数年率"></p>
<p><strong>美国居民消费价格指数年率</strong><br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/USA_cpi_year.png" alt="美国居民消费价格指数年率"></p>
<p><strong>英国居民消费价格指数年率</strong><br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/UK_cpi_year.png" alt="英国居民消费价格指数年率"></p>
<p><strong>德国居民消费价格指数年率</strong><br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/German_cpi_year.png" alt="德国居民消费价格指数年率"></p>
<p>对比5个国家发现，中国在2000年前，CPI年率有过两次高峰，2012年后，CPI年率基本稳定在3%附近，2020年初则是因为疫情的影响又高了起来。</p>
<p>其它4个国家都是发达国家，日本在1995年后，CPI年率一直稳定在1.3%下面，2015附近年有过一次波峰，和2010附近的波谷正好抵消。美国自1993年之后，CPI年率一直在3%下面，但整体高于日本；英国自1993年之后，CPI年率基本在3%下面，但是它的波动较大，其中一半的时间CPI年率都在2%下面；德国1996年之后绝大部分时间都在2%下面。</p>
<p>中国由于改革开放，造就了此后30年经济的高速增长，这也是工资、物价飞速增长的30年。但是近些年，我们能明显的感受到，经济的增长速度慢了下来，嗯，也叫经济新常态。之后还可能会进一步降低，降低到和老牌发达国家一样的低增速水平，这也意味着在接下来的一个较长的时期内，CPI年率会一直处于3%以下，并且大部分时间都达不到3%的水平。</p>
<p>假设当前的物价是1，那么以3%的CPI年率计算，25年后，物价是2.1，翻了一倍，也就是说，同等数量的钱，25年后购买力降低了一半。</p>
<h4 id="支出项预估"><a href="#支出项预估" class="headerlink" title="支出项预估"></a>支出项预估</h4><p>上面从宏观层面分析了未来20、30年物价可能出现的增长情况，这部分是我们作为个体所无法控制或者较难控制的。我们唯一能控制的就是日常支出。</p>
<p>然而这一部分也是最难预估的一部分。就目前而言，每月固定开销就有房租、房贷、保险、日常消费等，再过几年还会会有小孩的教育费用等各种无法预料的支出。</p>
<p>日常开支里，日常生活开销的其实占比很小，大头还是房贷、教育支出等。因此这部分思路如下：将人生分为两个阶段，目标完成前和目标完成后，分别考虑支出。</p>
<table>
<thead>
<tr>
<th>支出项</th>
<th>25年期间</th>
<th>25年之后</th>
</tr>
</thead>
<tbody><tr>
<td><strong>房贷</strong></td>
<td>有（较大）</td>
<td>无（房贷25年）</td>
</tr>
<tr>
<td><strong>子女教育支出</strong></td>
<td>有（较大）</td>
<td>无</td>
</tr>
<tr>
<td><strong>大病支出</strong></td>
<td>保险覆盖</td>
<td>保险覆盖</td>
</tr>
<tr>
<td>赡养</td>
<td>有（较低）</td>
<td>有（稍大）</td>
</tr>
<tr>
<td>保险支出</td>
<td>有</td>
<td>少量</td>
</tr>
<tr>
<td>日常家庭开支</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>其它</td>
<td>有</td>
<td>有</td>
</tr>
</tbody></table>
<p>这里面真正大头的是房贷、子女教育支出和大病支出。除掉这三块之后，其它的其实没有多少。也就是说，相同的钱，在这25年里和25年后，所带来的幸福感是完全不同的。</p>
<p>那么在一线城市，25年后，在没有房贷和子女教育费用的情况下，一年需要需要多少收入能过的比较幸福呢？</p>
<p>我的答案是50万。</p>
<p>换算到现在，依据当前物价水平，在年被动收入25万且没有房贷和子女教育支出的情况下可以过的的比较幸福。一般消费都能支撑的起，还能偶尔奢侈一把。</p>
<p>考虑到25年后，自己可能还在工作，或者领取退休金，所以实际的生活幸福感会更高。</p>
<p><strong>注：这里不考虑疾病支出是因为这部分的支出可以通过一个完备的保险计划来覆盖掉。关于如何配置好家庭保险，之后会单独拎出来介绍。</strong></p>
<h3 id="500万的目标是否合理"><a href="#500万的目标是否合理" class="headerlink" title="500万的目标是否合理"></a>500万的目标是否合理</h3><h4 id="500万够不够？"><a href="#500万够不够？" class="headerlink" title="500万够不够？"></a>500万够不够？</h4><p>根据上面的拍脑袋，25年后被动收入50万就能完全覆盖家庭的日常开支。</p>
<p>每年50万的被动收入，本金500万的情况下，需要的年化收益率是10%。这个收益率的要求是比较高的，因为那个时候，我们对资产配置的要求已经从获取超额收益变成了获取稳定收益，能承受的风险水平大大降低，相应的收益率水平也会降低。</p>
<p>但是假设25年后，立即退休，开始领取养老金，社保交25年对应的养老金的替代率能达到50%，有这笔收入作为补充，需要实现的稳定收益率会大大降低，大约6%-7%附近，还是可行的。</p>
<p>这么一看，500万的目标是合理的。</p>
<h4 id="能不能通过工资实现？"><a href="#能不能通过工资实现？" class="headerlink" title="能不能通过工资实现？"></a>能不能通过工资实现？</h4><p>同居民消费价格指数一样，未来20、30年，在不出现科技突破导致生产力水平再一次突飞猛进的情况下，工资水平大概率会以一个较低的增长率水平缓慢增长。</p>
<p>以美国为例，看一下1990年-2018年这28年间 <a href="https://www.statista.com/statistics/200838/median-household-income-in-the-united-states/" target="_blank" rel="noopener">美国家庭收入中位数</a> 的变化，最低是1993年的52334，最高是2018年63179，也就是说，这28年间工资的最大增幅才20%。</p>
<p>当然，如果再去看一下1990年-2018年间 <a href="https://www.ceicdata.com/zh-hans/indicator/united-states/annual-household-income-per-capita" target="_blank" rel="noopener">美国家庭人均收入</a> 的变化，你会惊讶的发现其呈稳定增长趋势。结合上面的美国家庭收入中位数几乎不变的事实，可以得出这样一个结论：美国的贫富差距正在迅速扩大。</p>
<p>中国大概率也会进入这样的状态，当然，考虑到未来一段时间内，中国的经济增长水平仍然会维持在一个中低速增长的水平，因此工资水平还是会有一段时间的中低速的增长，只是不可能会像改革开放之后30年内，出现隔一段时间就翻一番的场景了。</p>
<p>低速增长的工资水平和物价水平相抵消，意味着很难通过工资实现资本的快速积累，但同时这也意味着在相当长的一段时间内，我们可以维持一个相对稳定的储蓄率。</p>
<h4 id="能不能攒到500万？"><a href="#能不能攒到500万？" class="headerlink" title="能不能攒到500万？"></a>能不能攒到500万？</h4><p>假设初始金额为0，目标500万，不同期限下每月投入金额和需要的年化收益率的对应关系如下：</p>
<table>
<thead>
<tr>
<th>每月投入金额</th>
<th>年复合收益率（15年）</th>
<th>年复合收益率（20年）</th>
<th>年复合收益率（25年）</th>
<th>年复合收益率（30年）</th>
</tr>
</thead>
<tbody><tr>
<td>500</td>
<td>47.141%</td>
<td>31.252%</td>
<td>22.936%</td>
<td>17.879%</td>
</tr>
<tr>
<td>1000</td>
<td>39.033%</td>
<td>25.719%</td>
<td>18.724%</td>
<td>14.469%</td>
</tr>
<tr>
<td>1500</td>
<td>34.374%</td>
<td>22.492%</td>
<td>16.243%</td>
<td>12.445%</td>
</tr>
<tr>
<td>2000</td>
<td>31.095%</td>
<td>20.198%</td>
<td><strong>14.467%</strong></td>
<td>10.987%</td>
</tr>
<tr>
<td>2500</td>
<td>28.561%</td>
<td>18.411%</td>
<td>13.075%</td>
<td>9.840%</td>
</tr>
<tr>
<td>3000</td>
<td>26.493%</td>
<td>16.943%</td>
<td>11.926%</td>
<td>8.890%</td>
</tr>
<tr>
<td>5000</td>
<td>20.693%</td>
<td>12.772%</td>
<td>8.632%</td>
<td>6.143%</td>
</tr>
</tbody></table>
<p>综合考虑自己的个人情况，认为每月投入2000，实现15%的年化收益率这种方案比较适合自己。这里面每月投入2000很简单，但是实现15%的收益率不太容易，需要持续不断的投入精力学习各种理财知识。</p>
<p>那么实现接近15%的年化收益率，难度高吗？这里以沪深300指数为例，沪深300指数基日是2004年12月31日，基点是1000点，2020年1月3号是4144点，折算成年化收益率是9.941%。如果配合一定的策略，完全是可以获取更高的收益率水平的。</p>
<p>因此，如何构建自己的投资体系，实现15%的超额收益，也是<code>【财务自由实证系列】</code>的一个目标之一。</p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>本篇算是 <code>【财务自由实证系列】</code> 的一个序，之后这个系列会定期公开自己财务自由计划的进展，记录自己在实现这个目标过程中的点点滴滴，同时证明这样的一个财务自由计划是完全有可能实现的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/27/Go-Modules-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tjjsjwhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tjjsjwhj的个人空间~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/27/Go-Modules-md/" class="post-title-link" itemprop="url">Go Modules 简介</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-27 19:16:55 / 修改时间：19:24:22" itemprop="dateCreated datePublished" datetime="2020-06-27T19:16:55+08:00">2020-06-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>In Go 1.14, module support is considered ready for production use, and all users are encouraged to migrate to modules from other dependency management systems.</p>
</blockquote>
<p>在go1.14中，模块支持被认为已经可以在生产环境中使用，因此鼓励所有用户将项目中的依赖管理系统都迁移到Go Mudules中。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="Go-版本升级"><a href="#Go-版本升级" class="headerlink" title="Go 版本升级"></a>Go 版本升级</h3><p><strong>查看Go版本</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env</span><br></pre></td></tr></table></figure>

<p>如果显示版本低于1.14，则需要升级。</p>
<p><strong>下载Go最新版本</strong></p>
<p>官网地址：<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a> ，下载对应版本。这里以 <code>go1.14.4.darwin-amd64.tar.gz</code> 为例。</p>
<p><strong>删除旧版本</strong></p>
<ul>
<li>通过 <code>go env</code> 获取安装路径（即 <code>GOROOT</code> ），一般是 <code>/usr/local/go</code> 。</li>
<li><code>rm -rf /usr/local/go</code> </li>
</ul>
<p><strong>安装新版本</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -C /usr/<span class="built_in">local</span> -xzf go1.14.4.darwin-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p>至此，Go1.14 升级完成，so easy~</p>
<h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><p>由于一些原因，下载Go的各种依赖包的时候，速度很慢，通过一些镜像网站下载的话，可以获得如丝滑般的下载体验。</p>
<p><strong>常见的Go Modules镜像网站：</strong><br>1、<a href="https://proxy.golang.org/" target="_blank" rel="noopener">https://proxy.golang.org/</a><br>GOPROXY 的默认值，这是一个在大陆无法访问的地址。。<br>2、<a href="https://goproxy.io/" target="_blank" rel="noopener">https://goproxy.io/</a><br>一个开源的为 Go Modules 而生的全球代理。国内开发者使用的较多，维护者是个人。<br>3、<a href="https://goproxy.cn/" target="_blank" rel="noopener">https://goproxy.cn/</a><br>Goproxy 中国，最初开发者是 <a href="https://aofeisheng.com/" target="_blank" rel="noopener">@盛傲飞</a>，目前是七牛云托管和维护。你甚至可以像 goproxy.baidu.com 一样将该服务用作上游代理。</p>
<p><strong>如何设置</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>

<p><strong>趣闻</strong>：<a href="https://github.com/goproxy/goproxy.cn/issues/61" target="_blank" rel="noopener">goproxy.io 和 goproxy.cn 是什么关系?</a></p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><blockquote>
<p>如果使用 Go Modules 来管理依赖，那么你的项目就没有必要在 <code>GOPATH</code> 中了。</p>
</blockquote>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>1、随便创建一个项目目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /tmp/scratchpad/repo</span><br><span class="line"><span class="built_in">cd</span> /tmp/scratchpad/repo</span><br></pre></td></tr></table></figure>
<p>2、go mod 准备</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init xxx/repo</span><br></pre></td></tr></table></figure>
<p>其中 <code>xxx</code> 是你项目托管的目录。如果是在github上，则是 <code>github.com/yourname/repo</code> 。</p>
<p>3、测试代码</p>
<p>repo 下 main.go 中添加如下测试代码</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	</span><br><span class="line">	<span class="string">"github.com/labstack/echo"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e := echo.New()</span><br><span class="line">	e.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c echo.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c.String(http.StatusOK, <span class="string">"Hello, World!"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	e.Logger.Fatal(e.Start(<span class="string">":1323"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、go mod xxx 相关命令</p>
<table>
<thead>
<tr>
<th>xxx</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>download</td>
<td>download modules to local cache</td>
</tr>
<tr>
<td>edit</td>
<td>edit go.mod from tools or scripts</td>
</tr>
<tr>
<td>graph</td>
<td>print module requirement graph</td>
</tr>
<tr>
<td>init</td>
<td>initialize new module in current directory</td>
</tr>
<tr>
<td>tidy</td>
<td>add missing and remove unused modules</td>
</tr>
<tr>
<td>vendor</td>
<td>make vendored copy of dependencies</td>
</tr>
<tr>
<td>verify</td>
<td>verify dependencies have expected content</td>
</tr>
<tr>
<td>why</td>
<td>explain why packages or modules are needed</td>
</tr>
</tbody></table>
<h3 id="日常工作流程"><a href="#日常工作流程" class="headerlink" title="日常工作流程"></a>日常工作流程</h3><p>使用 go mod 之后，你的<strong>日常工作流程</strong>应该是这样：</p>
<ol>
<li>在代码文件中写好 <code>import</code> 语句</li>
<li>执行 <code>go run</code> or <code>go build</code> or <code>go test</code>，或者一些其它的标准命令时，会自动下载依赖以及更新 <code>go.mod</code> 文件。</li>
<li>当你需要指定依赖的版本的时候，你可以使用命令 <code>go get foo@v1.2.3</code>， <code>go get foo@master</code> ，<code>go get foo@e3702bed2</code> 直接下载指定版本（这些命令都会直接更新go.mod），或者直接修改 go.mod 文件。</li>
</ol>
<p>一些你可能会用到的其它功能：</p>
<ol>
<li><code>go list -m all</code> – 查看全部直接或者间接的依赖</li>
<li><code>go list -u -m all</code> – 查看全部直接或者间接的依赖版本及最新版本</li>
<li><code>go get -u ./...</code> or <code>go get -u=patch ./...</code> ,，更新全部直接或者间接依赖到最新 <code>minor</code> 版本或者 <code>patch</code> 版本</li>
<li><code>go build ./...</code> or <code>go test ./...</code></li>
<li><code>go mod tidy</code> 精简不必要的依赖，同时增加任何必要的依赖。</li>
<li><code>go mod vendor</code> — 创建 vendor 目录，并复制依赖到其中。 </li>
</ol>
<h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><blockquote>
<p>A module is a collection of related Go packages that are versioned together as a single unit.</p>
</blockquote>
<p>仓库（repository）、模块（module）和 包（package）之间的关联：</p>
<ul>
<li>一个仓库包含了一个或多个 Go Modules</li>
<li>每个模块包含了一个或多个 Go Packages</li>
<li>每个包 包含了某个路径下的一个或多个 Go Source 文件</li>
</ul>
<p>Modules 必须被语义版本化 （遵循 <a href="https://semver.org/" target="_blank" rel="noopener">semver</a> 协议），其版本描述格式如 <code>v(major).(minor).(patch)</code> </p>
<blockquote>
<ol>
<li>major (主版本号)：当你做了不兼容的 API 修改，</li>
<li>minor (次版本号)：当你做了向下兼容的功能性新增</li>
<li>patch (修订号)：当你做了向下兼容的问题修正</li>
</ol>
</blockquote>
<h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h3><p><code>go.mod</code> 文件中有4个命令：<code>module</code>， <code>require</code>，<code>replace</code>，<code>exclude</code>。</p>
<p><strong>example</strong></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module github.com/my/thing</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com/some/dependency v1<span class="number">.2</span><span class="number">.3</span></span><br><span class="line">    github.com/another/dependency/v4 v4<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>module</code> 命令声明了当前模块的名称以及导入路径。</p>
<p><code>require</code> 命令标明了当前模块所依赖的模块。</p>
<p><code>replace</code> 和 <code>exclude</code> 命令仅对当前模块生效，即 build 主模块时，其它依赖模块中的 <code>replace</code> 和 <code>exclude</code> 命令都会被忽略掉。</p>
<h3 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h3><p>如果当前模块依赖的一个模块名是 M，当你还没有将 M 添加到 <code>go.mod</code> 中的时候，如果执行 <code>go build</code> 或者 <code>go test</code> 等命令，会自动拉取 M 并将其添加到 <code>go.mod</code> 中，拉取规则如下：</p>
<ul>
<li>拉取 M 最新的发行版本 v1.2.3，如果没有发行版本，则拉取最新的master的commit</li>
<li>如果当前模块中的依赖 A 依赖 M v1.0.0，B 依赖 M v1.2.3，那么会选择 M v1.2.3 (最小版本选择算法)</li>
</ul>
<h3 id="语义导入版本控制"><a href="#语义导入版本控制" class="headerlink" title="语义导入版本控制"></a>语义导入版本控制</h3><p>这里说的是导入模块的时候，包的路径应该与模块版本相符。</p>
<p>具体规则如下：</p>
<ul>
<li>模块的版本命令应该遵从 <a href="https://semver.org/" target="_blank" rel="noopener">semver</a> 协议。</li>
<li>如果该模块的版本是 v2 或者更高，那么 <code>go.mod</code> 中声明该模块的时候，需要加上 <code>/v2</code> 的后缀，如 <code>module github.com/my/mod/v2</code> 或者 <code>require github.com/my/mod/v2 v2.0.1</code>。这种用法也被用在 <code>go get</code> 命令中，如 <code>go get github.com/my/mod/v2@v2.0.1</code></li>
</ul>
<h2 id="FAQs"><a href="#FAQs" class="headerlink" title="FAQs"></a>FAQs</h2><p><strong>1、go.mod 中模块被标记成 <code>incompatible</code> 是什么意思</strong></p>
<p><strong>答：</strong> 如果 <code>Module</code> 的名字没有遵循 Golang 的规范，即在模块名中附带版本信息，那这就是一个不规范的模块，就会提示 <code>incompatible</code>。以 <code>github.com/labstack/echo</code> 为例，如果其当前版本是 <code>v3.3.10</code> ，那么 go.mod 中会这样显示：<code>github.com/labstack/echo v3.3.10+incompatible</code> 。</p>
<p>想象一下，如果 <code>github.com/labstack/echo</code> 更新到了 <code>v4.1.1</code> ，如果你的模块依赖它，并且执行了更新全部依赖的命令会怎么样？ <code>github.com/labstack/echo</code> 会更新到 <code>v4.1.1</code>，但是根据 <a href="https://semver.org/" target="_blank" rel="noopener">semver</a> 协议，v4 是不兼容 v3 的，这个时候你的模块就会出问题。如果依赖符合规范，如 <code>github.com/labstack/echo/v3</code> ，那你更新全部依赖后，也只是将版本更新到 <code>v3.9.9</code> 或者小于 <code>v4</code> 的最大一个版本，不会出现兼容性的问题。</p>
<p>当模块的版本小于等 v1 的时候，模块名默认不需附带版本信息。</p>
<p><strong>2、为什么 <code>go mod tidy</code> 会记录 <code>inderect</code> （非直接）依赖和测试依赖？</strong></p>
<p><strong>答：</strong> <code>go mod dity</code> 会尽可能的反应出所需要的全部环境下（有可能是系统、处理器架构或者build tags）的依赖，而 <code>go build</code> 和 <code>go test</code> 仅仅是更新 <code>go.mod</code> ，添加当前环境的依赖。</p>
<p><strong>3、如何在不支持 Module 的模块 A 中导入支持 Module 的 v2+ 的 模块 B?</strong></p>
<p><strong>答：</strong> 这需要看 module B 是如何发布 v2+ module 的。</p>
<ol>
<li>如果是在主分支，在 go.mod 中通过 <code>module</code> 声明 <code>/v3</code> <ul>
<li>模块 A 中不需要修改导入路径 （即使改了编译的时候也会忽略路径中的版本信息），在 <code>GOPATH</code> 模式下运行的时候，会选择 <code>GOPATH</code> 中的模块 B 的版本编译。</li>
</ul>
</li>
<li>如果 B 是在 子目录中创建了一个 <code>./v3</code> 目录，然后将 <code>go.mod</code> 文件放在 <code>./v3</code> 中<ul>
<li>A 中使用 <code>import github.com/xxx/B/v3</code> 是没有问题的。</li>
</ul>
</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">Go Modules 官方文档</a></li>
<li><a href="https://juejin.im/post/5d8ee2db6fb9a04e0b0d9c8b" target="_blank" rel="noopener">干货满满的 Go Modules 和 goproxy.cn</a></li>
<li><a href="https://rainbowmango.gitbook.io/go/chapter12/3-foreword/3.7-module-incompatible" target="_blank" rel="noopener">Go 专家编程-incompatible</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/21/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tjjsjwhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tjjsjwhj的个人空间~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/21/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">MySQL之索引</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-21 16:00:28 / 修改时间：16:08:53" itemprop="dateCreated datePublished" datetime="2020-06-21T16:00:28+08:00">2020-06-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么需要索引"><a href="#为什么需要索引" class="headerlink" title="为什么需要索引"></a>为什么需要索引</h2><p>索引就像书籍的目录一样，可以更快的查找数据。</p>
<h2 id="常见的索引模型"><a href="#常见的索引模型" class="headerlink" title="常见的索引模型"></a>常见的索引模型</h2><blockquote>
<p>innodb 索引模型选用B+树是由MySQL的应用场景（等值区间查找、插入删除等操作频繁）及机械磁盘的特点（寻址耗时）决定的。像Redis等一些Nosql数据库，他们的索引模型就是哈希表、跳表等。</p>
</blockquote>
<ul>
<li>数组<ul>
<li>等值查询很快（数组有序排列的情况下，二分查找）</li>
<li>区间查询很快</li>
<li>数据的插入删除很慢</li>
</ul>
</li>
<li>哈希表<ul>
<li>等值查询极快</li>
<li>插入删除极快</li>
<li>区间查询很慢（只能一个个的查找）</li>
</ul>
</li>
<li>搜索树（链表）<ul>
<li>二叉搜索树<ul>
<li>等值查询、区间查询很快，效率等于数组的二分查找</li>
<li>插入删除效率logN，需要树的再平衡，再平衡的效率也是logN</li>
</ul>
</li>
<li>多叉搜索树树<ul>
<li>相比于二叉树，多叉树一次寻址能取出更多的数据，能大大减少寻址次数</li>
<li>一个节点下面，叶子节点的个数取决于硬盘上数据块的大小</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>MySQL的应用场景中，等值查询和区间查询是很高频的场景，插入删除操作也十分频繁，因此综合考虑，搜索树最适合作为底层的存储引擎。又因为机械硬盘时代，磁盘寻址的时间成本很高，因此 innodb 底层的那存储引擎选用的索引模型是B+树。</p>
<p>本文后续主要介绍innodb的索引。</p>
<h2 id="Innodb中的索引"><a href="#Innodb中的索引" class="headerlink" title="Innodb中的索引"></a>Innodb中的索引</h2><h3 id="主键索引和非主键索引"><a href="#主键索引和非主键索引" class="headerlink" title="主键索引和非主键索引"></a>主键索引和非主键索引</h3><p><strong>主键索引：</strong> 主键索引的叶子结点（最后一层）存储的是数据库的行数据。</p>
<p><strong>非主键索引：</strong> 非主键索引的叶子节点（最后一层）存储的是主键索引。</p>
<p>对于一个查询操作，查询条件如果是主键索引，则直接返回结果；如果是非主键索引，则先返回主键，然后根据主键查询主键索引树，再返回结果。</p>
<p><em>查询原则：尽量使用主键索引查询。</em></p>
<h3 id="索引类别"><a href="#索引类别" class="headerlink" title="索引类别"></a>索引类别</h3><p>innodb中不同索引类别的特点如下：</p>
<ul>
<li>普通索引<ul>
<li>没有任何限制</li>
</ul>
</li>
<li>唯一索引<ul>
<li>索引列的值唯一</li>
<li>允许有空值</li>
<li>组合索引，列值必须唯一</li>
</ul>
</li>
<li>主键索引<ul>
<li>只能作用于一个列上</li>
<li>键值唯一</li>
<li>不能为空</li>
</ul>
</li>
</ul>
<p>业务上，如果只有一个索引，并且是唯一索引，可以直接用该字段建立索引（<strong>尽量使用主键索引查询原则</strong>）</p>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>插入数据或者删除数据，都涉及到索引表的调整。</p>
<p>插入数据的时候，有可能会导致叶子节点数据的挪动，也可能导致数据页的分裂。(对性能的影响需要结合B+树的增删改查操作)</p>
<p>删除数据的时候，一般只是对数据标记下删除，并不会立即调整索引树，除非索引树中被删除的数据过多，浪费了大量的空间，则需要重建索引树。</p>
<p><strong>自增主键的优势</strong></p>
<ul>
<li>主键自增，索引树不需要维护主键的有序性</li>
<li>自增ID占空间较小，非主键索引树占用的空间更小</li>
</ul>
<p>索引从性能和存储上考虑，自增ID都是更好的选择。</p>
<blockquote>
<p>想象以下，一个用户信息表，如果索引选择身份证号码，那每次新增一条数据，为了保证索引有序，都有可能导致一个数据块上数据重新排列，也能导致一个数据块分裂，显然更耗时。</p>
<p>如果这个用户信息表还有其它非主键索引树，那它的叶子节点存储的都是18位的身份证号码，显然消耗的空间相较于自增ID要更多</p>
</blockquote>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><blockquote>
<p>覆盖索引只是一种场景，或者一种现象，构造出这种现象有利于提高查询性能。</p>
</blockquote>
<p>先看一个查询的例子。如果我们有如下的一张表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0, </span><br><span class="line">s varchar(16) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">index k(k))</span><br><span class="line">engine&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line">insert into T values(100,1, &#39;aa&#39;),(200,2,&#39;bb&#39;),(300,3,&#39;cc&#39;),(500,5,&#39;ee&#39;),(600,6,&#39;ff&#39;),(700,7,&#39;gg&#39;);</span><br></pre></td></tr></table></figure>

<p>如果执行如下语句，需要查询几次？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T where k between 3 and 5;</span><br></pre></td></tr></table></figure>
<p>答：查询非主键索引树3次，回表2次。</p>
<p>同样如果执行下面的语句，需要查询几次？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from T where k between 3 and 5;</span><br></pre></td></tr></table></figure>
<p>答：查询非主键索引树3次，不需要回表。</p>
<p>如果索引树的查询结果已经包含了我们需要的结果，不需要回表，这种情况就称为覆盖索引。<strong>覆盖索引</strong>是常用的一种性能优手段。</p>
<h3 id="联合索引和最左前缀原则"><a href="#联合索引和最左前缀原则" class="headerlink" title="联合索引和最左前缀原则"></a>联合索引和最左前缀原则</h3><p>联合索引和最左前缀原则并没有什么必然的联系，这里放在一起讨论是因为联合索引的查找过程会应用到最左前缀原则。</p>
<h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><blockquote>
<p>B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</p>
</blockquote>
<p>查询的时候，如果查询条件是索引的最左N个字段，或者最左N个字符，都能用上索引，加快查询速度。</p>
<h4 id="如何安排联合索引的顺序"><a href="#如何安排联合索引的顺序" class="headerlink" title="如何安排联合索引的顺序"></a>如何安排联合索引的顺序</h4><p>联合索引是按照索引项的顺序建立索引的，如（A，B），建立索引的时候，是先按A排序，然后对同一个A，再按B排序，检索的顺序也是如此，先检索A，再检索B。所以建立联合索引的时候，一定要考虑索引的复用 程度。复用程度越高，越要放前面。</p>
<p>显然如果建立了联合索引（A，B），索引A是不需要单独建立索引的。</p>
<p>回到之前的覆盖索引，如果有个高频的需求是根据用户的身份证查询姓名，那有必要建立身份证号和姓名的联合索引吗？答案是不考虑索引维护的成本下是有必要的。</p>
<p>建立了身份证和姓名的联合索引之后，只需要查询联合索引树，就能直接返回查询结果而不需要回表，大大提高查询性能。</p>
<p>当然，索引的维护是有代价的。因此建立冗余的索引来实现覆盖索引就需要权衡考虑了。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p><strong>题目</strong>：对于如下表，由于历史原因，联合索引（a, b）是必须的，那这里面有不必要的索引吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;geek&#96; (</span><br><span class="line">  &#96;a&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;b&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;c&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;d&#96; int(11) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;a&#96;,&#96;b&#96;),</span><br><span class="line">  KEY &#96;c&#96; (&#96;c&#96;),</span><br><span class="line">  KEY &#96;ca&#96; (&#96;c&#96;,&#96;a&#96;),</span><br><span class="line">  KEY &#96;cb&#96; (&#96;c&#96;,&#96;b&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure>

<p><strong>答</strong>：ca是不必要的索引。</p>
<p>对于联合索引（a，b），其内部的组织是先根据a排序，再根据b排序，因此索引树c的内容其实是cab，即先根据c排序，再根据a排序，再根据b排序的一个B+数据。索引树（c，a）的叶子节点实际上是b，树的内容也是cab，和索引树c是一致的，因此ca索引树是不必要的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/mysql%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tjjsjwhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tjjsjwhj的个人空间~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/mysql%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7/" class="post-title-link" itemprop="url">MySQL之事务的隔离性</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 23:22:43" itemprop="dateCreated datePublished" datetime="2020-05-31T23:22:43+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-21 16:08:45" itemprop="dateModified" datetime="2020-06-21T16:08:45+08:00">2020-06-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一提到事务，我们就会想到事务的4个特性ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性和持久性）。本篇文章，主要讲的就是隔离性。</p>
<p>mysql里面并不是所有的存储引擎都支持事务，因此本文中针对事务的讨论都是基于存储引擎innodb。</p>
<h2 id="一、隔离级别"><a href="#一、隔离级别" class="headerlink" title="一、隔离级别"></a>一、隔离级别</h2><h3 id="1-1-“隔离级别”的概念"><a href="#1-1-“隔离级别”的概念" class="headerlink" title="1.1 “隔离级别”的概念"></a>1.1 “隔离级别”的概念</h3><blockquote>
<p>脏读（dirty read）: A 事务可以读到B事务未提交的数据，就叫脏读。<br>不可重复读（no-repeatable read）: 事务A开始时只能看到其它事务已经提交的修改。换句话说，事务A的两次查询可能看到不同的结果。（其它事务中途提交修改）。不可重复读针对的是单条记录。<br>幻读（phantom read）:当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）。</p>
</blockquote>
<p>当数据库上有多个事务 <strong>并行执行</strong> 的时候，会出现脏读（dirty read）、不可重复读（no-repeatable read）、幻读（phanton read)的问题，为了解决这些问题，就出现了”隔离级别”的概念。</p>
<h3 id="1-2-不同的隔离级别"><a href="#1-2-不同的隔离级别" class="headerlink" title="1.2 不同的隔离级别"></a>1.2 不同的隔离级别</h3><p>在谈隔离级别之前，我们首先要直到，你隔离的越严实，效率就会越低。因此很多时候，我们需要在二者之间寻找一个平衡点。</p>
<p>标准的事务隔离级别有以下几种：</p>
<ol>
<li><strong>读未提交</strong>（read uncommited）: 一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li><strong>读提交</strong>（read commited）: 一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li><strong>可重复读</strong>（repeatable read）: 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li><strong>串行化</strong>（sirializable）: 对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ol>
<h3 id="1-3-隔离级别的修改"><a href="#1-3-隔离级别的修改" class="headerlink" title="1.3 隔离级别的修改"></a>1.3 隔离级别的修改</h3><p><strong>隔离级别的查看</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%transaction_isolation%&quot;;</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| Variable_name         | Value           |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| transaction_isolation | REPEATABLE-READ |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>隔离级别的修改</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set [ global | session ] transaction isolation level [ Read uncommitted  | Read committed | Repeatable read | Serializable ];</span><br></pre></td></tr></table></figure>
<p>注：<code>[]</code> 表示可选。</p>
<h3 id="1-4-可重复读隔离级别的演示"><a href="#1-4-可重复读隔离级别的演示" class="headerlink" title="1.4 可重复读隔离级别的演示"></a>1.4 可重复读隔离级别的演示</h3><p>由于mysql默认的隔离级别是可重复读，因此这里就以可重复读为例进行演示，其它情况可通过修改隔离级别模拟。</p>
<p>步骤1：创建测试表，插入测试数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(c int) engine&#x3D;InnoDB;</span><br><span class="line">insert into T(c) values(1);</span><br></pre></td></tr></table></figure>

<p>步骤2：起2个事务模仿并发的情况，以下是两个事务中不同操作的执行顺序。</p>
<p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/repeatable%20read.png" alt="可重复读"></p>
<p>从图中可以看到，右边的事务无论是执行 update 操作，还是提交事务，左边的事务都是看不到的。当左边的事务提交之后，再次查询，才能看到更新之后的数据。完美契合可重复读的定义：事务执行期间看到数据可事务开启时看到的数据一致。</p>
<p>其它隔离级别读者可自行实验。</p>
<p><strong>提示</strong> </p>
<ul>
<li>如果是读未提交，那在上图第5步的时候，会发现数据发生变化</li>
<li>如果是读提交，那在上图第7步的时候，会发现数据发生变化</li>
<li>如果是串行化，那在执行第4步的时候，会失败，必须等左边的事务提交，右边的事务才能继续执行。</li>
</ul>
<h3 id="1-5-事务隔离的实现"><a href="#1-5-事务隔离的实现" class="headerlink" title="1.5 事务隔离的实现"></a>1.5 事务隔离的实现</h3><p>实现上，数据库会创建一个视图，访问的时候以视图的逻辑结果为准（<strong><em>注：此视图实为一致性读视图 consistend read view，不是MySQL中特指查询结果的那个视图</em></strong>）。不同时刻启动的事务，会有不同的视图，这意味着不同视图里面的同一条数据会有不同的版本，这就是数据库多版本并发控制（MVCC）。</p>
<p>“读未提交”隔离级别下，直接读取的最新数据，没有视图的概念；”读提交”隔离级别下，事务中每次执行查询语句前，都会新建一个视图；”可重复读”隔离级别下，事务启动的时候，会创建一个视图，整个事务执行期间都用这个视图；”串行化”隔离级别下，直接用加锁的方式来避免并行访问。</p>
<p><strong>以可重复读为例:</strong></p>
<p>在可重复读隔离级别下，不同事务在启动的时候，就拍了不同的”快照”: 一个基于整个库的快照。我们先来看下这个快照是怎么实现的。</p>
<p>Innodb中每个事务都有一个transaction id，这个id是在事务开始的时候向系统申请的，是按申请顺序严格递增的。</p>
<p>数据库中的每行数据有多个版本，每一个版本都是和一个transaction id绑定的。比如分别有事务trx_id_1，trx_id_2，trx_id_3 对某行数据进行更新，更新过程中该行数据产生了3个版本v1，v2，v3，记录的时候就会这样记：（v1, trx_id_1），（v2, trx_id_2），（v3, trx_id_3）。实际存储的时候，数据库只会记录最新的记录（v3, trx_id_3）,之前的记录则是通过undo日志计算出来的。</p>
<p>有了transaction id和多版本的概念，快照的实现方式可以这样描述：</p>
<ol>
<li>InnoDB 为每个事务构造了一个<strong>数组</strong>，用来保存这个事务启动瞬间，当前正在<strong>活跃</strong>的所有事务 ID。“活跃”指的就是，启动了但还没提交。</li>
<li>数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。(<strong>注意：这里的ID的最大值是已经创建过的所有事务ID的最大值</strong>)</li>
</ol>
<p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p>
<p>数据版本的可见性规则，就是基于数据的 trx_id 和这个一致性视图的对比结果得到的。</p>
<p>假设数据版本对应的事务id为trx_id，则可见性规则如下：</p>
<ol>
<li>如果trx_id小于低水位，则数据可见。</li>
<li>如果trx_id大于高水位，则数据不可见</li>
<li>如果trx_id在高低水位之间，有两种可能：<ol>
<li>如果trx_id在数组里，则数据不可见</li>
<li>如果trx_id不在数组里，则数据可见</li>
</ol>
</li>
</ol>
<p><strong>此外，如果是这个事务自己更新的数据，它自己还是要认的。</strong> </p>
<p>假设事务A启动的时候，当前系统中活跃的事务ID为[trx_id_1, trx_id_2, trx_id_3]，最小事务ID为trx_id_1，系统里已经创建过的事务ID的最大值加1为trx_id_max，当前数据版本为（V4，trx_id_x4）。</p>
<p>如果trx_id_x4 &gt; trx_id_max，就认为当前V4不可见，数据版本根据undolog回退到上一个版本（V3，trx_id_x3），如果trx_id_x3在高低水位之间，并且在数组里面，仍然认为V3不可见，在根据undolog回退到上一个版本(V2，trx_id_x2)，如果trx_id_x2小于低水位，认为数据可见。那么当前事务A在整个事务期间看到的这一行数据的版本都是V2。</p>
<p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p>
<ul>
<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li>
<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li>
</ul>
<p>InnoDB 正是利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</p>
<h3 id="1-5-不同隔离级别的应用场景"><a href="#1-5-不同隔离级别的应用场景" class="headerlink" title="1.5 不同隔离级别的应用场景"></a>1.5 不同隔离级别的应用场景</h3><h2 id="二、事务到底是隔离的还是非隔离的"><a href="#二、事务到底是隔离的还是非隔离的" class="headerlink" title="二、事务到底是隔离的还是非隔离的"></a>二、事务到底是隔离的还是非隔离的</h2><p>上面介绍的不同的隔离级别下看到的数据版本针对的是当前事务的操作是纯读的情况，如果当前事务事务中存在更新操作，那会是什么情况呢？</p>
<p>当然，串行化的隔离级别下，无论读写，都会加锁，并等待锁的释放，所以这种情况下和原来一样。其它三种级别下，事务执行过程中，如果出现update操作，就会应用这样一条规则：</p>
<p><strong>更新数据都是先读后写的，而这个读，只能读当前最新版本的值，称为当前读（current read）</strong></p>
<p>读未提交隔离级别下，一直都是读的最新版本值，所以这条规则实际影响的是 <strong>读提交</strong> 和 <strong>可重复读</strong>。</p>
<p>在可重复读的事务过程中，如果出现了update操作，会等其它事务的update完成，释放行锁，然后读取当前值，在执行update语句。在这之后的select语句的执行结果都是更新后的值，因为1.5中：</p>
<p><strong>此外，如果是这个事务自己更新的数据，它自己还是要认的。</strong> </p>
<h2 id="三、尽量避免使用长事务"><a href="#三、尽量避免使用长事务" class="headerlink" title="三、尽量避免使用长事务"></a>三、尽量避免使用长事务</h2><p>事务的隔离中用到一致性视图，而一致性视图需要用到回滚日志undolog。那回滚日志什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p>
<p>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 read-view 的时候。</p>
<p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。</p>
<p>因此建议总是使用 set autocommit=1, 通过显式语句的方式来启动事务(<strong>这样之前挂起的事务会被隐式提交</strong>)。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/06/2020%E5%B9%B4%E5%BA%A6%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tjjsjwhj">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tjjsjwhj的个人空间~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/06/2020%E5%B9%B4%E5%BA%A6%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">2020年度规划</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-06 01:38:37" itemprop="dateCreated datePublished" datetime="2020-05-06T01:38:37+08:00">2020-05-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%9F%E6%B4%BB/" itemprop="url" rel="index">
                    <span itemprop="name">生活</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>临近春节，工作上没有那么忙了，正好把2020年的年度计划整理下，定上几个小目标。</p>
<p>为了提高计划的完成度，下面制定计划的时候，会尽可能的给出相应的时间节点和比较可行的操作步骤。</p>
<h3 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h3><p>19年在专业技能上的完成度比较差，所以这一部分先列出来，以体现其重要性。</p>
<p>对于目前的自己来说，有两个方向，一个是后端开发，另一个是算法（NLP方向）。从行业的发展来看，后端开发的需求量大，技术更新迭代较快，但是在企业，绝大部分的开发内容都是业务逻辑实现，可替代性较强，且工作强度较大，不利于工作和生活的平衡；算法（NLP方向）的数学基础要求较高，门槛高，可替代性较弱，但是随着各种开发工具的完善，算法模型的实现难度在迅速下降，并且NLP发展到今天，已经达到了一个瓶颈，距离真正的自然语言理解还很遥远。</p>
<p>考虑到自己的兴趣点，以及2-3年之后的职业规划，我在专业技能上的目标是成为一个具有较强的开发能力的自然语言处理算法工程师（算法工程师）。</p>
<p>以此为基准，2020年的专业技能提升计划如下：</p>
<ul>
<li>开发<ul>
<li>Redis深度历险：核心原理与应用实践<ul>
<li>目标：完成该书的重读和总结</li>
<li>时间：Q1季度结束之前</li>
<li>完成形式：至少三篇技术博客</li>
</ul>
</li>
<li>Go语言编程<ul>
<li>目标：完成该书的阅读</li>
<li>时间：Q2季度结束之前</li>
<li>完成形式：至少四篇技术博客</li>
</ul>
</li>
<li>mysql<ul>
<li>目标：完成极客时间的mysql实战</li>
<li>时间：Q2季度之前</li>
<li>完成形式：至少4篇技术博客</li>
</ul>
</li>
<li>其它相关知识<ul>
<li>目标：完成工作上一些技术设计的总结</li>
<li>时间：全年</li>
<li>完成形式：至少4篇技术博客</li>
</ul>
</li>
</ul>
</li>
<li>算法（NLP）<ul>
<li>自然语言处理入门<ul>
<li>目标：每月完成一章</li>
<li>时间：2020年</li>
<li>完成形式：完整的阅读完，并且能针对其中部分章节形成4-5篇技术博客</li>
</ul>
</li>
<li>机器学习实战<ul>
<li>目标：完成整本书的代码实现</li>
<li>时间：2020年</li>
<li>完成形式：每月完成一个章节算法的github提交</li>
</ul>
</li>
<li>数据结构、算法与应用<ul>
<li>目标：用Python和Go实现相应的数据结构及算法</li>
<li>时间：2020年</li>
<li>完成形式：每2周一篇技术博库</li>
</ul>
</li>
<li>其它<ul>
<li>leetcode刷题<ul>
<li>目标：完成200道题目，每周4道题</li>
<li>时间：2020年</li>
<li>完成形式：200道题目过关</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="非核心能力"><a href="#非核心能力" class="headerlink" title="非核心能力"></a>非核心能力</h2><h3 id="投资"><a href="#投资" class="headerlink" title="投资"></a>投资</h3><h4 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h4><ul>
<li>逃不开的经济周期</li>
<li>哈利·布朗的永久投资组合</li>
</ul>
<h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><ul>
<li>投资实证公开</li>
<li>专业知识整理汇总，逐步形成自己系统的投资知识体系</li>
<li>开始研究量化投资，争取完成相关代码的开发</li>
</ul>
<h3 id="欧洲史"><a href="#欧洲史" class="headerlink" title="欧洲史"></a>欧洲史</h3><p>为明年去欧洲旅行提前做准备，哈哈~~</p>
<h4 id="阅读-1"><a href="#阅读-1" class="headerlink" title="阅读"></a>阅读</h4><ul>
<li>极简欧洲史</li>
<li>企鹅欧洲史</li>
</ul>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>之前写2020年规划的时候，才刚过完年来北京。回过头去看，当时指定的目标绝大部分都没有按计划执行。果然自己的自制力还是比较差。今天重新回顾了了下之前的计划，并对其中的部分内容做了删减，感觉又有动力了！</p>
<hr>
<p><strong>一个月后见进展~~</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tjjsjwhj</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/tjjsjwhj" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tjjsjwhj" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:tjjsjwhj@126.com" title="E-Mail → mailto:tjjsjwhj@126.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tjjsjwhj</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
