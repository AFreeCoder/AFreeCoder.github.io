<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go 并发基石之 channel (三) —— 几种典型的应用模式</title>
    <link href="/2021/05/23/go-channel-3/"/>
    <url>/2021/05/23/go-channel-3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Go 并发系列是根据我对晁岳攀老师的《Go 并发编程实战课》的吸收和理解整理而成，如有偏差，欢迎指正~</p></blockquote><p>在上一篇 <a href="https://mp.weixin.qq.com/s/uS4jS26V7jfJW80Jpsh3RA">Go 并发基石之 channel (二) —— 源码初探</a> 中粗略的了一遍 channel 的源码，大致了解了背后的实现思路。</p><p>这一篇，主要介绍 channel 的几种经典的应用模式。</p><h2 id="channel-的五种应用场景"><a href="#channel-的五种应用场景" class="headerlink" title="channel 的五种应用场景"></a>channel 的五种应用场景</h2><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/22/channel-de-wu-zhong-ying-yong-chang-jing.jpg" alt="channel 的五种应用场景"></p><h2 id="消息交流"><a href="#消息交流" class="headerlink" title="消息交流"></a>消息交流</h2><p>channel 的底层是一个循环队列，当队列的长度大于 0 的 时候，它会被当做线程安全队列和 buffer。利用这个特性，一个 goroutine 可以安全的往 channel 中存放数据，另一个 goroutine 可以安全的从 channel 中读取数据，这样就实现了 goroutine 之间的消息交流。</p><p>这个比较简单，就不展开了。</p><h2 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h2><p>数据传递类似游戏“击鼓传花”。鼓响时，花（或者其它物件）从一个人手里传到下一个人，数据就类似这里的花。</p><p>现在有下面这样一个任务：</p><blockquote><p>有 4 个 goroutine，编号为 1、2、3、4。每秒钟会有一个 goroutine 打印出它自己的编号，要求你编写程序，让输出的编号总是按照 1、2、3、4、1、2、3、4……这个顺序打印出来。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startTask</span><span class="hljs-params">(id, n <span class="hljs-keyword">int</span>, chans []<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-comment">// 每个任务从对应的 chan 读取数据，并传递给下一个chan</span><br><span class="hljs-keyword">for</span> &#123;<br>token := &lt;-chans[id]<br>fmt.Printf(<span class="hljs-string">&quot;%d \n&quot;</span>, id+<span class="hljs-number">1</span>)<br>chans[(id+<span class="hljs-number">1</span>)%n] &lt;- token<br>time.Sleep(time.Second)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>n := <span class="hljs-number">4</span><br>chans := []<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>chans = <span class="hljs-built_in">append</span>(chans, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;))<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br><span class="hljs-keyword">go</span> startTask(i, n, chans)<br>&#125;<br>chans[<span class="hljs-number">0</span>] &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中，token 代指“击鼓传花”中的“花”，chans 代指围坐一圈的人。每个 chan（人）都是从上一个 chan（人）手中拿到 token，放在自己手上，从而实现顺序打印 1，2，3，4。</p><h2 id="信号通知"><a href="#信号通知" class="headerlink" title="信号通知"></a>信号通知</h2><p>channel 类型有这样一个特性：如果 channel 为空，那么 recevier 接收数据的时候就会阻塞，直到有新的数据进来或者 channel 被关闭。</p><p>利用这个特性，就可以实现 wait/notify 设计模式。另外还有一个经常碰到的场景，实现程序的 graceful shutdown。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      ...... <span class="hljs-comment">// 执行业务处理</span><br>    &#125;()<br><br>  <span class="hljs-comment">// 处理CTRL+C等中断信号</span><br>  termChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal)<br>  signal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM)<br>  &lt;-termChan <br><br>  <span class="hljs-comment">// 执行退出之前的清理动作</span><br>  doCleanup()<br>  <br>  fmt.Println(<span class="hljs-string">&quot;优雅退出&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，如果清理操作很耗时，需要增加超时限制，doClenup() 可以进行如下改写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    closed := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>    <br>    ...... <span class="hljs-comment">// 中间过程都一样</span><br>    <br>    <span class="hljs-comment">// 执行退出之前的清理操作</span><br>    <span class="hljs-keyword">go</span> doCleanup(closed)<br>    <br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-closed:<br>    <span class="hljs-keyword">case</span> &lt;-time.After(time.Second):<br>        fmt.Println(<span class="hljs-string">&quot;清理超时，不等了！&quot;</span>)<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;优雅退出！&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doCleanup</span><span class="hljs-params">(closed <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br>    time.Sleep(time.Minute)<br>    <span class="hljs-built_in">close</span>(closed)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>在这个系列最开始就介绍了 <a href="https://mp.weixin.qq.com/s/gjXH9RU_8X_MASHMINHNVQ">Go 中 Mutex 设计原理详解（一）</a>。利用 channel 我们也能实现锁的功能。</p><p>sync.Mutex 通过修改持有锁标记位的状态达到占有锁的目的，因此 channel 可以通过转移这个标记位的所有权实现占有锁。</p><p>具体代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// 使用chan实现互斥锁</span><br><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;<br>    ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 使用锁需要初始化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMutex</span><span class="hljs-params">()</span> *<span class="hljs-title">Mutex</span></span> &#123;<br>    mu := &amp;Mutex&#123;<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)&#125;<br>    mu.ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    <span class="hljs-keyword">return</span> mu<br>&#125;<br><br><span class="hljs-comment">// 请求锁，直到获取到</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">Lock</span><span class="hljs-params">()</span></span> &#123;<br>    &lt;-m.ch<br>&#125;<br><br><span class="hljs-comment">// 解锁</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">Unlock</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> m.ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;:<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unlock of unlocked mutex&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 尝试获取锁</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">TryLock</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-m.ch:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">default</span>:<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 加入一个超时的设置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">LockTimeout</span><span class="hljs-params">(timeout time.Duration)</span> <span class="hljs-title">bool</span></span> &#123;<br>    timer := time.NewTimer(timeout)<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-m.ch:<br>        timer.Stop()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">case</span> &lt;-timer.C:<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 锁是否已被持有</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">IsLocked</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(m.ch) == <span class="hljs-number">0</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := NewMutex()<br>    ok := m.TryLock()<br>    fmt.Printf(<span class="hljs-string">&quot;locked v %v\n&quot;</span>, ok)<br>    ok = m.TryLock()<br>    fmt.Printf(<span class="hljs-string">&quot;locked %v\n&quot;</span>, ok)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里实现锁主要利用了向满 channel 发送数组或从空 channel 接收数据会阻塞的特性。另外，利用 select 很容易实现 TryLock 和 Timeout 的功能。</p><h2 id="任务编排"><a href="#任务编排" class="headerlink" title="任务编排"></a>任务编排</h2><p>在前面的 <a href="https://mp.weixin.qq.com/s/GhM-xnBWazxii2G0uvwOew">Go 并发任务编排利器之 WaitGroup</a> 中介绍了 sync.WaitGroup。通过 sync.WaitGroup，我们能很容易的实现 <em>等待一组 goroutine 完成任务</em> 这种任务编排需求。同样，我们也可以用 channel 实现。</p><p>但是如果任务编排再复杂一些呢？如果面试官出了下面这个题目：</p><blockquote><p>有一批任务需要处理，但是机器资源有限，只能承受100的并发度，该如何实现？</p></blockquote><p>一种解决方案就是使用 channel，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">task</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-comment">//执行任务</span><br>time.Sleep(time.Second * <span class="hljs-number">10</span>)<br>ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">concurrency100</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">100</span>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>&lt;-ch<br><span class="hljs-keyword">go</span> task(ch)<br>&#125;<br>&#125;()<br><span class="hljs-keyword">for</span> &#123;<br>fmt.Println(runtime.NumGoroutine())  <span class="hljs-comment">// 观察并发度</span><br>time.Sleep(time.Second)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用 sender 给满员的 channel 发送数据会阻塞的特性，就实现了并发度始终维持在 100 的需求。</p><p>除此之外，下面再介绍几种常见的模式。</p><h3 id="or-Done-模式"><a href="#or-Done-模式" class="headerlink" title="or-Done 模式"></a>or-Done 模式</h3><p>or-Done 模式对应的场景很好理解，n 个任务，有一个完成就算完成。</p><p>看过之前文章 <a href="https://mp.weixin.qq.com/s/4Z2hhn1H6F95wPnFfMz1bA">记一次学习 orDone 模式爬坑经历</a> 读者对 or-Done 应该不陌生，因为课程中关于 or-Done 模式的代码是<strong>有问题的！</strong></p><p>正确的代码应该是下面这个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">or</span><span class="hljs-params">(channels ...&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123; <span class="hljs-comment">//1</span><br><br><span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(channels) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">//2</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">//3</span><br><span class="hljs-keyword">return</span> channels[<span class="hljs-number">0</span>]<br>&#125;<br><br>orDone := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//4</span><br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(orDone)<br><br><span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(channels) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">//5</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">0</span>]:<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">1</span>]:<br>&#125;<br><span class="hljs-keyword">default</span>: <span class="hljs-comment">//6</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">0</span>]:<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">1</span>]:<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">2</span>]:<br><span class="hljs-keyword">case</span> &lt;-or(<span class="hljs-built_in">append</span>(channels[<span class="hljs-number">3</span>:], orDone)...): <span class="hljs-comment">//6</span><br>&#125;<br>&#125;<br>&#125;()<br><span class="hljs-keyword">return</span> orDone<br>&#125;<br></code></pre></td></tr></table></figure><p>在编写 or-Done 的代码时，有两个点需要注意：</p><ol><li>递归前，需要声明一个 orDone 变量，用来通知子函数退出。</li><li>len(channels) == 2 是一种特殊情况，否则会因为 append orDone 产生无限递归。</li></ol><h3 id="扇入模式"><a href="#扇入模式" class="headerlink" title="扇入模式"></a>扇入模式</h3><p>扇入（Fan-In）是一个术语，用于描述将多个结果组合到一个 channel 中的过程。扇入模式下，输入源有多个，输出目标只有一个。下面是扇入模式的一种实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fanInRec</span><span class="hljs-params">(chans ...&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(chans) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>        <span class="hljs-built_in">close</span>(c)<br>        <span class="hljs-keyword">return</span> c<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> chans[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> mergeTwo(chans[<span class="hljs-number">0</span>], chans[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">default</span>:<br>        m := <span class="hljs-built_in">len</span>(chans) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> mergeTwo( <span class="hljs-comment">// 对多个数据进行合并处理</span><br>            fanInRec(chans[:m]...),<br>            fanInRec(chans[m:]...))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="扇出模式"><a href="#扇出模式" class="headerlink" title="扇出模式"></a>扇出模式</h3><p>扇出模式（Fan-Out）只有一个输入源，但是有多个输出目标。下面是一个扇出模式的实现，从源 channel 取出一个数据后，依次发送给多个目标 channel。发送的时候，既可以同步，也可以异步。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fanOut</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, out []<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, async <span class="hljs-keyword">bool</span>)</span></span> &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//退出时关闭所有的输出chan</span><br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(out); i++ &#123;<br>                <span class="hljs-built_in">close</span>(out[i])<br>            &#125;<br>        &#125;()<br><br>        <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123; <span class="hljs-comment">// 从输入chan中读取数据</span><br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(out); i++ &#123;<br>                <span class="hljs-keyword">if</span> async &#123; <span class="hljs-comment">//异步</span><br>                    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>                        out[i] &lt;- v <span class="hljs-comment">// 放入到输出chan中,异步方式</span><br>                    &#125;()<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    out[i] &lt;- v <span class="hljs-comment">// 放入到输出chan中，同步方式</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><p>stream 是把 channel 当做流式管道的方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// asStream 将一个 slice 转成流</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">asStream</span><span class="hljs-params">(done &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, values ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>    s := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-comment">//创建一个unbuffered的channel</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 启动一个goroutine，往s中塞数据</span><br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(s) <span class="hljs-comment">// 退出时关闭chan</span><br>        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123; <span class="hljs-comment">// 遍历数组</span><br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-done:<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">case</span> s &lt;- v: <span class="hljs-comment">// 将数组元素塞入到chan中</span><br>            &#125;<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>转成流之后，如果要实现取前 N 个数的功能 TakeN，可以再创建一个输出流，从输入流中读取: </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">takeN</span><span class="hljs-params">(done &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, valueStream &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, num <span class="hljs-keyword">int</span>)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>    takeStream := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-comment">// 创建输出流</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(takeStream)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; num; i++ &#123; <span class="hljs-comment">// 只读取前num个元素</span><br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-done:<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">case</span> takeStream &lt;- &lt;-valueStream: <span class="hljs-comment">//从输入流中读取元素</span><br>            &#125;<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> takeStream<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map-reduce"></a>map-reduce</h3><p>map-reduce 是一种面向大规模数据处理的并行计算模型和方法，但是这里要介绍的是一种单机版的 map-reduce 模式。</p><p>map-reduce 分为两个步骤，第一步是 map，将队列中的数据用 mapFn 函数处理；第二步是 reduce，将处理后的数据用 reduceFn 函数汇总。</p><p>map 逻辑实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapChan</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, mapFn <span class="hljs-keyword">func</span>(<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125;) &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-comment">//创建一个输出chan</span><br>    <span class="hljs-keyword">if</span> in == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 异常检查</span><br>        <span class="hljs-built_in">close</span>(out)<br>        <span class="hljs-keyword">return</span> out<br>    &#125;<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 启动一个goroutine,实现map的主要逻辑</span><br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(out)<br>        <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> in &#123; <span class="hljs-comment">// 从输入chan读取数据，执行业务操作，也就是map操作</span><br>            out &lt;- mapFn(v)<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">return</span> out<br>&#125;<br></code></pre></td></tr></table></figure><p>reduce 逻辑实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reduce</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, reduceFn <span class="hljs-keyword">func</span>(r, v <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">if</span> in == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 异常检查</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    out := &lt;-in <span class="hljs-comment">// 先读取第一个元素</span><br>    <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> in &#123; <span class="hljs-comment">// 实现reduce的主要逻辑</span><br>        out = reduceFn(out, v)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> out<br>&#125;<br></code></pre></td></tr></table></figure><p>想象这样一个需求：将一组数据中每个数据乘以10，最后计算总和。为此，我们需要实现 mapFn (乘 10) 和 reduceFn （求和）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Go"><br><span class="hljs-comment">// 生成一个数据流</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">asStream</span><span class="hljs-params">(done &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>    s := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>    values := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(s)<br>        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123; <span class="hljs-comment">// 从数组生成</span><br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-done:<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">case</span> s &lt;- v:<br>            &#125;<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    in := asStream(<span class="hljs-literal">nil</span>)<br><br>    <span class="hljs-comment">// map操作: 乘以10</span><br>    mapFn := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>        <span class="hljs-keyword">return</span> v.(<span class="hljs-keyword">int</span>) * <span class="hljs-number">10</span><br>    &#125;<br><br>    <span class="hljs-comment">// reduce操作: 对map的结果进行累加</span><br>    reduceFn := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r, v <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>        <span class="hljs-keyword">return</span> r.(<span class="hljs-keyword">int</span>) + v.(<span class="hljs-keyword">int</span>)<br>    &#125;<br><br>    sum := reduce(mapChan(in, mapFn), reduceFn) <span class="hljs-comment">//返回累加结果</span><br>    fmt.Println(sum)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇过了一遍基于 channel 的几种典型应用模式，这些模式都不复杂，但是要做到灵活运用却不容易，平时写代码过程中如果遇到相应场景，还要仔细留心体会，多加练习。</p><p>到这里，channel 相关的知识点就告一段落了。</p><p>喜极而泣~</p><p>下期开始新的章节，再见~</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p><p><strong>都看到这里了，不如加个关注呗~~</strong></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>channel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 并发基石之 channel (二) —— 源码初探</title>
    <link href="/2021/05/16/go-channel-2/"/>
    <url>/2021/05/16/go-channel-2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Go 并发系列是根据我对晁岳攀老师的《Go 并发编程实战课》的吸收和理解整理而成，如有偏差，欢迎指正~</p></blockquote><p>在上一篇 <a href="https://tjjsjwhj.me/2021/05/06/go-channel-1/">Go 并发基石之 channel（一）</a> 中简单介绍了 channel 的由来、基本用法以及几种容易出错的场景。</p><p>这一篇，尝试通过 channel 源码的阅读，了解 channel 的实现思路。</p><p><em>说明：以下源码均基于 go1.16。</em></p><h2 id="channel-的定义"><a href="#channel-的定义" class="headerlink" title="channel 的定义"></a>channel 的定义</h2><p>channel 的数据类型是 <a href="https://github.com/golang/go/blob/release-branch.go1.16/src/runtime/chan.go">runtime.hchan</a>，其详细定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br>qcount   <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// channel中元素的个数</span><br>dataqsiz <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// channel的容量</span><br>buf      unsafe.Pointer <span class="hljs-comment">// 指向底层循环队列的指针</span><br>elemsize <span class="hljs-keyword">uint16</span>         <span class="hljs-comment">// 元素的大写</span><br>closed   <span class="hljs-keyword">uint32</span>         <span class="hljs-comment">// 是否关闭的标志</span><br>elemtype *_type <span class="hljs-comment">// 元素的类型</span><br>sendx    <span class="hljs-keyword">uint</span>   <span class="hljs-comment">// 已发送元素在队列中的索引</span><br>recvx    <span class="hljs-keyword">uint</span>   <span class="hljs-comment">// 已接收元素在队列中的索引</span><br>recvq    waitq  <span class="hljs-comment">// 等待接收数据的协程队列</span><br>sendq    waitq  <span class="hljs-comment">// 等待发送数据的协程队列</span><br><br><span class="hljs-comment">// 锁，保护hchan中所有字段</span><br>lock mutex<br>&#125;<br></code></pre></td></tr></table></figure><p>整体上，channel 的设计思路可以概述为用一个循环队列存储数据，send 索引和 recv 索引记录发送和接收数据的节点。向 channel 发送的数据会被添加循环队列尾部；从 channel 接收的数据来自于队列的首部。</p><h2 id="channel-的创建"><a href="#channel-的创建" class="headerlink" title="channel 的创建"></a>channel 的创建</h2><p>创建 channel 的语句如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)       <span class="hljs-comment">// 无缓冲的channel</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">2</span>)    <span class="hljs-comment">// 有缓冲的channel</span><br></code></pre></td></tr></table></figure><p>make 函数的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// walkMakeChan walks an OMAKECHAN node.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkMakeChan</span><span class="hljs-params">(n *ir.MakeExpr, init *ir.Nodes)</span> <span class="hljs-title">ir</span>.<span class="hljs-title">Node</span></span> &#123;<br><span class="hljs-comment">// When size fits into int, use makechan instead of</span><br><span class="hljs-comment">// makechan64, which is faster and shorter on 32 bit platforms.</span><br>size := n.Len<br>fnname := <span class="hljs-string">&quot;makechan64&quot;</span><br>argtype := types.Types[types.TINT64]<br><br><span class="hljs-keyword">if</span> size.Type().IsKind(types.TIDEAL) || size.Type().Size() &lt;= types.Types[types.TUINT].Size() &#123;<br>fnname = <span class="hljs-string">&quot;makechan&quot;</span><br>argtype = types.Types[types.TINT]<br>&#125;<br><span class="hljs-keyword">return</span> mkcall1(chanfn(fnname, <span class="hljs-number">1</span>, n.Type()), n.Type(), init, reflectdata.TypePtr(n.Type()), typecheck.Conv(size, argtype))<br>&#125;<br></code></pre></td></tr></table></figure><p>仅仅看注释，也能猜出来，make 的时候，编译器会根据系统的位数选择对应的函数： makechan64 还是 makechan。makechan64 底层直接调用的 makechan。所以我们直接看 makechane 的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">const</span> (<br>  <span class="hljs-comment">// maxAlign 用来设置内存最大对齐值</span><br>maxAlign  = <span class="hljs-number">8</span><br><span class="hljs-comment">// hchanSize 是大于 Sizeof(hchan&#123;&#125;) 的且为8的倍数中最小的一个</span><br>hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="hljs-keyword">uintptr</span>(-<span class="hljs-keyword">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="hljs-number">-1</span>))<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makechan</span><span class="hljs-params">(t *chantype, size <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">hchan</span></span> &#123;<br>elem := t.elem<br><br><span class="hljs-comment">// 元素最大不能超过64K</span><br><span class="hljs-keyword">if</span> elem.size &gt;= <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span> &#123;<br>throw(<span class="hljs-string">&quot;makechan: invalid channel element type&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> hchanSize%maxAlign != <span class="hljs-number">0</span> || elem.align &gt; maxAlign &#123;<br>throw(<span class="hljs-string">&quot;makechan: bad alignment&quot;</span>)<br>&#125;<br><br>mem, overflow := math.MulUintptr(elem.size, <span class="hljs-keyword">uintptr</span>(size))<br><span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;makechan: size out of range&quot;</span>))<br>&#125;<br><br>  <span class="hljs-comment">// 下面这个注释没太看明白，先放着，等以后看完 gc 再重新了解。 </span><br><span class="hljs-comment">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span><br><span class="hljs-comment">// buf points into the same allocation, elemtype is persistent.</span><br><span class="hljs-comment">// SudoG&#x27;s are referenced from their owning thread so they can&#x27;t be collected.</span><br><span class="hljs-keyword">var</span> c *hchan<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> mem == <span class="hljs-number">0</span>:<br><span class="hljs-comment">// 无缓冲</span><br>c = (*hchan)(mallocgc(hchanSize, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>))<br>c.buf = c.raceaddr()<br><span class="hljs-keyword">case</span> elem.ptrdata == <span class="hljs-number">0</span>:<br><span class="hljs-comment">// 非指针类型元素内存申请方式</span><br>c = (*hchan)(mallocgc(hchanSize+mem, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>))<br>c.buf = add(unsafe.Pointer(c), hchanSize)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// 指针类型元素内存申请方式</span><br>c = <span class="hljs-built_in">new</span>(hchan)<br>c.buf = mallocgc(mem, elem, <span class="hljs-literal">true</span>)<br>&#125;<br><br>c.elemsize = <span class="hljs-keyword">uint16</span>(elem.size)<br>c.elemtype = elem<br>c.dataqsiz = <span class="hljs-keyword">uint</span>(size)<br>lockInit(&amp;c.lock, lockRankHchan)<br><br><span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><p>梳理 makechan 的逻辑之前，先看下常量 maxAlign 和 hchanSize。</p><p><em>maxAlign</em>： 内存对齐最大值，这里8表示64位对齐。<br><em>hchanSize</em>： 大于 Sizeof(hchan{}) 且为8的倍数中最小的一个，其目的是提高 CPU 存取的速度（<strong>CPU 按块存取数据，块的大小可以是8、16、24等字节</strong>）。</p><p>第 20 行，计算需要给循环队列 buf 分配的内存，如果超过最大限制，则抛出异常。</p><p>接下来的内存分配流程比较清晰。</p><p>如果 mem == 0，说明是无缓冲 channel，只需要分配 hchan 本身的内存；如果缓冲数据是值类型，则分配 hchanSize+mem 大小的连续内存，buf 指向循环队列；如果缓冲数据是指针类型，则分别分配 hchan 和循环队列的内存。</p><h2 id="往-channel-发送数据"><a href="#往-channel-发送数据" class="headerlink" title="往 channel 发送数据"></a>往 channel 发送数据</h2><p>以下是往 channel 发送数据的语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Go">ch &lt;- <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>其对应源码如下（解释见注释）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// entry point for c &lt;- x from compiled code</span><br><span class="hljs-comment">//go:nosplit</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend1</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;<br>chansend(c, elem, <span class="hljs-literal">true</span>, getcallerpc())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-keyword">bool</span>, callerpc <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br>   <span class="hljs-comment">// 发送操作有个是否阻塞的判断，如果是非阻塞模式，直接返回false，不会被挂起（如果是select case 语句，block 就是 false）。</span><br><span class="hljs-keyword">if</span> !block &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">// waitReasonChanSendNilChan: &quot;chan send (nil chan)&quot;</span><br>gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>&#125;<br>   <span class="hljs-comment">// 非阻塞模式，缓冲区满了，直接返回false</span><br><span class="hljs-keyword">if</span> !block &amp;&amp; c.closed == <span class="hljs-number">0</span> &amp;&amp; full(c) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">var</span> t0 <span class="hljs-keyword">int64</span><br><span class="hljs-comment">// 控制协程信息的输出比例，具体可执行 go doc runtime.SetBlockProfileRate 看详细的解释。</span><br><span class="hljs-keyword">if</span> blockprofilerate &gt; <span class="hljs-number">0</span> &#123;<br>t0 = cputicks()<br>&#125;<br><br>lock(&amp;c.lock)<br>  <span class="hljs-comment">// 如果 channel 被关闭，抛出异常</span><br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;send on closed channel&quot;</span>))<br>&#125;<br>  <br>  <span class="hljs-comment">// 如果这会有正在等待接收数据的协程，则直接把数据传过去</span><br><span class="hljs-keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br>send(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br>  <span class="hljs-comment">// 如果缓冲队列还有空位，就把要发送的数据拷贝到 sendx 处</span><br><span class="hljs-keyword">if</span> c.qcount &lt; c.dataqsiz &#123;<br>qp := chanbuf(c, c.sendx)<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racenotify(c, c.sendx, <span class="hljs-literal">nil</span>)<br>&#125;<br>typedmemmove(c.elemtype, qp, ep)<br>c.sendx++<br><span class="hljs-keyword">if</span> c.sendx == c.dataqsiz &#123;<br>c.sendx = <span class="hljs-number">0</span><br>&#125;<br>c.qcount++<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">if</span> !block &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 如果缓冲区满了，将发送数据的协程挂起</span><br><span class="hljs-comment">// 构造一个 mysg:sudog(goroutine 的封装)</span><br>gp := getg()<br>mysg := acquireSudog()<br>mysg.releasetime = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> t0 != <span class="hljs-number">0</span> &#123;<br>mysg.releasetime = <span class="hljs-number">-1</span><br>&#125;<br><br>mysg.elem = ep<br>mysg.waitlink = <span class="hljs-literal">nil</span><br>mysg.g = gp<br>mysg.isSelect = <span class="hljs-literal">false</span><br>mysg.c = c<br>gp.waiting = mysg<br>gp.param = <span class="hljs-literal">nil</span><br><span class="hljs-comment">// 将发送协程放到发送队列中</span><br>c.sendq.enqueue(mysg)<br><br>atomic.Store8(&amp;gp.parkingOnChan, <span class="hljs-number">1</span>)<br>gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="hljs-number">2</span>)<br><br>KeepAlive(ep)<br><br><span class="hljs-comment">// 发送协程被唤醒</span><br><span class="hljs-keyword">if</span> mysg != gp.waiting &#123;<br>throw(<span class="hljs-string">&quot;G waiting list is corrupted&quot;</span>)<br>&#125;<br>gp.waiting = <span class="hljs-literal">nil</span><br>gp.activeStackChans = <span class="hljs-literal">false</span><br>closed := !mysg.success<br>gp.param = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> mysg.releasetime &gt; <span class="hljs-number">0</span> &#123;<br>blockevent(mysg.releasetime-t0, <span class="hljs-number">2</span>)<br>&#125;<br>mysg.c = <span class="hljs-literal">nil</span><br>releaseSudog(mysg)<br><span class="hljs-keyword">if</span> closed &#123;<br><span class="hljs-keyword">if</span> c.closed == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;chansend: spurious wakeup&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 如果不巧，channel 已经被关闭了，抛出异常</span><br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;send on closed channel&quot;</span>))<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不深究细节，只看流程，chansend 还比较好理解，只是 if 分支比较多，不容易厘清，可以对着下面的流程图一起看：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/16/chansend.png" alt="chansend"></p><h2 id="从-channel-接收数据"><a href="#从-channel-接收数据" class="headerlink" title="从 channel 接收数据"></a>从 channel 接收数据</h2><p>从 channel 接收数据的写法有两种：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Go">a := &lt;-ch<br>a, ok := &lt;-ch<br></code></pre></td></tr></table></figure><p>分别对应如下两个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// entry points for &lt;- c from compiled code</span><br><span class="hljs-comment">//go:nosplit</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv1</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;<br>chanrecv(c, elem, <span class="hljs-literal">true</span>)<br>&#125;<br><br><span class="hljs-comment">// 处理带 ok 的情形</span><br><span class="hljs-comment">//go:nosplit</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv2</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span> <span class="hljs-params">(received <span class="hljs-keyword">bool</span>)</span></span> &#123;<br>_, received = chanrecv(c, elem, <span class="hljs-literal">true</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这两个函数都是通过调用 chanrecv 实现（主要解释见注释）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-keyword">bool</span>)</span> <span class="hljs-params">(selected, received <span class="hljs-keyword">bool</span>)</span></span> &#123;<br><br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br>   <span class="hljs-comment">// 非阻塞模式下，直接返回false</span><br><span class="hljs-keyword">if</span> !block &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 否则挂起</span><br>gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>&#125;<br><br>  <span class="hljs-comment">// 非阻塞模式，且chanel缓冲队列为空的情况下，不涉及加锁解锁操作，故优先处理</span><br><span class="hljs-keyword">if</span> !block &amp;&amp; empty(c) &#123;<br><span class="hljs-keyword">if</span> atomic.Load(&amp;c.closed) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// empty 是在其它地方实现的，两种情况下会为true：</span><br><span class="hljs-comment">// 1) 无缓冲且无发送协程</span><br><span class="hljs-comment">// 2) 有缓冲但循环队列为空</span><br><span class="hljs-comment">// 故非阻塞情况下，可以直接返回false</span><br><span class="hljs-comment">// 这里channel已经被关闭，再次检查channel是否empty</span><br><span class="hljs-keyword">if</span> empty(c) &#123;<br>   <span class="hljs-comment">// 从关闭的channel中接收同样类型的零值</span><br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemclr(c.elemtype, ep)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> t0 <span class="hljs-keyword">int64</span><br><span class="hljs-keyword">if</span> blockprofilerate &gt; <span class="hljs-number">0</span> &#123;<br>t0 = cputicks()<br>&#125;<br><br>lock(&amp;c.lock)<br><br>  <span class="hljs-comment">// 阻塞模式下，如果channel已经被关闭，并且缓冲队列中为空</span><br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &amp;&amp; c.qcount == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquire(c.raceaddr())<br>&#125;<br>unlock(&amp;c.lock)<br><span class="hljs-comment">// 从关闭的channel中接收同样类型的零值</span><br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemclr(c.elemtype, ep)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span><br>&#125;<br>  <br>  <span class="hljs-comment">// 有等待的发送者，说明：</span><br>  <span class="hljs-comment">// 1) 无缓冲：直接将发送者的数据传给接收者</span><br>  <span class="hljs-comment">// 2) 缓冲已满：将队列首位数据给接收者，并将发送者的数据放到队列尾部</span><br>  <span class="hljs-comment">// 3) channnel 没有被关闭</span><br><span class="hljs-keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br>recv(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>&#125;<br><br>  <span class="hljs-comment">// 缓冲队列不为空</span><br>  <span class="hljs-comment">// 对recv而言，接下来只需要关心缓冲队列有没有元素，不需要关心channel有没有被关闭</span><br><span class="hljs-keyword">if</span> c.qcount &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Receive directly from queue</span><br>qp := chanbuf(c, c.recvx)<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racenotify(c, c.recvx, <span class="hljs-literal">nil</span>)<br>&#125;<br><span class="hljs-comment">// 将队列头部数据拷贝给接收者</span><br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemmove(c.elemtype, ep, qp)<br>&#125;<br><span class="hljs-comment">// 发送完之后，清空，同时 recv 往后挪一位</span><br>typedmemclr(c.elemtype, qp)<br>c.recvx++<br><span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;<br>c.recvx = <span class="hljs-number">0</span><br>&#125;<br>c.qcount--<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>&#125;<br><br>  <span class="hljs-comment">// 缓冲队列容量为0，且非阻塞，直接返回false</span><br><span class="hljs-keyword">if</span> !block &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 阻塞模式下，缓冲队列容量为0，将发送数据的协程挂起</span><br><span class="hljs-comment">// 构造一个 mysg:sudog(goroutine 的封装)</span><br>gp := getg()<br>mysg := acquireSudog()<br>mysg.releasetime = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> t0 != <span class="hljs-number">0</span> &#123;<br>mysg.releasetime = <span class="hljs-number">-1</span><br>&#125;<br><br>mysg.elem = ep<br>mysg.waitlink = <span class="hljs-literal">nil</span><br>gp.waiting = mysg<br>mysg.g = gp<br>mysg.isSelect = <span class="hljs-literal">false</span><br>mysg.c = c<br>gp.param = <span class="hljs-literal">nil</span><br>c.recvq.enqueue(mysg)<br><br>atomic.Store8(&amp;gp.parkingOnChan, <span class="hljs-number">1</span>)<br>gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 接收数据的协程被唤醒</span><br><span class="hljs-keyword">if</span> mysg != gp.waiting &#123;<br>throw(<span class="hljs-string">&quot;G waiting list is corrupted&quot;</span>)<br>&#125;<br>gp.waiting = <span class="hljs-literal">nil</span><br>gp.activeStackChans = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> mysg.releasetime &gt; <span class="hljs-number">0</span> &#123;<br>blockevent(mysg.releasetime-t0, <span class="hljs-number">2</span>)<br>&#125;<br>success := mysg.success<br>gp.param = <span class="hljs-literal">nil</span><br>mysg.c = <span class="hljs-literal">nil</span><br>releaseSudog(mysg)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, success<br>&#125;<br></code></pre></td></tr></table></figure><p>chanrecv 的 if 判断可以对着下面的流程图看：<br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/16/chanrecv.jpg" alt="chanrecv"></p><h2 id="close-一个-channel"><a href="#close-一个-channel" class="headerlink" title="close 一个 channel"></a>close 一个 channel</h2><p>关闭 一个 channel 的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">closechan</span><span class="hljs-params">(c *hchan)</span></span> &#123;<br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;close of nil channel&quot;</span>))<br>&#125;<br><br>lock(&amp;c.lock)<br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;close of closed channel&quot;</span>))<br>&#125;<br><br>c.closed = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">var</span> glist gList<br><br><span class="hljs-comment">// release all readers</span><br><span class="hljs-keyword">for</span> &#123;<br>sg := c.recvq.dequeue()<br><span class="hljs-keyword">if</span> sg == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> sg.elem != <span class="hljs-literal">nil</span> &#123;<br>   <span class="hljs-comment">// close之后，读到的都是零值</span><br>typedmemclr(c.elemtype, sg.elem)<br>sg.elem = <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;<br>sg.releasetime = cputicks()<br>&#125;<br>gp := sg.g<br>gp.param = unsafe.Pointer(sg)<br>sg.success = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquireg(gp, c.raceaddr())<br>&#125;<br>glist.push(gp)<br>&#125;<br><br><span class="hljs-comment">// release all writers (they will panic)</span><br><span class="hljs-keyword">for</span> &#123;<br>sg := c.sendq.dequeue()<br><span class="hljs-keyword">if</span> sg == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>sg.elem = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;<br>sg.releasetime = cputicks()<br>&#125;<br>gp := sg.g<br>gp.param = unsafe.Pointer(sg)<br>sg.success = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquireg(gp, c.raceaddr())<br>&#125;<br>glist.push(gp)<br>&#125;<br>unlock(&amp;c.lock)<br><br><span class="hljs-comment">// Ready all Gs now that we&#x27;ve dropped the channel lock.</span><br><span class="hljs-keyword">for</span> !glist.empty() &#123;<br>gp := glist.pop()<br>gp.schedlink = <span class="hljs-number">0</span><br>goready(gp, <span class="hljs-number">3</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>close 一个 channel 之前，如果这是 channel 是 nil 或者已经被 close ，则抛出异常。</p><p>接下来，close 的动作有三块：</p><p>1）修改 c.closed 标志位<br>2）唤醒所有读协程：读到的都是零值<br>3）唤醒所有写协程：chansend 中会抛出异常</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>粗略的过了一遍 channel 的源码，还是有不少细节没看明白，但是目前水平所限，只能看到这一步。期待对 Go 有了进一步的了解之后，再回过头来重温，能有新的认识。</p><p>下一期过一遍基于 channel 的几种并发模式。</p><p>就这样，下一期再见~</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>channel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#7——实证升级了！</title>
    <link href="/2021/05/06/invest-pratice-7/"/>
    <url>/2021/05/06/invest-pratice-7/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://tjjsjwhj.me/2020/07/18/invest-pratice-0/">财务自由实证#0——自由能实现吗？</a>。</p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更“美好”的事物上。</p><h2 id="准备换种方式来写实证"><a href="#准备换种方式来写实证" class="headerlink" title="准备换种方式来写实证"></a>准备换种方式来写实证</h2><p>五一假期已经过去一大半了，这个假期大家过的如何?</p><p>又到了写实证的时候，发现没太多东西可写。如果实证仅仅是记录一个数字，感觉意义不是很大。正好昨天看到<em>知行小酒馆</em>把之前对也大的一次访谈记录置顶了，就又重温了一遍。</p><p>这篇访谈中，也大强调了我们不应该被困在【<strong>等我自由了，我就如何如何</strong>】的假设里面，因为很多事情不需要等到自由，就可以开始行动。</p><p><strong>如果现在不做，那凭什么认为自由之后还会做呢？</strong></p><p>不是自由了才能怎样，而是做完了之后发现，自己离自由更近了一步。在追求自由的过程中，由于短期内市场的波动无法预测，财务计划的进展是不受控制的；但是为了追求自由所做的其它努力是可控，并且可以量化的。</p><p>因此经过思考，打算将该实证从单纯的财务实证<em>升级</em>为个人成长实证。格式上，固化以下三个模块：</p><p><strong>实证进展</strong></p><ul><li>虽然进展不可控，但是数字还是最直接的体现，所以这部分仍然保留。</li></ul><p><strong>本月回顾</strong></p><ul><li>该部分用于回顾本月计划完成情况。</li></ul><p><strong>下月计划</strong></p><ul><li>该部分用于规划下个月需要完成的任务。</li></ul><p>嗯，也好给年底的年终总结提供素材[\机智]</p><h2 id="实证进展"><a href="#实证进展" class="headerlink" title="实证进展"></a>实证进展</h2><p>本月进展如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/16199486555411.jpg" alt="-w414"></p><p>当前进展 2.46%，相比上个月增加了 0.2%，终于有了肉眼可变的变化了，喜极而泣~</p><p>其实在春节附近，就曾经达到过这个数字，后来市场急剧向下，花了2个多月的时间才再次站上了这个高点。</p><p>本月特殊操作：无。</p><h2 id="合理的家庭资产配置"><a href="#合理的家庭资产配置" class="headerlink" title="合理的家庭资产配置"></a>合理的家庭资产配置</h2><p>这是一个老生常谈的话题，很多文章都写过如何对家庭资产进行一个合理的配置，在我之前的文章 <a href="https://tjjsjwhj.me/2020/10/10/invest-pratice-1/">财务自由实证#1——如何开始？</a> 中也提到过。</p><p>一般而言，一个合理的家庭资产配置方向大致如下：</p><ul><li>规划紧急备用金：活钱</li><li>规划必要的保险：风险杠杆</li><li>规划3年内要用的钱：短期存款、债券</li><li>规划长期要用的钱：股票、基金等</li></ul><p>之所以再把这个话题拿出来说，是因为最近这个月的经历让我对这个<strong>看似普通</strong>的配置方案有了新的认识。</p><p>3月底的时候，刚好有一个朋友因为买房，首付还差一点，借了一些；紧接着，4月底，摇号意外中签。</p><p>借的那部分对应的是活钱，中签这个对应的是3年内要用的钱。短短一个月内，这两笔钱都派上了用场。</p><blockquote><p>有知有行的温度计：13℃，这意味着市场再次到达了一个黄金位置。</p></blockquote><p>如果最开始没有严格分配4笔钱，而是都放到长期组合中，现在就会十分被动，不得不<strong>忍痛割肉</strong>。</p><p>之前对这个家庭资产配置方案的理解比较肤浅，这次的经历让我开始从另一个角度来理解这个方案。</p><p>在之前的认知中，我认为4笔钱的地位是相等的，只是场景不同，实际上并不是。</p><p>根据墨菲定律:</p><blockquote><p>如果坏事有可能发生，不管这种可能性有多小，它总会发生，并造成最大可能的破坏。</p></blockquote><p>前3笔钱的使用场景相对于4而言，就是<strong>坏事</strong>。一旦<strong>坏事</strong>发生，最大的破坏就是长期计划无法执行，功亏一篑。</p><p>这个方案的目的不是为了应对平时零用，也不是为了应对可能的大病，更不是为了应对3年内的大额支出，而是为了实现资产的最终增值。也就是说，前3笔的配置都是为了确保第4笔钱在增值的过程中不受到任何干扰。</p><h2 id="4月回顾"><a href="#4月回顾" class="headerlink" title="4月回顾"></a>4月回顾</h2><p><strong>写作</strong></p><p>本月一共写了三篇文章，一篇 Go 的，两篇投资理财相关的。数量上严重不达标。。</p><p>不过 <a href="https://tjjsjwhj.me/2021/05/06/%E5%AE%9A%E6%8A%95%E7%9A%84%E9%99%B7%E9%98%B1/">定投的“陷阱” </a> 这一篇的数据很好看，阅读、点赞、在看分别是383、22、15，三个数据都是历史新高，说明花心思写还是有用的！</p><p><strong>个人项目</strong></p><p>4月份完成了公众号服务端Demo的开发以及服务的部署，项目地址见：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://github.com/AFreeCoder/wechat-official-account<br></code></pre></td></tr></table></figure><p>现在还只是一个Demo，刚跑通了流程，效果如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/16201088646753.jpg" alt="-w414"></p><p>有了这个作为基础，后面的基金入门知识的 QABot 可以提上日程了。</p><h2 id="5月计划"><a href="#5月计划" class="headerlink" title="5月计划"></a>5月计划</h2><p><strong>写作</strong></p><ul><li>完成《Go 并发编程实战》channel 部分文章的输出，数量&gt;=4</li><li>完成行业指数、国外主流指数相关文章的输出，同时开始温度计的调研，数量&gt;=4</li></ul><p><strong>个人项目</strong></p><ul><li>语料库存储方案调研，完成一篇调研</li><li>根据历史文章，完成基金入门知识语料的整理，待整理文章6篇</li></ul><p>就这样，期待5月底的实证~~</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定投的“陷阱”</title>
    <link href="/2021/05/06/%E5%AE%9A%E6%8A%95%E7%9A%84%E9%99%B7%E9%98%B1/"/>
    <url>/2021/05/06/%E5%AE%9A%E6%8A%95%E7%9A%84%E9%99%B7%E9%98%B1/</url>
    
    <content type="html"><![CDATA[<p>不知道从什么时候开始，每当基金行情火爆的时候，各种自媒体文章都开始贩卖理财焦虑，套路都是职场某不起眼的同事A，通过理财获得了远超工资的睡后收入，劝你不要在傻傻的挣死工资了！</p><p>那同事A是怎么理财的呢？答案都是定投。</p><p>接着，这些文章会用爱因斯坦的那句名言“复利是这个世界上的第八大奇迹”开头，然后假设每月定投500，年化利率20%，定投30年，你就会有1000多万啦。</p><p>可是，定投真有这么神奇吗？</p><h2 id="定投真的是“无所不能”的吗？"><a href="#定投真的是“无所不能”的吗？" class="headerlink" title="定投真的是“无所不能”的吗？"></a>定投真的是“无所不能”的吗？</h2><p>如果定投的威力真的有这么大，那我们所有人都进行定投，50年后，地球上的财富还够分吗？</p><p>在知乎上搜索关键词：定投，会出来很多问题，除了一些说定投有多好的话题外，还有很多问题对定投充满了疑惑，比如下面这些问题：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">长期定投基金是骗局吗？<br>基金定投一定赚钱吗？<br>在支付宝买定投基金1年半了，越定投亏越多，怎么办？<br></code></pre></td></tr></table></figure><p>显然，仍有很多人对定投充满了疑惑，觉得一个普普通通的定投怎么可能赚很多呢？</p><p>这是因为很多文章在解释基金定投的时候，都会犯一个错误，就是将名义利率当成实际利率来计算，从而忽略了基金增长过程中的波动情况。</p><p>举个例子，某基金的初始净值是1，25年后期末净值是32.9，倒推该基金的年化收益率是15%，但是如果你定投这个基金，能用15%来推算预期收益吗，显然不行。</p><p>下面我用<strong>三种增长曲线假设</strong>来解释，不同的增长曲线下，收益差距是有多么夸张！</p><h3 id="步步高升"><a href="#步步高升" class="headerlink" title="步步高升"></a>步步高升</h3><p>第一种假设我把它叫做<strong>步步高升</strong>，意思是基金的走势完美的符合复利增长的曲线，示意图如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/jie-ping20210404-142145.png" alt="截屏2021-04-04 14.21.45"></p><p>如果定投增长曲线如图所示的基金，25年和30年的收益情况如下：</p><table><thead><tr><th>期限（年）</th><th>净投入</th><th>期末资产</th><th>总收益率</th><th>平均年化收益率</th></tr></thead><tbody><tr><td>25</td><td>300000</td><td>3243529</td><td>980%</td><td>15%</td></tr></tbody></table><p>显然，标准走势下，如果我们定投该基金，是能获得期望的收益的。</p><h3 id="出道即巅峰"><a href="#出道即巅峰" class="headerlink" title="出道即巅峰"></a>出道即巅峰</h3><p>第二种假设我把它叫做<strong>出道即巅峰</strong>。意思是基金一发行就遇到了大牛市，净值一飞冲天，之后的多年都没有什么变化，它的增长曲线示例如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/jie-ping20210404-143529.png" alt="截屏2021-04-04 14.35.29"></p><p>如果定投增长曲线如图所示的基金，收益情况如下表所示：</p><table><thead><tr><th>期限（年）</th><th>净投入</th><th>期末资产</th><th>总收益率</th><th>平均年化收益率</th></tr></thead><tbody><tr><td>25</td><td>300000</td><td>331900</td><td>10.63%</td><td>0.8%</td></tr></tbody></table><p>出道即巅峰这种走势下，平均年化收益率才0.8%，还不如货币基金的年化收益率，收益情况远远不达预期。</p><h3 id="大器晚成"><a href="#大器晚成" class="headerlink" title="大器晚成"></a>大器晚成</h3><p>第三种假设我把它叫做<strong>大器晚成</strong>。意思是基金发行之后一直是熊市，直到25年期末才忽然暴涨，它的增长曲线示例如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/jie-ping20210404-144103.png" alt="截屏2021-04-04 14.41.03"></p><p>如果定投增长曲线如图所示的基金，收益情况如下表所示：</p><table><thead><tr><th>期限（年）</th><th>净投入</th><th>期末资产</th><th>总收益率</th><th>平均年化收益率</th></tr></thead><tbody><tr><td>25</td><td>300000</td><td>9870000</td><td>3190%</td><td>22.86%</td></tr></tbody></table><p>大器晚成这种走势下，总收益率达到了3190%，平均年化收益率达到了22.86%，远远超过了预期！</p><h2 id="真实市场回测"><a href="#真实市场回测" class="headerlink" title="真实市场回测"></a>真实市场回测</h2><p>真实的基金走势并不会像上面三种假设那样极端，但是通过这三种极端假设，我们仍然能得出一个结论：简单的定投并不一定能让我们获得预期的收益，还是得看真实的基金走势如何。</p><p>更何况，基金的真实波动远比这三种假设复杂很多，也更难预测的多。</p><p>回到真实环境中，我们可以用沪深300做一个简单的回测。沪深300的指数基日是2004年12月31日，基点1000，截止2021年4月2号，收盘指数值是5161.56，对应的平均年化收益率是10.53%</p><p>如果采取每月定投1000的方式定投沪深300ETF，最终收益如下：</p><table><thead><tr><th>期限（年）</th><th>净投入</th><th>期末资产</th><th>总收益率</th><th>平均年化收益率</th></tr></thead><tbody><tr><td>16年零5个月</td><td>197000</td><td>408,658</td><td>107.44%</td><td>8.41%</td></tr></tbody></table><p>定投的实际年化收益率是8.41%，比指数的年化收益率低一些，不过也还不错了。</p><h2 id="定投还有必要吗？"><a href="#定投还有必要吗？" class="headerlink" title="定投还有必要吗？"></a>定投还有必要吗？</h2><p>上面啰啰嗦嗦说了那么多，其实就想说明一件事，定投的收益不能简简单单的用平均年化收益率来衡量。</p><p>那定投的意义是什么呢？我认为主要三点，分别是：</p><ul><li>强制储蓄</li><li>降低风险</li><li>帮助投资者完成投资理财入门教育</li></ul><p><strong>强制储蓄</strong></p><p>定投这个概念最初源于美国，后经过不断发展，最终催生了401K退休计划。对应到国内，就是我们的社保（养老金）。我们每个月交的养老金其实就相当于定投，只是决定投资标的的是国家社保基金。</p><p>上班族最大的特点就是本金不多，但是有源源不断的收入作为现金流。故而通过定投这种方式能够实现强制储蓄的效果，同时还能分享部分经济发展的红利。</p><p><em>注：401K计划是美国养老保险的一部分：企业年金部分。按该计划，企业为员工设立专门的401K账户，员工每月从其工资中拿出一定比例的资金存入养老金账户（企业也会投入一定比例），企业向员工提供3到4种不同的证券组合投资计划。员工可任选一种进行投资。员工退休时，可以选择一次性领取、分期领取和转为存款等方式使用。</em></p><p><strong>降低风险</strong></p><p>虽然定投是因为没有多少本金而选择的无奈之举，但是这也避免了集中投资下风险过大的问题。</p><p>从一个较长的时间跨度来看，只要坚持定投，哪怕开始投资的时候是牛市顶点，也能通过后续的投入不断摊低成本，从而提高盈利的概率。</p><p><strong>帮助投资者完成投资理财入门教育</strong></p><p>证券市场不是取款机，股市七亏二平一赚也不是什么调侃，能盈利的始终是少数。很多投资者在没有完成基本的理论学习和实践之前，就拿着多年积蓄，一股脑的冲进去，最终亏了个精光。</p><p>定投是定期定额投入，即使出现亏损，一是亏不了多少，二是不会影响日常生活，反而能让投资者静下心来研究基本理论，找到适合自己的策略，同时养成良好的投资心态。</p><p>从以上这三点来看，尽管定投并没有许多自媒体吹嘘的那么强，但确实是普通投资者尤其是上班族入门投资的比较好的一种方式。</p><h2 id="我有一个想法"><a href="#我有一个想法" class="headerlink" title="我有一个想法"></a>我有一个想法</h2><p>说点其它的。</p><p>看过这个系列第一篇 <a href="https://tjjsjwhj.me/2020/07/18/invest-pratice-0/">《财务自由实证#0——自由能实现吗？》</a> 的读者们都知道，我对这个实证计划的预期年化收益率是15%。这是一个相对乐观但还算合理的目标。</p><p>现阶段我实现这个目标的方式是跟投知名的组合，虽然我个人比较喜欢这种方式，但是这种方式也有两个缺点：</p><p><strong>1. 组合的生命周期无法保证。</strong></p><p>组合的存在与否很大程度上由主理人主观决定，跟投者只能被动接受。我信任长赢计划，然而谁能保证它还有下一轮呢？</p><p><strong>2. 策略不透明。</strong></p><p>虽然每个组合都有其投资策略的介绍，但是策略的细节仍然是不透明的；而且具体到每一次的操作上，我们也无法判断主理人是否完美的执行了该策略。</p><p>本着“自主可控”的原则，打算捡起去年的想法，开发一些简单但有效的投资策略，构建属于自己的投资组合，在实践中加快自己投资体系的建立。</p><p>由于深知“闭门造车”的弊端，所以借这篇文章推广一下：</p><p>如果你也对构建自己的投资策略也感兴趣，欢迎私信（公众号回复【搞事情】），一起搞事情！</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>定投</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 并发基石之 channel（一）</title>
    <link href="/2021/05/02/go-channel-1/"/>
    <url>/2021/05/02/go-channel-1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Go 并发系列是根据我对晁岳攀老师的《Go 并发编程实战课》的吸收和理解整理而成，如有偏差，欢迎指正~</p></blockquote><p>作为 Go 的核心数据结构以及 goroutine 之间的通信方式，channel 是支撑 Go 语言高性能并发编程模型的重要数据结构。</p><p>学习 Go，channel 是无论如何都无法绕过的特性。因此本篇就和大家一起看下 channel 的由来、基本用法以及常犯的一些错误。</p><h2 id="1-channel-的发展"><a href="#1-channel-的发展" class="headerlink" title="1. channel 的发展"></a>1. channel 的发展</h2><p>要了解 channel 的设计思想，就得追溯到 CSP 理论。</p><p>CSP 是 Communication Sequential Process 的简称，最早由计算机科学家 Tony Hoare 在 1978 年发表的同名论文提出。最开始的 CSP 其实是一种并发编程语言，之后经过一系列发展和演化，才变成了现在的 CSP 理论。</p><p>作者认为，并发场景中，<strong>输入</strong>和<strong>输出</strong>是被忽略的两个原语。在最初的 CSP 中，Hoare 创造了 <strong>!</strong> 和 <strong>?</strong> 命令，分别表示输入和输出，并展示了如何用通信的方式来解决并发问题！</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/16/16198628955968.jpg" alt="-w1047"></p><p>在上图的最后一个例子中，描述了从 west 进程不断读取字符到变量 c 并发送给 east 进程的通信过程。</p><p>此外，CSP 中还使用了守护命令 **—&gt;**，命令左边的语句是 false 或者退出，那么命令的右边就不会执行。</p><p>这和 channel 的用法是何其的相似！</p><p>CSP 描述了一种多个任务之间通过通信来进行信息交互的处理问题的方案，这也构成了 Go 并发哲学的基础。</p><h2 id="2-channel-和-sync"><a href="#2-channel-和-sync" class="headerlink" title="2. channel 和 sync"></a>2. channel 和 sync</h2><p>前面一系列的文章介绍了 Go sync 包下的并发原语，如 Mutex，WaitGroup，Once，Cond 等。在 Go 中，它们和 channel 其实是竞争关系。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/16/channel-hesync.jpg" alt="channel和sync"></p><blockquote><p>Don’t communicate by sharing memory, share memory by communicating.</p></blockquote><p>学习 Go 的过程中，总是时不时的看到这句话。直白的翻译就是：不要通过共享内存来通信，而要通过通信来共享内存。</p><p>sync 和 channel 就分别代表了这两种解决并发问题的方式。</p><p>以最常见的计数器为例，看一下这两种方式分别是如何处理的。</p><h3 id="1-sync-的解决方案"><a href="#1-sync-的解决方案" class="headerlink" title="1) sync 的解决方案"></a>1) sync 的解决方案</h3><p>sync 的解决方式很直观，就是通过 Mutex 来确保同一时刻只有一个 goroutine 在修改数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">//countByShareMemory</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countByShareMemory</span><span class="hljs-params">()</span></span> &#123;<br>count := <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> w sync.WaitGroup <span class="hljs-comment">// 用于确保100个 goroutine 都执行完毕</span><br><span class="hljs-keyword">var</span> m sync.Mutex<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>w.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>m.Lock()<br><span class="hljs-keyword">defer</span> w.Done()<br><span class="hljs-keyword">defer</span> m.Unlock()<br>count++<br>&#125;()<br>&#125;<br>w.Wait()<br>fmt.Println(count)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-channel-的解决方案"><a href="#2-channel-的解决方案" class="headerlink" title="2) channel 的解决方案"></a>2) channel 的解决方案</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// countByCommunicating</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countByCommunicating</span><span class="hljs-params">()</span></span> &#123;<br>w := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">100</span>) <span class="hljs-comment">// 用于确保100个 goroutine 都执行完毕</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">1</span>)<br>ch &lt;- <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> count := &lt;-ch:<br>ch &lt;- count + <span class="hljs-number">1</span><br>&#125;<br>w &lt;- <span class="hljs-number">0</span><br>&#125;()<br><br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>&lt;-w<br>&#125;<br>fmt.Println(&lt;-ch)<br>&#125;<br></code></pre></td></tr></table></figure><p>并发场景下，需要保证 count++ 操作的原子性，也就是 count 变量独占权的问题。sync.Mutex 的解决方案中，通过<strong>互斥锁</strong>保证同一时刻只有一个 goroutine 对count 拥有所有权；channel 的解决方案中，则是通过管道<strong>转移</strong>对 count 的所有权。</p><h3 id="3-如何选择-sync-和-channel"><a href="#3-如何选择-sync-和-channel" class="headerlink" title="3) 如何选择 sync 和 channel"></a>3) 如何选择 sync 和 channel</h3><p>尽管 Go 的设计者极力推荐使用 CSP 的方式来解决并发问题，但是 CSP 只是解决并发安全问题的其中一种途径，在某些场景，还是要具体问题具体分析。</p><p>该课程中给出的建议如下：</p><ul><li>共享资源的并发访问使用传统并发原语；</li><li>复杂的任务编排和消息传递使用 Channel；</li><li>消息通知机制使用 Channel，除非只想 signal 一个 goroutine，才使用 Cond；</li><li>简单等待所有任务的完成用 WaitGroup，也有 Channel 的推崇者用 Channel，都可以；</li><li>需要和 Select 语句结合，使用 Channel；</li><li>需要和超时配合时，使用 Channel 和 Context。</li></ul><h2 id="3-channel-的基本用法"><a href="#3-channel-的基本用法" class="headerlink" title="3. channel 的基本用法"></a>3. channel 的基本用法</h2><p>你既可以往 channel 中发送数据，也可以从 channel 中接收数据，所以，channel 的类型有如下三种：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">chan</span>    <span class="hljs-comment">// 既可以发送数据，又可以接收数据的 channel</span><br><span class="hljs-keyword">chan</span>&lt;-  <span class="hljs-comment">// 只能接收数据的 channel</span><br>&lt;-<span class="hljs-keyword">chan</span>  <span class="hljs-comment">// 只能发送数据的 channel</span><br></code></pre></td></tr></table></figure><p>channel 是管道，因此一个传输具体类型数据的 channel 声明方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>      <span class="hljs-comment">// 既可以往 ch 中写，也可以从 ch 中读 string 类型数据</span><br><span class="hljs-keyword">var</span> ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">struct</span>&#123;&#125;  <span class="hljs-comment">// 只能往 ch 中发送 struct&#123;&#125; 类型数据</span><br><span class="hljs-keyword">var</span> ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>       <span class="hljs-comment">// 只能从 ch 中读取 int 数据</span><br></code></pre></td></tr></table></figure><p>channel 的初始化和 slice 类似，都是使用关键字 make，未初始化的 channel 零值是 nil。具体的声明方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>其中 5 是 channel 的容量。也可以不指定 channel 的容量，即容量为 0，这样的 channel 一般叫做 unbuffered channel。</p><h3 id="1-发送数据"><a href="#1-发送数据" class="headerlink" title="1) 发送数据"></a>1) 发送数据</h3><p>往 channel 中发送数据使用 “ch&lt;-“，示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Go">ch &lt;- <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>这里的 ch 的类型是 <code>chan int</code> 或者 <code>chan&lt;- int</code>。</p><h3 id="2-接收数据"><a href="#2-接收数据" class="headerlink" title="2) 接收数据"></a>2) 接收数据</h3><p>从 channel 中接收数据使用 “&lt;-ch”，示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go">x := &lt;-ch  <span class="hljs-comment">// 把 ch 中接收到的一条数据赋值给 x</span><br>foo(&lt;-ch) <span class="hljs-comment">// 把 ch 中接收到的一条数据作为函数 foo 的参数</span><br>&lt;-ch      <span class="hljs-comment">// 丢弃一条从 ch 中接收到的数据</span><br></code></pre></td></tr></table></figure><p>从 channel 中接收数据的时候，还可以接收两个值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Go">x, ok := &lt;-ch<br></code></pre></td></tr></table></figure><p>ok 是一个 bool 值，表示是否成功的从 channel 中接收到了数据。如果 ok 是 false，ch 已经被 close，且 ch 中没有缓存数据，那么 x 就是零值。所以，如果 x 是零值，有可能是接收到了零值，也有可能是空的且被 close 的 channel 产生的零值。</p><h3 id="3-其它操作"><a href="#3-其它操作" class="headerlink" title="3) 其它操作"></a>3) 其它操作</h3><p>Go 的内建函数 close、cap、len 都可以操作 channel。close 可以关闭 channel，关闭之后的 channel 无法接收数据；cap 返回 channel 的容量；len 返回 channel 的长度。</p><p>发送和接收数据还可以作为 select 语句的 case clause，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> ch &lt;- i:<br>        <span class="hljs-keyword">case</span> v := &lt;-ch:<br>            fmt.Println(v)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>channel 还可以用于 for-range 语句中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123;<br>    fmt.Println(v)<br>&#125;<br></code></pre></td></tr></table></figure><p>或者是忽略读取的值，只是清空 channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> ch &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里，channel 的基本用法就介绍完了，下面说几种使用 channel 过程中常见的错误。</p><h2 id="4-使用-channel-常见的错误"><a href="#4-使用-channel-常见的错误" class="headerlink" title="4. 使用 channel 常见的错误"></a>4. 使用 channel 常见的错误</h2><p>使用 channel 最常见的错误就是 panic 和 goroutine 泄露。</p><h3 id="1-panic-错误"><a href="#1-panic-错误" class="headerlink" title="1) panic 错误"></a>1) panic 错误</h3><p>常见的会导致 panic 的三种场景如下：</p><ul><li>close 为 nil 的 channel</li><li>send 已经 close 的 channel</li><li>recv 已经 close 的 channel</li></ul><h3 id="2-goroutine-泄露"><a href="#2-goroutine-泄露" class="headerlink" title="2) goroutine 泄露"></a>2) goroutine 泄露</h3><p>这里的泄露指的是 channel 阻塞导致 goroutine 一直无法退出的情况。下面是课程中的一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(timeout time.Duration)</span> <span class="hljs-title">bool</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 模拟处理耗时的业务</span><br>        time.Sleep((timeout + time.Second))<br>        ch &lt;- <span class="hljs-literal">true</span> <span class="hljs-comment">// block</span><br>        fmt.Println(<span class="hljs-string">&quot;exit goroutine&quot;</span>)<br>    &#125;()<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> result := &lt;-ch:<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">case</span> &lt;-time.After(timeout):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该示例中，假设业务处理的时间大于超时时间，故 select 语句先接收超时的信号，返回 false，这导致第 7 行一直阻塞，goroutine 无法退出，进而造成泄露。</p><p>出现这种情况的原因是第二行初始化的 ch 是一个 unbuffered channel，向 unbuffered channel 发送数据的时候，由于容量为 0，必须同时存在接收方接收数据，发送方才能将数据发送出去，否则只能阻塞。</p><p>改进的方式也很简单，ch 初始化的时候，指定容量为 1 就行。</p><h2 id="5-结尾"><a href="#5-结尾" class="headerlink" title="5. 结尾"></a>5. 结尾</h2><p>这一篇，简单的介绍了 channel 的由来以及它的一些基本用法。CSP 理论那其实没怎么讲清楚，只是搬运了《Concurrency in Go》关于 CSP 的一些介绍，短期内也不打算深究，能明白大概意思就行。</p><p>下一篇，尝试写一下 channel 源码解析。</p><p>大家五一假期快乐~~</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>channel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次学习 orDone 模式爬坑经历</title>
    <link href="/2021/04/25/go-or-done/"/>
    <url>/2021/04/25/go-or-done/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Go 并发系列是根据我对晁岳攀老师的《Go 并发编程实战课》的吸收和理解整理而成，如有偏差，欢迎指正~</p></blockquote><p>看了下上次 Go 技术学习的文章 《Go 并发之原子操作 atomic》发布时间: 3月27，一个月之前。再想一想最初立的 flag：每周一篇 Go 技术学习的文章。霍，脸真疼！</p><p>最近在看 channel 。作为 Go 核心的数据结构和 goroutine 之间的通信方式，channel 是支撑 Go 语言高性能并发编程模型的重要数据结构。</p><p>今天就来聊一聊 channel 实现的 Go 的并发模式 orDone 以及我在学习这个模式中不断跳坑出坑的经历。</p><h2 id="任务编排之-orDone-模式"><a href="#任务编排之-orDone-模式" class="headerlink" title="任务编排之 orDone 模式"></a>任务编排之 orDone 模式</h2><p>先介绍一下 orDone 模式。</p><p>orDone 模式是信号通知模式中应用比较广泛的一种模式。</p><p>什么是信号通知模式呢？信号通知模式实现了某个任务执行完成后的通知机制。在实现的时候，通常使用 channel strcut{} 类型，如果任务完成就 close 这个 channel，其它 receiver 就会收到这个信号。</p><p>orDone 模式是说我们有一个任务可以发送给 n 个处理方来执行，只要有一个处理方完成，就返回任务完成的信号。</p><p>如果 n 已知，实现方式很简单，用 select-case 语句就行。但是有些时候，你并不知道有多少个处理者，有可能是10个，也有可能是100个，所以没办法直接使用 select-case 。</p><p>在 《Go 并发编程实战》的 channel 相关的章节中，orDone 模式的代码实现如下（这段代码其实是有问题的，后面会说）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">or</span><span class="hljs-params">(channels ...&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>    <span class="hljs-comment">// 特殊情况，只有零个或者1个chan</span><br>    <span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(channels) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> channels[<span class="hljs-number">0</span>]<br>    &#125;<br><br>    orDone := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(orDone)<br><br>        <span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(channels) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">// 2个也是一种特殊情况</span><br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">0</span>]:<br>            <span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">1</span>]:<br>            &#125;<br>        <span class="hljs-keyword">default</span>: <span class="hljs-comment">//超过两个，二分法递归处理</span><br>            m := <span class="hljs-built_in">len</span>(channels) / <span class="hljs-number">2</span><br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-or(channels[:m]...):<br>            <span class="hljs-keyword">case</span> &lt;-or(channels[m:]...):<br>            &#125;<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">return</span> orDone<br>&#125;<br></code></pre></td></tr></table></figure><p>该示例代码中，采取二分递归的方式来监听任务的完成信号。</p><p>附带测试代码如下 ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sig</span><span class="hljs-params">(after time.Duration)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(c)<br>        time.Sleep(after)<br>    &#125;()<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    start := time.Now()<br><br>    &lt;-or(<br>        sig(<span class="hljs-number">20</span>*time.Second),<br>        sig(<span class="hljs-number">10</span>*time.Second),<br>        sig(<span class="hljs-number">30</span>*time.Second),<br>        sig(<span class="hljs-number">40</span>*time.Second),<br>        sig(<span class="hljs-number">50</span>*time.Second),<br>        sig(<span class="hljs-number">01</span>*time.Minute),<br>    )<br><br>    fmt.Printf(<span class="hljs-string">&quot;done after %v&quot;</span>, time.Since(start))<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果完美符合预期，10s 之后，printf 语句成功打印。</p><h2 id="问题1：goroutine-泄露问题"><a href="#问题1：goroutine-泄露问题" class="headerlink" title="问题1：goroutine 泄露问题"></a>问题1：goroutine 泄露问题</h2><p>上面的代码乍看之下很合理，但是仔细想一想，却有两个问题：</p><ol><li>变量 orDone 在函数中的作用到底是什么？ </li><li>case 2 所说的特殊情况到底是什么？能否在 case 2 处就递归？</li></ol><p>带着这两个问题，一顿搜索，搜到了《Concurrency in Go》这本书。在这本书中，orDone 模式的代码示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">or</span><span class="hljs-params">(channels ...&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123; <span class="hljs-comment">//1</span><br><br><span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(channels) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">//2</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">//3</span><br><span class="hljs-keyword">return</span> channels[<span class="hljs-number">0</span>]<br>&#125;<br><br>orDone := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//4</span><br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(orDone)<br><br><span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(channels) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">//5</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">0</span>]:<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">1</span>]:<br>&#125;<br><span class="hljs-keyword">default</span>: <span class="hljs-comment">//6</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">0</span>]:<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">1</span>]:<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">2</span>]:<br><span class="hljs-keyword">case</span> &lt;-or(<span class="hljs-built_in">append</span>(channels[<span class="hljs-number">3</span>:], orDone)...): <span class="hljs-comment">//6</span><br>&#125;<br>&#125;<br>&#125;()<br><span class="hljs-keyword">return</span> orDone<br>&#125;<br></code></pre></td></tr></table></figure><p>对比发现，这两种写法最主要的一个区别就是变量 orDone 有没有作为参数传递给子函数中。</p><p>在 or 函数执行结束前，orDone 会被 close，递归子函数的 case 分支接收到这个信号后，在立即退出的同时会将新 orDone 的 close 信号传递给它的递归子函数。也就是说，变量 orDone 的作用是用来通知其它协程退出。</p><p>在《Concurrency in Go》一书中，有如下解释：</p><blockquote><p>Here we recursively create an or-channel from all the channels in our slice after the third index, and then select from this. This recurrence relation will destructure the rest of the slice into or-channels to form a tree from which the first sig‐ nal will return. <strong>We also pass in the orDone channel so that when goroutines up the tree exit, goroutines down the tree also exit</strong>.</p></blockquote><p>到这里，基本可以确认，晁老师的二分递归版本的代码是有问题的。这个版本没有传递 orDone 信号，通知其它协程退出，<strong>会造成 goroutine 泄露问题</strong>！</p><p>谨慎起见，我还是大胆的联系了晁老师，进行确认。</p><p><em>注：为了方便起见，下文中用二分递归版代指晁老师的代码示例，用直接递归版代指《Concurrency in Go》中的示例。</em></p><h2 id="问题2：slice-切片问题"><a href="#问题2：slice-切片问题" class="headerlink" title="问题2：slice 切片问题"></a>问题2：slice 切片问题</h2><p>在和晁老师确认的过程中，我先根据自己的理解，对他的代码进行了一番修改，改动点（default 分支）如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">default</span>: <span class="hljs-comment">//超过两个，二分法递归处理</span><br>    m := <span class="hljs-built_in">len</span>(channels) / <span class="hljs-number">2</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-or(<span class="hljs-built_in">append</span>(channels[:m], orDone)...):<br>    <span class="hljs-keyword">case</span> &lt;-or(<span class="hljs-built_in">append</span>(channels[m:], orDone)...):<br>    &#125;<br></code></pre></td></tr></table></figure><p>用上文的测试代码测试发现，程序在30s末的时候，才执行了 print 语句，不符合预期！</p><p>这个时候，晁老师回复了，先是夸了一通我看的仔细，然后确认这个地方确实遗漏了 orDone 信号的传递，并给出了修改版代码，改动如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">default</span>:<br>    m := <span class="hljs-built_in">len</span>(channels) / <span class="hljs-number">2</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-or(<span class="hljs-built_in">append</span>(channels[:m:m], orDone)...): <span class="hljs-comment">// must append orDone to avoid leak!!!!</span><br>    <span class="hljs-keyword">case</span> &lt;-or(<span class="hljs-built_in">append</span>(channels[m:], orDone)...):<br>    &#125;<br></code></pre></td></tr></table></figure><p>我一看，这不和我改的一样嘛。再一想，晁老师不可能未经测试就给出代码，于是我跑了一遍测试代码，不出所料，这个结果是正确的！</p><p>问题出在哪呢？</p><p>逐字对比后，发现这两份代码在 slice 切片上有细微差别。晁老师版本指定了切片容量 m。</p><p>经过一番查阅，发现 slice 切片的时候，如果不指定容量，直接 append，仍然会对底层的 slice 产生影响。这里的影响就是 channels[m:] 的第一个元素 sig(10*time.Second) 被 orDone 覆盖了。</p><p><strong>注：slice 切片的知识点其实很基础，各位读者稍微一搜就知道，我就不详细介绍了，不要像我一样犯这个错误😂。</strong></p><h2 id="问题3：二分递归无法退出问题"><a href="#问题3：二分递归无法退出问题" class="headerlink" title="问题3：二分递归无法退出问题"></a>问题3：二分递归无法退出问题</h2><p>到这里，问题已经得到了解决，接下来的剧情本应是和大佬客气几句然后愉快的结束讨论，继续接下来的学习。</p><p>但是！转折来了！</p><p>在执行二分递归版代码的过程中，电脑的风扇总是发出“呼呼”的噪音，而执行直接递归版代码的时候，就没有这个问题。</p><p>似乎有哪里不对🤔？</p><p>带着这个疑问，我写了下面的测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>start := time.Now()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>time.Sleep(time.Second)<br>fmt.Println(<span class="hljs-string">&quot;任务进行中，当前协程数:&quot;</span>, runtime.NumGoroutine())<br>&#125;()<br><span class="hljs-comment">//测试 orDone 模式</span><br>&lt;-or(<br>sig(<span class="hljs-number">20</span>*time.Second),<br>sig(<span class="hljs-number">10</span>*time.Second),<br>sig(<span class="hljs-number">30</span>*time.Second),<br>sig(<span class="hljs-number">40</span>*time.Second),<br>sig(<span class="hljs-number">50</span>*time.Second),<br>sig(<span class="hljs-number">01</span>*time.Minute),<br>)<br>fmt.Printf(<span class="hljs-string">&quot;done after %v\n&quot;</span>, time.Since(start))<br>fmt.Println(<span class="hljs-string">&quot;任务结束后，当前协程数:&quot;</span>, runtime.NumGoroutine())<br>&#125;<br></code></pre></td></tr></table></figure><p><em>注：sig 函数的实现和原来一样。</em></p><p>二分递归版代码的测试结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">任务进行中，当前协程数: 233059<br><span class="hljs-keyword">done</span> after 10.011710905s<br>任务结束后，当前协程数: 1248213<br></code></pre></td></tr></table></figure><p>直接递归版代码测试结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">任务进行中，当前协程数: 11<br><span class="hljs-keyword">done</span> after 10.002369341s<br>任务结束后，当前协程数: 6<br></code></pre></td></tr></table></figure><p>对比之下，问题很明显：二分递归版本创建的协程数巨多！且任务执行结束后，协程数翻了6倍！</p><p>根据这个结果，我们大胆的猜测一下：二分递归的代码陷入了无穷递归。</p><p>在纸上画一下测试 case 的递归树，发现 len(channels) == 3 的情况下，左右子树 len(channels) 分别是 1 和 2，但是加上退出信号 orDone 之后，变成了2和3。这里长度为 3 的这个分支发生了无穷递归。</p><p>这也解答了<strong>问题1</strong>最开始的第2个疑问：case2 为什么是特殊情况？能不能省掉，直接递归？</p><p>答案是 case len(channels)==2 如果直接递归，会发生无穷递归，所以不能省掉。并且 case len(channels)==3 也应该作为特殊情况处理，避免无穷递归。</p><p>所以二分递归版正确的写法是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(orDone)<br><br><span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(channels) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">0</span>]:<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">1</span>]:<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">0</span>]:<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">1</span>]:<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">2</span>]:<br>&#125;<br><span class="hljs-keyword">default</span>:<br>m := <span class="hljs-built_in">len</span>(channels) / <span class="hljs-number">2</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-or(<span class="hljs-built_in">append</span>(channels[:m:m], orDone)...): <span class="hljs-comment">// must append orDone to avoid leak!!!!</span><br><span class="hljs-keyword">case</span> &lt;-or(<span class="hljs-built_in">append</span>(channels[m:], orDone)...):<br>&#125;<br>&#125;<br>&#125;()<br></code></pre></td></tr></table></figure><p>再次和晁老师沟通后，得到了肯定的答复！</p><h2 id="问题4：二分递归的效率问题"><a href="#问题4：二分递归的效率问题" class="headerlink" title="问题4：二分递归的效率问题"></a>问题4：二分递归的效率问题</h2><p>如果你不怕麻烦，在跑一遍二分递归的最终版代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">任务进行中，当前协程数: 15<br><span class="hljs-keyword">done</span> after 10.002655818s<br>任务结束后，当前协程数: 6<br></code></pre></td></tr></table></figure><p>结果没有异常，任务结束后，剩余协程数是6，说明任务结束信号正常传递，递归出来的协程都正常退出了。但是任务进行中的协程数比直接递归多4个！</p><p>难道二分递归的效率反而更低些？</p><p>随便测试几组 case 就能发现，随着 len(channels) 的上升，二分递归版衍生出来的协程数与直接递归衍生出来的协程数的差值也在上升。</p><p>这是因为二分递归版每递归一次，len(channels) 就会加2，而直接递归版 len(channels) 只会加1。而且为了减少递归衍生出的协程数，直接递归版把 case 2 单独拎了出来进行处理​。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>本文记录了学习 channel 的应用场景 orDone 模式中一次又一次的跳坑出坑的经历，虽然痛苦，却苦尽甘来。</p><p>文末留个开放性问题吧，二分递归和直接递归衍生出来的协程数似乎能用数学表达式写出来，你知道怎么写吗？</p><p>我反正是干不动，躺下了。</p><p>下期再见。</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p><p><strong>都看到这里了，不如加个关注呗~~</strong></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>channel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#6——你的预期年化收益率是多少？</title>
    <link href="/2021/03/30/invest-pratice-6/"/>
    <url>/2021/03/30/invest-pratice-6/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://tjjsjwhj.me/2020/07/18/invest-pratice-0/">财务自由实证#0——自由能实现吗？</a>。</p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更“美好”的事物上。</p><h2 id="实证进展"><a href="#实证进展" class="headerlink" title="实证进展"></a>实证进展</h2><p>本月进展如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/16170307690332.jpg"></p><p>当前进展 2.26%，相比上个月，增加 0%。较真的话，其实是有增加的，增加了不到400，聊胜于无。毛估了下，从春节到现在，回撤大概10%。</p><p>不过这才是真实的市场，不是吗？</p><h2 id="春节之后"><a href="#春节之后" class="headerlink" title="春节之后"></a>春节之后</h2><p>随着A股市场近一个多月的断崖式下跌，公募基金募集日光的现象暂时偃旗息鼓，多只基金的募集都发出了延期的公告。</p><p>由于有些基金跌的太厉害，还出现了基金经理回怼投资人的情况：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/16169274119020.jpg" alt="-w717"></p><p>这一个多月的时间里面，相关公司的基本面没有发生重大变化，基金经理的投资理念和投资风格也没有发生变化，变的只有我们的心态。</p><p>正好借着这波震荡的行情，来聊一聊股票的预期年化收益率应该是多少这个话题。</p><h2 id="你的预期年化收益率是多少？"><a href="#你的预期年化收益率是多少？" class="headerlink" title="你的预期年化收益率是多少？"></a>你的预期年化收益率是多少？</h2><p>聊这个话题之前，先弄个投票，看下大家的年化收益率的预期都是多少。</p><ul><li>没有预期收益率</li><li>5%以下</li><li>10%左右</li><li>15%左右</li><li>20%以上</li><li>50%以上</li></ul><p>为什么要问这个问题，是因为平时偶尔的聊天中，发现好多人对预期收益率这件事情没有概念，你问他的预期年化收益率是多少，他也说不上来，就觉得越高越好。</p><p>预期年化收益率其实就是投资目标。没有目标的投资，投资行为很容易变形。而且，有了合理的预期之后，我们面对暴涨暴跌，也会从容许多，因为那超出预期的，必然会回落；而那低于预期的，必然会反弹。</p><p>那么，重点来了，合理的预期年化收益率是多少？我们应该如何估计呢？</p><h2 id="股票合理的预期收益率应该是多少？"><a href="#股票合理的预期收益率应该是多少？" class="headerlink" title="股票合理的预期收益率应该是多少？"></a>股票合理的预期收益率应该是多少？</h2><p>在之前的文章《为什么要坚持长期投资？》中贴过一张图：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/16169417733213.jpg"></p><p>这张图是1802年到2008年这207年间，不同的统计周期下，年回报率的均值和标准差的对应情况。</p><p>以一年为统计周期，207年的平均收益率是6.5%，标准差是18.3%，也就是说，大约2/3的时间里，年回报率在-11.3%~25.3% 之间波动。实际上，一年的回报率最高能到66.6%，最低只有-38.6%。</p><p>统计周期拉长后，年回报率的标准差迅速减小，但是均值却没有什么变化，这说明，无论短期收益率波动如何剧烈，长期下来，收益率都会回归到某个值附近，这才是我们更有可能获得的真实收益率。</p><p><em>注：上图中的回报率是指剔除通货膨胀率之后收益率，加上通货膨胀率之后的名义收益率是10%左右。</em></p><p>很多人可能会说，美股的资本市场历史较长，制度比较完善，不能直接在A股上套用这个统计规律。</p><p>确实是这样。</p><p>之前看有知有行的文章《股票的预期收益率应该是多少？》，里面给出了一个自上而下的推导过程。</p><p>这个推导过程的依据是：<strong>GDP的增长率 &lt; 全体上市公司的增长率 &lt; 优质上市公司的增长率。</strong></p><p>GDP我们都知道，国民生产总值，也可以理解成所有大大小小的企业的生产总值。因此GDP的增速就是全部企业增长速度的均值。在过去的几十年里，中国的GDP经历了一个高速增长的阶段，但是随着经济体量的增大、人口红利的减少以及科技水平的制约，新常态下的GDP的增速肯定不可能有以前那么高，但是5%~6%的增长水平还是可以预期的。</p><p>当我们投资股票或者股票基金的时候，实际上投资的是这个国家规模比较大、盈利能力比较强的一些企业。毕竟无论是主板还是创业板、科创板块上市，都是需要满足一定的筛选条件的。基于这个事实，全体上市公司的增长率比GDP的增长率高3到4个百分点是比较合理的，因此如果我们投资全体上市公司，8%~10%的长期年化收益率是可以预期的。</p><p>尽管全体上市公司代表着国内比较优秀的一批公司，但是这一堆公司里面，也有许多平庸的公司，如果我们能从中挑选出一批更加优质的公司，我们的预期收益率还能再提高2到3个百分点。基于这个事实，10%~12%的长期年化收益率也是可以预期的。</p><p>除此之外，A股还有个所有人都体会深刻的特性：巨大的波动性。从人性的角度看，绝大部分人都是厌恶波动，喜欢确定性。但是投资的角度看，波动如果利用的好，是可以提升收益率的。</p><p>有知有行做过一个测算，如果在市场情绪较低的情况下买入，持有三年平均累计收益率可以达到130%，相反，如果是在高估的情况下买入，同样持有三年，平均亏损幅度高达46%。因此如果依据估值进行低买高卖，就有可能把长期收益率拉高到12%~15%的水平。</p><p>所以，对于普通投资者而言，12%~15%是一个比较合理且偏乐观的预期年化收益率。</p><h2 id="我有一个想法"><a href="#我有一个想法" class="headerlink" title="我有一个想法"></a>我有一个想法</h2><p>说点其它的。</p><p>看过这个系列第一篇 <a href="https://tjjsjwhj.me/2020/07/18/invest-pratice-0/">《财务自由实证#0——自由能实现吗？》</a> 的读者们都知道，我对这个实证计划的预期年化收益率是15%。这是一个相对乐观但还算合理的目标。</p><p>现阶段我实现这个目标的方式是跟投知名的组合，虽然我个人比较喜欢这种方式，但是这种方式也有两个缺点：</p><ol><li>组合的生命周期无法保证。</li></ol><p>组合的存在与否很大程度上由主理人主观决定，跟投者只能被动接受。我信任长赢计划，然而谁能保证它还有下一轮呢？</p><ol start="2"><li>策略不透明。</li></ol><p>虽然每个组合都有其投资策略的介绍，但是策略的细节仍然是不透明的；而且具体到每一次的操作上，我们也无法判断主理人是否完美的执行了该策略。</p><p>本着“自主可控”的原则，打算捡起去年的想法，开发一些简单但有效的投资策略，构建属于自己的投资组合，在实践中加快自己投资体系的建立。</p><p>由于深知“闭门造车”的弊端，所以借这篇文章推广一下：</p><p>如果你也对构建自己的投资策略也感兴趣，欢迎私信，一起搞事情！</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#5——我迁移了投资记账软件</title>
    <link href="/2021/02/27/invest-pratice-5/"/>
    <url>/2021/02/27/invest-pratice-5/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://tjjsjwhj.me/2020/07/18/invest-pratice-0/">财务自由实证#0</a>。</p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更“美好”的事物上。</p><h2 id="拖更太久了"><a href="#拖更太久了" class="headerlink" title="拖更太久了"></a>拖更太久了</h2><p>看了下上次写的那理财相关的文章，2月9号，到今天已经过去了大半个月。</p><p>反思了下，主要有两个原因：</p><p>一是春节。从初二开始，天天串亲戚，要么中午，要么下午，要么全天，天天串，天天吃，完全没有学习时间写文章。。</p><p>说好的疫情期间不串门呢？</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/wo-neng-you-shen-me-ban-fa.gif" alt="我能有什么办法"></p><p>二是投资理财部分没想好要怎么展开。这一部分能写的点太多，却又都不深刻，无法形成系统的文章。</p><p>不过这个问题最近已经想的差不多了，所以接下来奋力码字~</p><h2 id="实证进展"><a href="#实证进展" class="headerlink" title="实证进展"></a>实证进展</h2><p>不再多说废话，上图：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/16143531861520.jpg"></p><p>本月进展2.26%，相比上个月增加0.1%，缓慢而顽强的朝着目标前进。。。</p><p>特殊操作，除了之前跟投的组合外，新增两个组合的跟投：积极进取和全球精选。</p><p>感觉每个月的跟投额度有渐渐不受控制的倾向😂，不过积极进取和全球精选侧重资产配置，定期会有平衡操作，所有后续即使不跟投，问题也不大。</p><p>这个星期，出了个新词，不少小伙伴应该都看到了：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/wechatimg8649.jpeg" alt="WechatIMG8649"></p><p>过于真实。</p><p>看了下明星基金【易方达蓝筹精选】最近一段时间的走势：</p><p>年前净值创新高，过年之后一直在跌，一共跌了15%，堪比小型股灾。</p><p>没忍住去看了下支付宝【易方达蓝筹精选】的评论区，不少基民已经开始质疑张坤会不会炒股，为啥不减仓，，哈哈哈~</p><p>​下回再看支付宝的基金讨论区，算我输。</p><p>多说一句，买基金这事，既然选择了信任，不妨先坚持个几年试试，反正是闲钱，没必要着急。</p><h2 id="为什么要迁移记账软件？"><a href="#为什么要迁移记账软件？" class="headerlink" title="为什么要迁移记账软件？"></a>为什么要迁移记账软件？</h2><p>有看过之前实证记录的小伙伴，细心一点会发现，投资记账的软件换掉了。</p><p>是的，从这个月开始，所有的投资记录都从【且慢小账本】迁移到【有行记账】了。</p><p>为什么要迁移呢？</p><p>最主要的原因是【且慢小账本】已经停止维护，说不定什么时候就不能用了。其次就是相比与【且慢小账本】，【有行记账】还是一个有温度的工具。</p><p>【且慢小账本】原本是孟岩在且慢主导的一个记账软件，但是由于产品定位不清晰，过于工具化，有些用户除了它来记账，还会用它来记录彩票的收益率，或者是零花钱的流水，并且使用起来毫不违和。</p><p>然而这种使用方式和产品的初衷完全背离。【有行记账】的产品认为：</p><blockquote><p>记账的目的是为了投资，投资的目的是为了挣钱，挣钱的目的是为了生活。</p></blockquote><p>【有行记账】就是希望成为体现这种理念、关注投资本质，能帮大家走到投资大道上去的记账工具。</p><p>更具体的特征，大家不妨自己下载来体验一下~~</p><h2 id="迁移过程中的意外收获"><a href="#迁移过程中的意外收获" class="headerlink" title="迁移过程中的意外收获"></a>迁移过程中的意外收获</h2><p>由于【且慢小账本】不支持数据导出，而且我在它上面记录的数据也不全面，就想着干脆将这两年全部的投资记录全部都翻出来，重新都记录一遍。</p><p>为了防止之后再更换投资账本，以及更方便的进行数据导入导出分析，我使用了如下的步骤来进行数据迁移：</p><ol><li>在记账软件 MoneyWiz 上新建一个投资账户，记录完整的投入和转出。</li><li>将历史投资记录按月记录到有行账本中。</li><li>根据且慢小账本的记录，更新有行账本上部分历史时间节点的总资产。</li></ol><p>迁移的过程中，正好利用 MoneyWiz 的统计功能，把投入数据导出成 Excel，生成了下面这张表格：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/shi-zheng-ji-hua-tou-ru-ji-lu.png" alt="实证计划投入记录"></p><p>图虽然简单，却真实反应了我这两年来的投资历程。</p><p>2019年1月，出于纯粹的跑赢通胀的目的，首次投入【长赢指数计划】。由于当时市场低迷，组合中大部分基金的持仓成本都低于E大，运气好。</p><p>2019年2月到7月的这段时间，偶尔的跟调，但是读了（听了）不少书，算是完成了一个基本入门教育。</p><p>2019年7月之后，由于对基金有了进一步的认识，开始买入一些投资组合，从这之后，每月的净投入上了一个新台阶。</p><p>2020年2月份之后，疫情导致市场大跌，这期间加大了投入的额度。</p><p>2020年9月份之后，逐渐保持了一个稳定的投入额度。</p><p>现在回顾整个过程，比较可惜的就是3月份那次机会，毕竟像疫情这种非系统性的风险引起市场大幅下跌的机会，很难再遇到第二次了。</p><p>不过投资就是这样，你不可能抓住所有的机会，唯一能做的就是不断提升自己，静静的等待下一次的机会。</p><h2 id="再唠叨几句"><a href="#再唠叨几句" class="headerlink" title="再唠叨几句"></a>再唠叨几句</h2><p>春节之后的行情，想必大家都很不爽。我也是，毕竟累计收益的第一个数字直接减了1。</p><p>但是这才是正常情况，不是吗？从一开始我们就知道，市场是剧烈波动的，唯有有效的策略，正确的认知，再加上一个长长的期限，才能有所收获。</p><p>多年之后再回过头来看，这些波动不过就是几朵浪花而已，不值一提。</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么要坚持长期投资？</title>
    <link href="/2021/02/09/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9D%9A%E6%8C%81%E9%95%BF%E6%9C%9F%E6%8A%95%E8%B5%84/"/>
    <url>/2021/02/09/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9D%9A%E6%8C%81%E9%95%BF%E6%9C%9F%E6%8A%95%E8%B5%84/</url>
    
    <content type="html"><![CDATA[<h2 id="基金赚钱-≠-基民赚钱"><a href="#基金赚钱-≠-基民赚钱" class="headerlink" title="基金赚钱 ≠ 基民赚钱"></a>基金赚钱 ≠ 基民赚钱</h2><p>前几天，E大微博放出了一张中欧基金统计的客户收益和基金收益的对比图，十分震撼：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/7d46c32ba4fa44f4921f65242b46853d.png" alt="7D46C32B-A4FA-44F4-921F-65242B46853D"></p><p>图中蓝色柱状图是客户的累计收益，橙色柱状图是基金成立以来的收益。<strong>权益类基金的客户收益仅有基金累计收益的零头</strong>！</p><p>另外，中欧旗下的财务管理平台钱滚滚数据表示，2020年90%的基民实现了正收益，43%的基民平均投资收益超过了10%，但是反过来想就是**近60%的基民收益不到10%**。要知道2020年可是权益基金的大年。</p><p>这说明绝大部分的基金投资者都是短期投资者。</p><h2 id="为什么要坚持长期投资？"><a href="#为什么要坚持长期投资？" class="headerlink" title="为什么要坚持长期投资？"></a>为什么要坚持长期投资？</h2><blockquote><p>我对预测股市的短期波动一无所长，我对未来六个月、未来一年或未来两年内的股票市场的走势一无所知。—— 巴菲特</p></blockquote><p>商品价格受供求关系影响，围绕价值上下波动。而股票是股份公司发行的所有权凭证（股权凭证），股票的价值对应着公司的价值。虽然股票不能算完全意义的商品，但是其价格仍然符合价值规律的表现形式。</p><p>短期来看，公司的价值不可能发生巨大的变化，这个时候股票价格就会受到供求关系的影响。又因为股票不是完全意义的商品，没有使用价值，所以影响供求关系的其实是市场参与者对股票价格未来的期望。期望是一种心里预期，所以巴菲特才说他对未来一两年的股票市场走势一无所知。</p><p>长期来看，公司不断进行创新（技术创新、组织创新、模式创新），不断提高生产力，公司的价值也在不断提高，相应的，股票的价值也不断提高。这才是我们应该去争取获得的利润的来源。</p><h3 id="股票的长期收益"><a href="#股票的长期收益" class="headerlink" title="股票的长期收益"></a>股票的长期收益</h3><p>如果坚持长期投资，能获得多少收益呢？这里引用《共同基金十周年纪念版》中的数据（美股）：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/16128407901664.jpg"></p><p>表格数据补充说明：</p><ol><li>三个阶段：a)1802-1870年，美国从农业经济转为工业经济；b)1871-1925年，美国成为全球重要的经济和政治大国；c) 1926至今，现代股票市场时代。</li><li>1997和2008分别对应《共同基金常识》第一版和十周年纪念版的初版时间。</li><li>阴影部分数据是十周年再版时更新的数据。</li><li>消费者价格指数（CPI）指通货膨胀率。</li><li>90年代美股走强，2008年金融危机，所以1998-2008年间，实际回报率为负值。</li></ol><p>从这张图里能看到，从19世纪到20世纪，通货膨胀率急剧上升（二战后金本位解体），股市的名义回报率也大幅上升，但是实际总回报率（名义回报率减去通货膨胀率）仍然在7%左右。</p><h3 id="波动巨大的年回报率"><a href="#波动巨大的年回报率" class="headerlink" title="波动巨大的年回报率"></a>波动巨大的年回报率</h3><p>虽然股市长期回报率趋于稳定，但绝不能认为股市每年的实际收益率都是7%左右（很多投资者有一个错误的认知，长期回报率7%就是每年7%）。实际上，以一年为单位，股票的收益率存在巨大的波动。</p><p>下图是1802年到2008年期间，股票逐年波动率的情况：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/16128408642617.jpg"></p><p>表格中的数据不少，其实只要看1802-2008年这一行，这207年间，回报率的均值是7%，标准差是18.3%，也就是说，大约2/3的时间里，实际回报率在-11.3%~25.3%之间波动。实际上，这一段时期内，回报率最高能到66.6%，最低只有-38.6%。</p><p>显然，割裂的看每一年的回报率，存在巨大的不确定性。</p><h3 id="不同周期下年回报率的波动范围"><a href="#不同周期下年回报率的波动范围" class="headerlink" title="不同周期下年回报率的波动范围"></a>不同周期下年回报率的波动范围</h3><p>虽然具体到每一年，回报率波动十分剧烈，但是这个波动的剧烈程度，随着时间跨度的增加会迅速下降。</p><p>如下图所示：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/16128410086854.jpg"></p><p>在这张图里面，横坐标标识持有股票的时间，以年为单位；纵坐标显示的是年化回报率；而柱状图的高度代表了在相应的年限里，最高与最低的回报率范围。需要注意的是，这个波动范围是是根据标准差计算出来的一个范围，实际波动高于这个估计。</p><p>从图里我们可以看到，随着持有年限的增加，标准差迅速从18.3%下降到1.0%，前期下降远远快于后期下降。这说明我们持有的时间越长，获得一个稳定收益的概率越高。</p><h2 id="长期投资的风险"><a href="#长期投资的风险" class="headerlink" title="长期投资的风险"></a>长期投资的风险</h2><p>上面的数据<strong>仅仅证明了长期投资远远优于短期投资</strong>，但这并不意味着长期投资就没有风险。</p><blockquote><p>长期投资风险不是短期的波动，因为长期投资者可以忽略短期波动。而且，并不存在任何预定的回报率，而仅仅可能是一个无法实现的期望回报率，风险是这样一种可能性。在长期，股票的回报可能很差。</p></blockquote><p>上面是福特基金会财务官劳伦斯·西格尔关于长期历史回报率的忠告，长期下来，股票的回报可能不及预期。因为长期的终点，很可能正好是市场的寒冬。但是寒冬终会过去，只要继续等待，就一定能等到收货的季节。所以投资界还有一句名言：</p><blockquote><p>当闪电劈下来的时候，你要在场。</p></blockquote><p>需要说明的是，上面的回报率的计算不是基于某个股票，而是基于一堆股票，也就是说这个回报率是市场的平均水平。这就是为什么巴菲特推荐普通投资者购买推荐指数基金的原因：</p><blockquote><p>一个投资者虽然不了解具体企业的经济状况，但又想成为 美国产业的长期拥有者，应当定期地投资于指数基金。以这种方式，一无所知的投资者就能够超越大多数投资专家。但悖谬的是，当迟钝的投资者承认其局限时，他就再不迟钝了。长期 投资者就像寓言里步履蹒跚的乌龟，最终赢得了与投机者的竞赛，而投机者就像那只跑跑停停的兔子。</p></blockquote><p>再强调一下，<strong>关注长期远优于短期</strong>。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>文中表格数据均来自《共同基金常识》十周年纪念版，所以最后再次推荐下这本书。<br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/jie-ping20210125-013013.png" alt="截屏2021-01-25 01.30.13"></p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#4——基金组合和 FOF</title>
    <link href="/2021/01/30/invest-pratice-4/"/>
    <url>/2021/01/30/invest-pratice-4/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://tjjsjwhj.me/2020/07/18/invest-pratice-0/">财务自由实证#0</a>。</p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更”美好“的事物上。</p><h2 id="实证进展"><a href="#实证进展" class="headerlink" title="实证进展"></a>实证进展</h2><p>本月进展如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/16120621994964.jpg" alt="-w414"></p><p>当前进度：2.16%，相比上个月，增加0.16%。本月无特殊操作，按时定投，按比例跟投，其它时间老老实实学习，工作，写公众号。</p><h2 id="目前跟投的基金组合"><a href="#目前跟投的基金组合" class="headerlink" title="目前跟投的基金组合"></a>目前跟投的基金组合</h2><p>附一下当前实证计划中主要的组合：</p><table><thead><tr><th>组合名称</th><th>平台</th><th>主理人</th><th>特点</th></tr></thead><tbody><tr><td>长赢指数投资计划-150份</td><td>且慢APP</td><td>ETF拯救世界</td><td>一次性投入</td></tr><tr><td>长赢指数投资计划-S定投</td><td>且慢APP</td><td>ETF拯救世界</td><td>按比例跟投</td></tr><tr><td>云长进取</td><td>且慢APP</td><td>刘备教授</td><td>按比例跟投 + 定投</td></tr><tr><td>日积月累</td><td>蛋卷基金</td><td>Alex价值发现者</td><td>按比例跟投</td></tr></tbody></table><p>强调一下，实证中的这些组合服务于长期投资组合，能承受的风险等级较高，因此仅供参考。</p><h3 id="什么是基金组合"><a href="#什么是基金组合" class="headerlink" title="什么是基金组合"></a>什么是基金组合</h3><p>基金组合是这两年兴起的一种比较流行的投资方式。这些基金组合是组合的主理人（管这个组合的人）根据一定的投资策略，购买的一篮子基金。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/ji-jin-zu-he.jpg" alt="基金组合"></p><p>有没有发现基金组合的概念十分类似类似 FOF（超链接：什么是FOF）？其实本质都一样，只不过 FOF是正规的基金，受监管部门监管，而普通的基金组合则是由一些知名的大V管理，相对更灵活一些。</p><h3 id="为什么推荐基金组合"><a href="#为什么推荐基金组合" class="headerlink" title="为什么推荐基金组合"></a>为什么推荐基金组合</h3><p>推荐基金组合的原因如下：</p><ol><li>风险相对较低，收益相对稳定</li><li>主理人对外沟通频繁</li><li>主理人真金白银的投资自己的组合</li><li>操作便捷</li></ol><p>第1点，风险相对较低，收益相对稳定。基金本身就是一篮子同类资产，风险相对低一些；基金组合再通过不同类型的基金搭配，进行风险对冲，相对会更稳健一些。</p><p>第2点，<strong>主理人对外沟通频繁</strong>，这是我推荐基金组合的最大原因。普通基金，一般一个季度、甚至半年才会公布一次持仓情况以及调仓理由，其它时间你对这个基金内部的变动一无所知。</p><p>很多人都说要相信基金经理，要长期持有基金，但是关于基金经理的公开资料太少，又不能直接和基金经理沟通，甚至连基金经理买不买自己的基金都不知道，这让投资者怎么始终如一的信任基金经理？靠一腔热血吗？</p><p>主理人就不一样了。大部分基金组合的主理人都有自己偏爱的自媒体渠道，比如前面的<em>ETF拯救世界</em>，尤其喜欢发微博，天天在苦口婆心跟你讲市场怎么样，为什么这么做，要保持什么样的心态等等。</p><p>说的多了，你就能判断出来，这个主理人的投资行为是不是和他的理念一致。只要你认同这种理念，并且对他有了一定的信任，坚持就变成了一件水到渠成的事情。</p><p>第3点，主理人真金白银的投资自己的组合，这个很好理解，因为这样更能获得投资者的信任。</p><p>第4点操作便捷也是我推荐基金组合的原因。这些基金组合一般都依托于较大的第三方基金销售平台（支付宝、且慢、蛋卷等），当主理人对基金组合进行调仓时，平台通过短信或者公众号等方式通知，收到通知后，按比例一键买入即可。</p><p>这里以蛋卷基金上的日积月累组合为例：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/gen-tou-bu-zhou001.jpeg" alt="跟投步骤.001"></p><p>第一步，下载蛋卷APP，搜索日积月累组合，左下角点关注。<br>第二步，微信关注蛋卷基金服务号，登录。然后等通知。<br>第三、四步，根据调仓通知，选择适合自己的比例跟投。</p><p>需要强调的是，这里说的基金组合只是一个名义上的组合，<em>你并不会和主理人发生任何交易</em>，实际直接交易的还是相应的基金公司，跟投仅仅是复制了主理人的操作而已。</p><h3 id="为什么不推荐-FOF"><a href="#为什么不推荐-FOF" class="headerlink" title="为什么不推荐 FOF"></a>为什么不推荐 FOF</h3><p>一方面，FOF基金 作为国内17年新出现的基金品种，还没有广为人知。目前国内公募基金10000多只，FOF 基金只有174只，占比很小，业绩历史较短。</p><p>另一方面，FOF作为正统的基金，受到各种监管限制。比如，最新版的《基金中基金(FOF)审核指引》有如下规定：</p><p>1）FOF中单只基金的市值，不得高于FOF基金资产净值的20%。<br>2）投资于货币市场基金的比例不得超过基金资产的15%。<br>3）某一类型的FOF（如股票型FOF），其80%以上的资产需要投资于股票基金</p><p>其中第2点，最开始 FOF 投资货币基金的资产占比限制时不能超过5%。也就是说如果市场股票和债券都向下的情况下，基金经理却没法大量购买货币基金来避险。这个比例直到19年6月才上调为15%。</p><p>由于 FOF 相比于其它类别的基金，还是新品种（仅就国内而言），所以监管政策还在完善中，FOF 的发展也还在完善中。</p><p>最后还有一个双重收费问题。FOF投资非自家基金公司的基金时，需要支付常规的基金费用项目，而投资者申购FOF也需要支付一定的申购费、管理费等。</p><p>所以目前阶段，我更推荐跟投基金组合的方式（<strong>主理人对外的频繁沟通是巨大的优势</strong>）。</p><h2 id="基金组合的缺点"><a href="#基金组合的缺点" class="headerlink" title="基金组合的缺点"></a>基金组合的缺点</h2><p>上面说了那么多，并不是说基金组合就没有缺点了。</p><p>比如，基金组合其实是主理人的个人组合，每个人都能建立组合。所以这个市场也会越来越鱼龙混杂，</p><p>还有就是主理人虽然会投资自己的组合，但是他不会公布该组合占了他全副身家的多少比例。很多时候你会发现主理人的钱无穷无尽，而你很快就没钱了，最终你的收益也不如主理人。</p><p>另外有些主理人管理的组合很多，并且有越来越多的趋势，很难让人不怀疑他在每个组合上到底能花多少精力。</p><p>不过，仅就 <strong>主理人对外沟通频繁</strong> 这一个理由，我会推荐初学者从跟投基金组合开始，并在这个跟投的过程中完善自己。</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#3——2020年回顾</title>
    <link href="/2020/12/30/invest-pratice-3/"/>
    <url>/2020/12/30/invest-pratice-3/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://tjjsjwhj.me/2020/07/18/invest-pratice-0/">财务自由实证#0</a>。</p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更”美好“的事物上。</p><h2 id="实证进展"><a href="#实证进展" class="headerlink" title="实证进展"></a>实证进展</h2><p>12月份进展如下：<br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2020/12/31/16094299697597.jpg" alt="-w414"></p><p>当前进度：2%。相比上个月增加0.12%。这个月前面都没涨，就这两天涨的。。</p><p>特殊操作方面，值得一提的就是正在逐渐把自己定投的那部分资金卖出，改成跟投其它组合，预计年前能调整完毕。</p><h2 id="2020回顾"><a href="#2020回顾" class="headerlink" title="2020回顾"></a>2020回顾</h2><p>2020年还有几天就要过去了，正好回顾一下这一年的投资理财历程。且慢没有按时间点展示投资及收益的功能，所以投资收益部分只能大概回忆一下，如果记错了，反正也没人知道。</p><p>1月份的时候，也就是春节前，本金2、3万，收益5000+，当时自我感觉良好，觉得自己有抄作业的天赋。</p><p>2月份，疫情发酵。3号，沪深300下跌7.88%。市场吓崩了，我也吓坏了，第一次见指数这么跌。虽然吓的不轻，但操作上啥也没做。之后指数迅速回升到年前水平。</p><p>3月份，疫情的影响持续扩大，从3月5号到3月23号，沪深300累计下跌16%。且慢上19年的收益基本跌没了，累计收益记得只剩200左右。不过因为收益始终是正的，所以心态上还好。</p><p>3月份，9号，12号，16号，18号，美股连续熔断4次，巴菲特天天在说见证历史，大家已经麻木了。</p><p>从3月底到6月底，各国积极应对疫情，尤其是中国，控制的非常好，日常活动已经和平时没有太大差别。资本市场发现被吓过头之后，开始自行修复。不过3长达个月的修复，也才达到了年前的水平。</p><p>这期间，上证指数最低是2680左右，那个时候想着指数每跌50就加一些，哪知道之后再也没有跌到2700以下。不过这个期间也陆陆续续的买了不少。现在回想起来，当时的行情是值得投入绝大部分资产，奋力一博的，可惜了。</p><p>到七月份，市场忽然就火了，可能是大家被憋的太久了，短短几天，沪深300涨了18%，市场情绪被全面点燃：</p><ul><li>部分机构喊出了“全面牛”的口号</li><li>A股的交易量天天破万亿</li><li>新股民开户过于热情导致多家券商平台崩溃</li></ul><p>7月初的这两周，眼见且慢上的收益从5000到10000，又迅速到了15000。这两天深刻认识到了A股暴涨暴跌的特性。（媳妇那个时候已经嚷嚷着要从她的小金库里掏出一部分来买基金了~）</p><p>7月下旬到年底，A股进入了横盘震荡的模式，涨跌比较随性。也正是这段时间的训练，现在每天如果跌个2000、3000，内心毫无波澜。</p><h2 id="一些感悟"><a href="#一些感悟" class="headerlink" title="一些感悟"></a>一些感悟</h2><p>2020年不管对谁，都是难忘且难过的一年。</p><p>从投资角度看，2020年，见证了美股历史上5次熔断中的4次；见证了A股的低迷，也见证了A股的爆发。原本3-5年甚至7年才能遇到市场的各种极端情况，这一年都遇到了。</p><p>经历了魔幻的2020年之后，关于市场和投资，有几个感悟特别强烈：</p><ol><li>不要对市场的顶部和底部设限。它能跌的让你怀疑人生，也能涨的让你怀疑人生。</li><li>不要去追求完美的最低点，模糊的低位区间，就已经值得加仓了。</li><li>无论买什么，都要了解所买资产的底层逻辑，明确自己想要得到什么已经自己能承担失去什么。</li><li>专业的事情交给专业的人做。</li><li>好好学习，好好工作，天天向上，攒钱才是王道。</li></ol><p>希望接下来的市场不要那么快起来，好让我多囤点资产~~</p><h2 id="说一说2020年理财上做的比较好的几点"><a href="#说一说2020年理财上做的比较好的几点" class="headerlink" title="说一说2020年理财上做的比较好的几点"></a>说一说2020年理财上做的比较好的几点</h2><h3 id="投资体系（框架）的知行合一"><a href="#投资体系（框架）的知行合一" class="headerlink" title="投资体系（框架）的知行合一"></a>投资体系（框架）的知行合一</h3><p><a href="https://tjjsjwhj.me/2020/10/10/invest-pratice-1/">财务自由实证#1</a> 中介绍了我的一个比较粗糙的投资体系：</p><ul><li>彻底了解自己</li><li>规划紧急备用金</li><li>规划必要的保险</li><li>规划3年内要用的钱</li><li>建立长期投资组合</li></ul><p>其实这里面的一些步骤或多或少都在其它地方看过或者听过，但是真正相信并彻底执行却是在今年下半年。</p><p>就是写 <a href="https://tjjsjwhj.me/2020/10/10/invest-pratice-1/">财务自由实证#1</a> 之前，有个周末，坐下仔细的梳理了自己的财务状况，严格按照上面的步骤走了一遍。</p><p>紧急备用金买了余额宝和互联网银行存款，保险基本配置完，3年内要用的钱买的债券基金组合中，长期投资组合的钱放在实证计划中的组合里。</p><h3 id="家庭内部实现理财观念的统一"><a href="#家庭内部实现理财观念的统一" class="headerlink" title="家庭内部实现理财观念的统一"></a>家庭内部实现理财观念的统一</h3><p>还记得刚开始的时候，特别希望能和媳妇一起研究如何理财，怎奈媳妇一点兴趣都没有，各种APP都懒得下，还得我去她手机里安装。</p><p>但是一个长达25年的理财规划，如果两个人的观念不能一致，是很难坚持下去的。比如如果市场一路下跌，但是你清楚的这个只是暂时的，撑过去就是海阔天空，但是你的另一半看到账户里天天都绿的发毛，要你赶紧取出来，怎么办？又或者是要买辆车了，但是行情不好，你要不要亏损取出来？</p><p>一边是金钱，一边是家庭和谐，如何选择？当然是两手都要抓，两手都要硬！</p><p>所以平时一有机会，我都会现学现卖，将我刚了解到东西讲给她听，跟她讲指数，讲基金，讲可转债，还有港股，也会把平时看到的比较好的公众号文章分享给她。</p><p>此外，无论赚多少亏多少，我从不瞒着，都会及时告诉她。</p><p>经过这些潜移默化的影响，媳妇现在已经完全认同我的观点，并且偶尔还会主动关心一下收益如何，或者主动和我讨论一下她看到的一些理财观点。</p><p>感谢媳妇一路以来的支持和理解，希望能早点带媳妇实现各种画出去的大饼！</p><h2 id="新年期望"><a href="#新年期望" class="headerlink" title="新年期望"></a>新年期望</h2><p>关于投资理财方面，期望主要有两个。</p><p>一是希望能在投资理财的认知层面和操作层面有一个比较大的进步；二是实证的金额翻个倍？</p><p>元旦快乐~~</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>聊一聊 golang 中的 Context 的实现</title>
    <link href="/2020/12/15/go-context/"/>
    <url>/2020/12/15/go-context/</url>
    
    <content type="html"><![CDATA[<h2 id="编程语言中的-Context"><a href="#编程语言中的-Context" class="headerlink" title="编程语言中的 Context"></a>编程语言中的 Context</h2><p>Context 的直接翻译是上下文或环境。在编程语言中，翻译成运行环境更合适。</p><p>比如一段程序，在执行之初，我们可以设定一个环境参数：最大运行时间，一旦超过这个时间，程序也应该随之终止。</p><p>在 golang 中， Context 被用来在各个 goroutine 之间传递取消信号、超时时间、截止时间、key-value等环境参数。</p><h2 id="golang-中的-Context-的实现"><a href="#golang-中的-Context-的实现" class="headerlink" title="golang 中的 Context 的实现"></a>golang 中的 Context 的实现</h2><p>golang中的Context包很小，除去注释，只有200多行，非常适合通过源码阅读来了解它的设计思路。</p><p><em><strong>注：本文中的golang 均指 go 1.14</strong></em></p><h3 id="接口-Context-的定义"><a href="#接口-Context-的定义" class="headerlink" title="接口 Context 的定义"></a>接口 Context 的定义</h3><p>golang 中 Context 是一个接口类型，具体定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>Deadline() (deadline time.Time, ok <span class="hljs-keyword">bool</span>)<br>Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>Err() error<br>Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Deadline()</strong></p><p>Deadline() 返回的是当前 Context 生命周期的截止时间。</p><p><strong>Done()</strong></p><p>Done() 返回的是一个只读的 channel，如果能从这个 channel 中读到任何值，则表明context的生命周期结束。</p><p><strong>Err()</strong></p><p>这个比较简单，就是返回异常。</p><p><strong>Value(key interface{})</strong></p><p>Value(key interface{}) 返回的是 Context 存储的 key 对应的 value。如果在当前的 Context 中没有找到，就会从父 Context 中寻找，一直寻找到最后一层。</p><h3 id="4种基本的context类型"><a href="#4种基本的context类型" class="headerlink" title="4种基本的context类型"></a>4种基本的context类型</h3><table><thead><tr><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">emptyCtx</td><td align="left">一个没有任何功能的 Context 类型，常用做 root Context。</td></tr><tr><td align="left">cancelCtx</td><td align="left">一个 cancelCtx 是可以被取消的，同时由它派生出来的 Context 都会被取消。</td></tr><tr><td align="left">timerCtx</td><td align="left">一个 timeCtx 携带了一个timer(定时器)和截止时间，同时内嵌了一个 cancelCtx。当 timer 到期时，由 cancelCtx 来实现取消功能。</td></tr><tr><td align="left">valueCtx</td><td align="left">一个 valueCtx 携带了一个 key-value 对，其它的 key-value 对由它的父 Context 携带。</td></tr></tbody></table><h3 id="emptyCtx-定义及实现"><a href="#emptyCtx-定义及实现" class="headerlink" title="emptyCtx 定义及实现"></a>emptyCtx 定义及实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> emptyCtx <span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span> <span class="hljs-title">Deadline</span><span class="hljs-params">()</span> <span class="hljs-params">(deadline time.Time, ok <span class="hljs-keyword">bool</span>)</span></span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span> <span class="hljs-title">Done</span><span class="hljs-params">()</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">struct</span></span>&#123;&#125; &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span> <span class="hljs-title">Err</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span> <span class="hljs-title">Value</span><span class="hljs-params">(key <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>看 emptyCtx 很轻松，因为它什么都没做，仅仅是实现了 Context 这个接口。在 context 包中，有一个全局变量 background，值为 new(emptyCtx)，它的作用就是做个跟 Context。其它类型的 Context 都是在 background 的基础上扩展功能。</p><h3 id="cancelCtx-定义及实现"><a href="#cancelCtx-定义及实现" class="headerlink" title="cancelCtx 定义及实现"></a>cancelCtx 定义及实现</h3><p>先看下 cancelCtx 的定义和创建。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义</span><br><span class="hljs-keyword">type</span> cancelCtx <span class="hljs-keyword">struct</span> &#123;<br>Context<br><br>mu       sync.Mutex            <span class="hljs-comment">// protects following fields</span><br>done     <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;         <span class="hljs-comment">// created lazily, closed by first cancel call</span><br>children <span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// set to nil by the first cancel call</span><br>err      error                 <span class="hljs-comment">// set to non-nil by the first cancel call</span><br>&#125;<br><br><span class="hljs-comment">// 创建</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancel</span><span class="hljs-params">(parent Context)</span> <span class="hljs-params">(ctx Context, cancel CancelFunc)</span></span> &#123;<br>c := newCancelCtx(parent)<br>propagateCancel(parent, &amp;c)<br><span class="hljs-keyword">return</span> &amp;c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;<br>&#125;<br><br><span class="hljs-comment">// newCancelCtx returns an initialized cancelCtx.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newCancelCtx</span><span class="hljs-params">(parent Context)</span> <span class="hljs-title">cancelCtx</span></span> &#123;<br><span class="hljs-keyword">return</span> cancelCtx&#123;Context: parent&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>总体来说，cancelCtx 的创建就是把父 Context 复制到 cancelCtx 的成员 Context 上，然后把父 Context 的一些信号广播到子 Context 上。最后返回了 cancelCtx 的引用，以及一个 cancelFunc。</p><p>我们看一下 cancel 实现的细节：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span> <span class="hljs-title">cancel</span><span class="hljs-params">(removeFromParent <span class="hljs-keyword">bool</span>, err error)</span></span> &#123;<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;context: internal error: missing cancel error&quot;</span>)<br>&#125;<br>c.mu.Lock()<br><span class="hljs-keyword">if</span> c.err != <span class="hljs-literal">nil</span> &#123;<br>c.mu.Unlock()<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// already canceled</span><br>&#125;<br>c.err = err<br><span class="hljs-keyword">if</span> c.done == <span class="hljs-literal">nil</span> &#123;<br>c.done = closedchan<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">close</span>(c.done)<br>&#125;<br><span class="hljs-keyword">for</span> child := <span class="hljs-keyword">range</span> c.children &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> acquiring the child&#x27;s lock while holding parent&#x27;s lock.</span><br>child.cancel(<span class="hljs-literal">false</span>, err)<br>&#125;<br>c.children = <span class="hljs-literal">nil</span><br>c.mu.Unlock()<br><br><span class="hljs-keyword">if</span> removeFromParent &#123;<br>removeChild(c.Context, c)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>cancel 有两个参数，一个是 removeFromParent，表示当前的取消操作是否需要把自己从父 Context 中移除，第二个参数就是执行取消操作需要返回的错误提示。</p><p>根据 cancel 的流程，如果 c.done 是 nil (父 Context 是 emptyCtx 的情况)，就赋值 closedchan。（ closedchan 是一个被关闭的channel）；如果不是nil，就直接关闭。然后递归关闭子 Context。</p><p>这里注意一下，关闭子 Context 的时候，removeFromParent 参数传值是 false，这是因为当前 Context 在关闭的时候，把 child 置成了 nil，所以子 Context 就不用再执行一次从父 Context 移除自身的操作了。</p><p>最后，我们重点说一说 <strong>propagateCancel</strong> 函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">propagateCancel</span><span class="hljs-params">(parent Context, child canceler)</span></span> &#123;<br>done := parent.Done()<br><span class="hljs-keyword">if</span> done == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// parent is never canceled</span><br>&#125;<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-done:<br><span class="hljs-comment">// parent is already canceled</span><br>child.cancel(<span class="hljs-literal">false</span>, parent.Err())<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br><br><span class="hljs-keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;<br>p.mu.Lock()<br><span class="hljs-keyword">if</span> p.err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// parent has already been canceled</span><br>child.cancel(<span class="hljs-literal">false</span>, p.err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> p.children == <span class="hljs-literal">nil</span> &#123;<br>p.children = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125;)<br>&#125;<br>p.children[child] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>p.mu.Unlock()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>atomic.AddInt32(&amp;goroutines, +<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-parent.Done():<br>child.cancel(<span class="hljs-literal">false</span>, parent.Err())<br><span class="hljs-keyword">case</span> &lt;-child.Done():<br>&#125;<br>&#125;()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从函数名 propagateCancel 大概能看出看出来这个函数的功能，即 “传播取消（信号）”。回想一下，父 Context 是如何判断有没有收到取消信号的？是根据它的私有成员 ctx.done 来判断的。那子 Context 如何能接收到这个信号呢？这就是函数 propagateCancel 干的事情，把 ctx.done 赋值给子 Context 的私有成员 done，子 Context 就可以获取到取消的信号。</p><p>propagateCancel 的实际处理要更为复杂一些。首先是判断判断父 Context 有没有被 cancel 掉？如果已经 cancel 掉，那么直接 cancel 掉当前的子 Context；如果没有的话，就会<strong>断言父 Context 是否是emptyCtx 类型</strong>，如果是，就通过父 Context 的成员 children 把子 Context 挂在父 Context 下面；如果不是，就启一个协程监听父 Context 信号。</p><p>解释一下为什么会 <strong>断言父 Context 是否是emptyCtx 类型</strong> ？想象一下，如果是你来写这段逻辑，会怎么写？最简单的方法就是每个子 Context 启一个协程，监听取消信号。这种方式能确实能实现取消信号广播的功能，但缺点就是如果子 Context 过多，协程就会很多，一直占用系统资源；而如果父 Context 的类型是 cancelCtx，那么它就能通过成员 children 递归的取消子 Context。一边是 n 个协程监听取消信号，一遍是一个协程就能递归取消所有子 Context，哪种方式消耗资源少，一目了然。</p><h3 id="timerCtx-定义及实现"><a href="#timerCtx-定义及实现" class="headerlink" title="timerCtx 定义及实现"></a>timerCtx 定义及实现</h3><p>先看以下 timerCtx 的定义和创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> timerCtx <span class="hljs-keyword">struct</span> &#123;<br>cancelCtx<br>timer *time.Timer <span class="hljs-comment">// Under cancelCtx.mu.</span><br><br>deadline time.Time<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithDeadline</span><span class="hljs-params">(parent Context, d time.Time)</span> <span class="hljs-params">(Context, CancelFunc)</span></span> &#123;<br><span class="hljs-keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;<br><span class="hljs-comment">// The current deadline is already sooner than the new one.</span><br><span class="hljs-keyword">return</span> WithCancel(parent)<br>&#125;<br>c := &amp;timerCtx&#123;<br>cancelCtx: newCancelCtx(parent),<br>deadline:  d,<br>&#125;<br>propagateCancel(parent, c)<br>dur := time.Until(d)<br><span class="hljs-keyword">if</span> dur &lt;= <span class="hljs-number">0</span> &#123;<br>c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded) <span class="hljs-comment">// deadline has already passed</span><br><span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">false</span>, Canceled) &#125;<br>&#125;<br>c.mu.Lock()<br><span class="hljs-keyword">defer</span> c.mu.Unlock()<br><span class="hljs-keyword">if</span> c.err == <span class="hljs-literal">nil</span> &#123;<br>c.timer = time.AfterFunc(dur, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded)<br>&#125;)<br>&#125;<br><span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithTimeout</span><span class="hljs-params">(parent Context, timeout time.Duration)</span> <span class="hljs-params">(Context, CancelFunc)</span></span> &#123;<br><span class="hljs-keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))<br>&#125;<br></code></pre></td></tr></table></figure><p>有了前面的 cancelCtx 的基础后，看 timerCtx 会清晰很多。timerCtx 的结构简单一些。timeCtx 有三个成员，第一个是 cancelCtx，这意味这 timerCtx 的取消的操作其实是通过 cancelCtx 实现的；第二个成员是 timer，这是一个定时器，干的事情就是到 deadline 的时候，执行 cancel 操作；第三个成员就是 deadline。</p><p>当然，除了等定时器到期自动执行 cancel 操作，也可以主动执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *timerCtx)</span> <span class="hljs-title">cancel</span><span class="hljs-params">(removeFromParent <span class="hljs-keyword">bool</span>, err error)</span></span> &#123;<br>c.cancelCtx.cancel(<span class="hljs-literal">false</span>, err)<br><span class="hljs-keyword">if</span> removeFromParent &#123;<br><span class="hljs-comment">// Remove this timerCtx from its parent cancelCtx&#x27;s children.</span><br>removeChild(c.cancelCtx.Context, c)<br>&#125;<br>c.mu.Lock()<br><span class="hljs-keyword">if</span> c.timer != <span class="hljs-literal">nil</span> &#123;<br>c.timer.Stop()<br>c.timer = <span class="hljs-literal">nil</span><br>&#125;<br>c.mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><p>如果主动执行 cancel 操作，除了会递归取消子 Context，还是终止定时器。</p><h3 id="valueCtx-的定义和创建"><a href="#valueCtx-的定义和创建" class="headerlink" title="valueCtx 的定义和创建"></a>valueCtx 的定义和创建</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> valueCtx <span class="hljs-keyword">struct</span> &#123;<br>Context<br>key, val <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValue</span><span class="hljs-params">(parent Context, key, val <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">Context</span></span> &#123;<br><span class="hljs-keyword">if</span> key == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;nil key&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;key is not comparable&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *valueCtx)</span> <span class="hljs-title">Value</span><span class="hljs-params">(key <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br><span class="hljs-keyword">if</span> c.key == key &#123;<br><span class="hljs-keyword">return</span> c.val<br>&#125;<br><span class="hljs-keyword">return</span> c.Context.Value(key)<br>&#125;<br></code></pre></td></tr></table></figure><p>valueCtx 也很简单，一个 Context 类型的成员，还有两个都是 interface{} 类型的成员 key，value。</p><p>从 valueCtx 的创建能看到，如果想给 Context 存储一个键值对，只能通过 WithValue 函数创建，且每个 Context 只能存储一对。取值的方式是递归寻找父 Context 存储的键值对，所以一个 Context 相当于存储了全部父节点的键值对。</p><p>另外可以看到，valueCtx 的成员是 Context 类型，不是 cancelCtx 类型，这一点需要注意。所以不同的业务场景需要选择不同的 Context。</p><h2 id="golang-中-Context-的使用"><a href="#golang-中-Context-的使用" class="headerlink" title="golang 中 Context 的使用"></a>golang 中 Context 的使用</h2><p>golang 中 Context 的使用套路是在最开始的时候，创建一个 root Context，这个 root Context 就是 emptyCtx 的一个实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>background = <span class="hljs-built_in">new</span>(emptyCtx)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Background</span><span class="hljs-params">()</span> <span class="hljs-title">Context</span></span> &#123;<br><span class="hljs-keyword">return</span> background<br>&#125;<br></code></pre></td></tr></table></figure><p>接着是根据各个场景，创建不同类型的 Context。</p><p>此外，官方博客也给出了 Context 使用的一些建议：</p><ol><li>不能在其它类型的结构下放 Context 类型的成员。</li><li>Context 类型应该作为函数的第一个参数使用，简写是 ctx</li><li>不要用 nil 来代替本该传入的 Context，实在不行可以先传 context.Todo() (和 background 类似)。</li><li>不要把函数内部的参数添加到 ctx 中。ctx 中应该存一些贯穿始终的数据。</li><li>Context 是并发安全的，所以不用担心多个线程同时使用。</li></ol><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>golang 的 Context 就讲到这里，由于篇幅原因，总觉得还有不少地方没有讲清楚，下回有机会结合业务场景讲一下 Context 的具体使用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/68792989">深度解密Go语言之context</a></li><li><a href="https://blog.csdn.net/u011957758/article/details/82948750?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160788294719726891176947%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=160788294719726891176947&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-10-82948750.nonecase&utm_term=golang%E4%B8%AD%E7%9A%84context&spm=1018.2118.3001.4449">由浅入深聊聊Golang的context</a></li></ol><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>context</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go 性能优化之 benchmark + pprof</title>
    <link href="/2020/12/06/go-benchmark-pprof/"/>
    <url>/2020/12/06/go-benchmark-pprof/</url>
    
    <content type="html"><![CDATA[<blockquote><p>testing 是go自带的一个轻量级的测试框架，主要有三个用途：单元测试(Test)，基准测试(Benchmark)以及示例测试(Example)。</p></blockquote><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>写go也有几个月了，一直没太关注类似 <code>benchmark</code> 之类的性能分析工具，只知道埋头写业务代码。直到前几天，工作上的一个项目遇到了性能瓶颈，需要分析一下原因，就用到了 <code>benchmark</code>。一顿分析，终于发现了程序中的”性能消耗大户“，颇有成就感。</p><h2 id="测试case准备"><a href="#测试case准备" class="headerlink" title="测试case准备"></a>测试case准备</h2><p>平时写代码的过程中，会经常写一些 <code>print</code> 或者 <code>debug</code> 函数，谁又能想到，这些 <code>print</code> 偷偷摸摸的消耗了多少 <code>CPU</code> 和 内存资源呢？</p><p>AES对称加密是业务代码中经常会用到的一种加密方式，但是编码习惯如果不好，或者测试代码忘了删，就会导致加密性能急剧下降。</p><p><strong>大师兄写的AES加密函数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AesEncryptA</span><span class="hljs-params">(aesKey, IV, origin []<span class="hljs-keyword">byte</span>)</span> []<span class="hljs-title">byte</span></span> &#123;<br>block, err := aes.NewCipher(aesKey)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>blocksize := block.BlockSize()<br>blockMode := cipher.NewCBCEncrypter(block, IV)<br>originData := PKCS5Pading(origin, blocksize)<br>crypted := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-built_in">len</span>(originData))<br>blockMode.CryptBlocks(crypted, originData)<br><span class="hljs-keyword">return</span> crypted<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二师兄写的AES加密函数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AesEncryptB</span><span class="hljs-params">(aesKey, IV, origin []<span class="hljs-keyword">byte</span>)</span> []<span class="hljs-title">byte</span></span> &#123;<br>block, err := aes.NewCipher(aesKey)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>blocksize := block.BlockSize()<br>blockMode := cipher.NewCBCEncrypter(block, IV)<br>originData := PKCS5Pading(origin, blocksize)<br>crypted := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-built_in">len</span>(originData))<br>blockMode.CryptBlocks(crypted, originData)<br>    <br>    <span class="hljs-comment">// 把加密结果打印到日志看看</span><br>f, _ := os.Create(<span class="hljs-string">&quot;temp.log&quot;</span>)<br><span class="hljs-keyword">defer</span> f.Close()<br>log.SetOutput(f)<br>log.Println(fmt.Sprintf(<span class="hljs-string">&quot;encrypt res is %s&quot;</span>, base64.StdEncoding.EncodeToString(crypted)))<br><br><span class="hljs-keyword">return</span> crypted<br>&#125;<br></code></pre></td></tr></table></figure><p>乍一看，大师兄和二师兄写的差不多，只是二师兄多了一个把加密结果写到日志中的操作。</p><p><em><strong>就这么一点点的区别，性能能差多少呢?让我们把悬念留到最后。</strong></em></p><h2 id="benchmark-实施"><a href="#benchmark-实施" class="headerlink" title="benchmark 实施"></a>benchmark 实施</h2><p>假设当前项目中的代码就是二师兄写的，我们就来分析一下，当前的性能瓶颈到底在什么地方。</p><h3 id="benchmark编写"><a href="#benchmark编写" class="headerlink" title="benchmark编写"></a>benchmark编写</h3><p><strong>写benchmark几个注意点</strong>：</p><ul><li>文件名以 <code>_test.go</code> 结尾，如 <code>practice_test.go</code></li><li>函数名统一以 <code>Benchmark</code> 开头，参数是 <code>*testing.B</code></li><li>对于要测试的函数，函数外面套上一个 for 循环，for 循环次数的上限是 <code>b.N</code></li><li>为了排除其它流程的干扰，一般会在 for 循环前加上 <code>b.ResetTimer</code></li></ul><p><strong>对二师兄的加密函数写个基准测试</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkAesEncryptB</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>aesKey := []<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;1234567890abcdef&quot;</span>)<br>IV := []<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;7878676756564545&quot;</span>)<br><br>originData := bytes.Repeat([]<span class="hljs-keyword">byte</span>&#123;<span class="hljs-number">28</span>&#125;, <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">29</span>)<br>b.ResetTimer()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>AesEncryptB(aesKey, IV, originData)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了更加明显的对比，这里我们测试的加密数据的大小是512MB（即 1&lt;&lt; 29）</p><h3 id="执行benchmark命令"><a href="#执行benchmark命令" class="headerlink" title="执行benchmark命令"></a>执行benchmark命令</h3><blockquote><p>testing 框架下的基准测试依赖 <code>go test</code> 工具</p></blockquote><p><strong>benchmark 命令示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">test</span> -bench BenchmarkAesEncryptB -run none -benchmem -cpuprofile cpuprofile.out -memprofile memprofile.out<br></code></pre></td></tr></table></figure><p>这个命令中的参数比较多，我们一个个的解释。</p><ul><li><code>-bench</code> 表示执行哪些基准测试函数，后面可以加需要执行的基准测试函数名称，也可以加 <code>.</code>，表示执行全部的基准测试函数。（其实 <code>-bench</code> 后面可以加正则表达式）</li><li><code>-run</code> 表示执行哪些单元测试和示例测试函数，一般会加none，表示都不执行</li><li><code>-benchmen</code> 表示打印函数执行过程中的内存分配</li><li><code>-cpuprofile</code> 表示将全过程的 <code>CPU</code> 的一些概要数据写到文件 <code>cpuprofile.out</code> 中</li><li><code>memprofile</code> 表示将全过程的内存的一些概要数据写到文件 <code>memprofile.out</code> 中</li></ul><p><strong>执行结果分析</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">goos: darwin<br>goarch: amd64<br>pkg: go_practice/benchmart_example<br>BenchmarkAesEncryptB-8                 1        8570217455 ns/op        6218811264 B/op       55 allocs/op<br>PASS<br>ok      go_practice/benchmart_example   9.985s<br></code></pre></td></tr></table></figure><p>从执行结果中能看到，for 循环每执行一次，耗时 8570217455 纳秒，同时会有55次内存分配操作，每次操作 6218811264 字节。</p><p>到这里，我们其实已经完成了基准测试的一个基本流程，也对二师兄的加密函数的性能和内存使用状况有了一个初步的认识。</p><p><strong>但是，我们还是不知道性能瓶颈在哪！！</strong></p><h2 id="终极杀器：benchmark-pprof"><a href="#终极杀器：benchmark-pprof" class="headerlink" title="终极杀器：benchmark + pprof"></a>终极杀器：benchmark + pprof</h2><blockquote><p>pprof 是 go 自带的 <code>CPU</code> 分析器，常用来分析性能瓶颈。</p></blockquote><p>在前面的基准测试中，我们生成了 <code>CPU</code> 概要文件 <code>cpuprofile.out</code> 以及内存概要文件 <code>memprofile.out</code>，现在可以派上大用场了。</p><p>pprof 既可以通过命令行交互的方式查看CPU（内存）的概要数据，也可以通过web的方式查看直观的图形化展示。这里我们主要通过web的方式来展示。</p><p><em><strong>当然，使用pprof工具前，你需要先安装 <code>graphviz</code>，如果是mac，执行 <code>brew install graphviz</code> 就行。</strong></em></p><h3 id="pprof-分析-CPU"><a href="#pprof-分析-CPU" class="headerlink" title="pprof 分析 CPU"></a>pprof 分析 CPU</h3><p><strong>执行命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool pprof -http=<span class="hljs-string">&quot;:8081&quot;</span> cpuprofile.out<br></code></pre></td></tr></table></figure><p>通过地址 <code>http://localhost:8081/ui/</code> 能看到</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/go-benchmark-pprof/cpuprofile.png" alt="cpuprofile.png"></p><p>从这个截图中，我们很容易看到，加密部分总共耗时5.11s，完全用在加密上的耗时才0.76s，其它时间都是用在日志打印上和字符串转化上，</p><h3 id="pprof-分析内存"><a href="#pprof-分析内存" class="headerlink" title="pprof 分析内存"></a>pprof 分析内存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool pprof -http=<span class="hljs-string">&quot;:8081&quot;</span> memprofile.out<br></code></pre></td></tr></table></figure><p>通过地址 <code>http://localhost:8081/ui/</code> 能看到</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/go-benchmark-pprof/memprofile.png" alt="memprofile.png"></p><p>从这个截图图中，我们很容易看到，5930.71MB的内存使用，真正用在加密上的才512MB以及对原始字符串padding操作的640MB，其它内存都耗费在字符串转化和各种 <code>print</code> 操作上。</p><p>很直观的，我们就知道了二师兄的代码问题就在那一段日志打印的操作上。</p><h3 id="优化二师兄的代码"><a href="#优化二师兄的代码" class="headerlink" title="优化二师兄的代码"></a>优化二师兄的代码</h3><p>根据上面的分析，我们需要优化的就是日志打印的那部分代码。二师兄的代码优化后其实就是大师兄的代码。</p><p>我们把大师兄和二师兄的代码放一起跑一遍基准测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">test</span> -bench . -run none -benchmem -cpuprofile cpuprofile.out -memprofile memprofile.out<br></code></pre></td></tr></table></figure><p><strong>得到</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">goos: darwin<br>goarch: amd64<br>pkg: go_practice/benchmart_example<br>BenchmarkAesEncryptA-8                 1        1174023307 ns/op        1207968624 B/op       13 allocs/op<br>BenchmarkAesEncryptB-8                 1        7496300203 ns/op        6218810296 B/op       50 allocs/op<br>PASS<br>ok      go_practice/benchmart_example   9.508s<br></code></pre></td></tr></table></figure><p>从 <code>CPU</code> 耗时上看，大师兄的代码耗时只有二师兄的 1/7，单次内存消耗只有二师兄的 1/5，并且内存分配次数也只有二师兄的 1/4 左右。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>二师兄在追赶大师兄的道路上，又前进了一大步，可喜可贺~~</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://my.oschina.net/solate/blog/3034188">go benchmark 性能测试</a></p><p>[2] <a href="https://golang.org/cmd/go/#hdr-Testing_flags">go testing</a></p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>testing</tag>
      
      <tag>benchmark</tag>
      
      <tag>pprof</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang下文件锁的使用</title>
    <link href="/2020/12/02/go-file-lock/"/>
    <url>/2020/12/02/go-file-lock/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>题目是golang下文件锁的使用，但本文的目的其实是通过golang下的文件锁的使用方法，来一窥文件锁背后的机制。</p><h2 id="为什么需要文件锁"><a href="#为什么需要文件锁" class="headerlink" title="为什么需要文件锁"></a>为什么需要文件锁</h2><blockquote><p>只有多线程/多进程这种并发场景下读写文件，才需要加锁，</p></blockquote><p><strong>场景1-读写并发</strong></p><p>读写并发场景下，如果不加锁，就会出现读到脏数据的情况。想象一下，读文件的进程，读到第500字节，有其它进程以覆盖写的方式向文件中写入1000字节，那读进程读到的后500字节就是脏数据。</p><p><strong>场景2-写写并发</strong></p><p>写写并发场景下，如果不加锁，假设A进程先写0-1000字节，B进程写0-900字节，以此类推，最后一个进程写0-100字节，那最终的文件内容就是每个进程前100个字节拼接起来的错乱的内容了。</p><h2 id="文件锁的几个概念"><a href="#文件锁的几个概念" class="headerlink" title="文件锁的几个概念"></a>文件锁的几个概念</h2><p><strong>共享锁</strong></p><p>共享锁，也叫读锁。某个进程首次获取共享锁后，会生成一个锁类型的变量L，类型标记为共享锁。其它进程获取读锁的时候，L中的计数器加1，表示又有一个进程获取到了共享锁。这个时候如果有进程来获取排它锁，会获取失败。</p><p><strong>排它锁</strong></p><p>排它锁，也叫写锁。某个进程首次获取排他锁后，会生成一个锁类型的变量L，类型标记为排他锁。其它进程获取任何类型的锁的时候，都会获取失败。</p><p><strong>阻塞</strong></p><p>阻塞的意思是说，新的进程发现当前的文件（数据）被加锁后，会一直处于等待状态，直到锁被释放，才会继续下一步的行为。</p><p><strong>非阻塞</strong></p><p>非阻塞的意思是说，新的进程发现当前的文件（数据）被加锁后，立即返回异常。业务上需要根据具体的业务场景对该异常进行处理。</p><p>阻塞和非阻塞其实是进程遇到锁的时候的两种处理模式。</p><h2 id="golang下如何使用文件锁"><a href="#golang下如何使用文件锁" class="headerlink" title="golang下如何使用文件锁"></a>golang下如何使用文件锁</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs golang"><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;syscall&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    f, err := os.Create(<span class="hljs-string">&quot;example.txt&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;create file example.txt failed&quot;</span>, err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> f.Close()<br>    <span class="hljs-comment">// 非阻塞模式下，加共享锁</span><br>    <span class="hljs-keyword">if</span> err := syscall.Flock(<span class="hljs-keyword">int</span>(f.Fd()), syscall.LOCK_SH|syscall.LOCK_NB); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;add share lock in no block failed&quot;</span>, err)<br>    &#125;<br>    <span class="hljs-comment">// 这里进行业务逻辑</span><br>    <span class="hljs-comment">// TODO</span><br><br>    <span class="hljs-comment">// 解锁</span><br>    <span class="hljs-keyword">if</span> err := syscall.Flock(<span class="hljs-keyword">int</span>(f.Fd()), syscall.LOCK_UN); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;unlock share lock failed&quot;</span>, err)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>示例中 <code>LOCK_SH</code> 表示当前获取的是共享锁，如果是 <code>LOCK_EX</code>，则表示获取的是排他锁。而 <code>LOCK_NB</code> 表示当前获取锁的模式是非阻塞模式，如果需要阻塞模式，不加这个参数即可。<code>LOCK_UN</code> 则表示解锁，即释放锁。</p><p>golang 下这种文件锁的使用方式其实是Linux下的系统级调用，使用的是Linux的原生的文件锁的相关能力。</p><h3 id="使用flock的几个注意点"><a href="#使用flock的几个注意点" class="headerlink" title="使用flock的几个注意点"></a>使用flock的几个注意点</h3><p>1、只要fd指向的是同一个文件指针，那么加锁解锁的行为都是继承和覆盖的（这个可以看最后的解释）。</p><p>2、flock这种方式加的是建议性锁，也就是说新的进程一上来不管三七二十一，不去通过flock获取锁，就对文件各种操作，也是可以正常生效的。</p><h2 id="说一说Linux下面的flock和fcntl"><a href="#说一说Linux下面的flock和fcntl" class="headerlink" title="说一说Linux下面的flock和fcntl"></a>说一说Linux下面的flock和fcntl</h2><p>和flock一样，fcntl也是系统级调用，但是在具体的使用上却有很大不用，并且两种锁互不干扰，用flock加锁，fcntl无法感知，反之也一样。</p><h3 id="建议性锁和强制锁"><a href="#建议性锁和强制锁" class="headerlink" title="建议性锁和强制锁"></a>建议性锁和强制锁</h3><p>flock加的是建议性锁，而fcntl加的是强制性锁。</p><p>建议性锁，本质是一种协议，约定读写操作前都去检查一下该文件是否有被其它进程加锁。如果不遵守该协议，一上来就对文件进行操作，不检查有没有锁，程序执行上是没有任何问题的，能执行成功。</p><p>强制性锁，才更像真正意义上的锁。只要加了锁，其它进程是无法执行非允许的操作的。</p><p>其实一些利用redis做的分布式锁，都是建议性锁。锁机的机制要生效，需要大家共同遵守这个约定才行。</p><h3 id="全局锁和局部锁"><a href="#全局锁和局部锁" class="headerlink" title="全局锁和局部锁"></a>全局锁和局部锁</h3><p>对于一个文件，flock加锁的范围是整个文件内容，而fcntl能对文件的任意部分加锁。</p><h3 id="锁的持有者问题"><a href="#锁的持有者问题" class="headerlink" title="锁的持有者问题"></a>锁的持有者问题</h3><p>flock认为，锁的持有者是文件表（可以理解为文件指针），所以对于fork和dup操作，他们都对应同一个文件指针，所有的操作都会作用到这个文件上。具体表现：</p><ul><li>A进程加锁，A的子进程进程可以解锁，新的操作会覆盖之前的操作</li><li>A进程加锁，A进程复制fd，仍然是可以通过新的fd操作文件锁，新的操作会覆盖之前的操作</li></ul><p>fcntl 认为，锁的持有者是进程。加锁和解锁的行为都是跟着进程走，具体表现为：</p><ul><li>A进程加锁，B进程得等A进程消亡或者解锁才能加锁</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/25134841">被遗忘的桃源——flock 文件锁</a></p><p>[2] <a href="https://www.cnblogs.com/charlesblc/category/914733.html">Linux文件锁学习-flock, lockf, fcntl</a></p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#2——延迟退休的影响</title>
    <link href="/2020/11/23/invest-pratice-2/"/>
    <url>/2020/11/23/invest-pratice-2/</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p><strong>财务自由实证</strong> 系列的第零篇是 <a href="https://tjjsjwhj.me/2020/07/18/invest-pratice-0/">财务自由实证#0</a>。</p><p>追求财务自由，并不是希望大富大贵，而是希望自由之后，能更有底气的把生命浪费在更”美好“的事物上，而无须担心生计问题。</p><h2 id="实证进展"><a href="#实证进展" class="headerlink" title="实证进展"></a>实证进展</h2><p>先上进展：<br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/invest_demostration2.jpeg" width="50%" height="50%"></p><p>当前进度：1.88%。相比上个月增加0.19%，呃，听上去有些微不足道。如果仔细看下就会发现，这1个多月中，总资产增加近1万，但是实际新增投入不到6000，这么一看，很惊喜有没有。</p><h2 id="投资计划的一些调整"><a href="#投资计划的一些调整" class="headerlink" title="投资计划的一些调整"></a>投资计划的一些调整</h2><p>这一个月中投资的观念发生了一些变化，具体表现就是新增资金不再定投宽基指数，全部改成跟投基金组合。</p><p>关于基金组合：</p><blockquote><p>由基金主理人结合自己的投资理念选择投资基金与比例，提供符合该理念的投资方案，并进行长期持续仓位管理与方案调整的产品。</p></blockquote><p>组合的买卖调仓操作都会通过短信、APP、微信服务号发送通知，当然跟不跟还是看自己。我的建议是既然选择了相信，就无脑跟投。</p><p>常用的两个软件是<strong>且慢</strong>和<strong>蛋卷基金</strong>，主要跟投两个组合，一个是<strong>E大</strong>(ETF拯救世界)的<strong>长赢计划</strong>，一个是<strong>Alex</strong>的<strong>日积月累</strong>。</p><p><strong>长赢计划</strong>19年初开始跟投，目前收益率60%，比较满意，就是本金有点少，才10000，颇为遗憾。补充一下，因为进去的时间点比较巧，刚好在低点，组合中的绝大部分基金组合持仓成本都比主理人的持仓成本低，所以这个收益率比主理人还要高。</p><p><strong>日积月累</strong>是19年12月开始跟，每月大概跟投1000左右，目前收益率20%多（由于是定投，这个收益率其实是低于组合的实际收益率的，此外，该组合中途也有不少获利了结的，实际收益是更高的）。整体比较满意，没法和<strong>长赢</strong>比，没办法，相比年初，那个时候市场已经起来了。</p><p>很高兴，目前为止，这两个组合的收益率都跑赢了沪深300。</p><h3 id="之前我是如何定投的"><a href="#之前我是如何定投的" class="headerlink" title="之前我是如何定投的"></a>之前我是如何定投的</h3><p>上一篇提到的养老金账户和教育金账户就是手动定投的，其中养老金账户归到了实证计划中，教育金账户另算。这两个账户的策略完全一致，都是按照低估值理论，定投沪深300、中证500和中证红利。</p><p>定投的策略依据的是低估值理论，月初执行定投（刚发完工资），具体执行的时候，会参考下蛋卷和且慢的指数估值，三个指数里面，谁低谁就多买一些（比例啥的，全都是拍脑袋），如此执行了大约1年多。</p><p>养老金的起投时间是2019年8月，截止目前收益率23.2%；教育金起投时间是2019年6月，截止目前收益率23.3%。粗看收益率还行，主要是因为上半年疫情的影响，指数大幅度下跌，那个时候除了严格的执行定投策略，还会不定期不定额的视市场情况，不断加仓。如果没有那段时间的频繁加仓，收益会逊色很多。</p><p>而且中间加仓的那段时间，天天看指数，每天都在想要不要加，加多少，后面又跌了怎么办，十分影响心情。</p><h3 id="调整方案"><a href="#调整方案" class="headerlink" title="调整方案"></a>调整方案</h3><p>基金组合的跟投有两种，一种是存量资金跟投，一种增量资金跟投（类似定投）。</p><p>打算已投部分全部调整到兴全基金管理的一个组合 <strong>兴全进取派选牛基</strong> 中，继续定投的组合还没想好，是且慢的 <strong>U定投</strong> 还是其它，等确定了，后续再公布。</p><h2 id="延迟退休"><a href="#延迟退休" class="headerlink" title="延迟退休"></a>延迟退休</h2><p>说一说最近比较火的《十四五规划建议》，该建议提出，实施渐进式延迟法定退休年龄。之前一直有传言的延迟退休，看这次是真的要落地了。</p><p>客观来说，延迟退休这个事迟早都是要来的，原因有三点：</p><p><strong>1. 人口预期寿命大幅增长</strong></p><p>当前退休年龄是上个世纪50年代指定的，那个时候人口平均预期寿命较低，才45岁左右，如今人口平均寿命大幅增加到77岁。退休年龄不变的情况下，养老金支出会迅猛增加。</p><p>假定一个人25岁开始工作，55岁退休，平均寿命是60岁，工作期间每年缴纳的养老金就是退休之后每年领取的退休金，那么一个劳动力能供养6个退休人员。但是如果平均寿命增加到77岁（2019年数据），那么一个劳动力仅能供养一个退休人员。何况一个劳动力每年缴纳的养老金远远少于之后每年领取的退休金，得多个劳动力才能供养一个退休人员。</p><p>所以说在不调整退休年龄的情况之下，如果平均寿命大幅增加，养老金压力会越来越大，但显而易见，平均寿命还会继续增加。</p><p><strong>2. 计划生育，中国提前步入老年化</strong></p><p>计划生育的一个影响是，新生儿出生率呈断崖式的下跌。这意味着劳动力人口的增长率页呈下跌趋势。</p><p>计划生育从70年代开始实施，70年代末后正式成为一项基本国策。以此推算，到2020年，实行计划生育之前出生的女性职工正式开始退休，到2030年，实行计划剩余之前的男性职工也开始正式退休。</p><p>目前，中国60岁以上的人口2.52亿，而1963年到1970年间出生的人口大约3亿，也就是说到2030年，60岁以上的人口将到5亿，这是很可怕的。</p><p>这么多的老年人口，对养老保险而言，是个很大很重的负担。</p><p><strong>3. 中国养老保险制度实施较晚</strong></p><p>中国的养老保险制度发展颇为曲折，直到1997年，才决定实施社会统筹和个人缴纳相结合的新的养老保险制度。</p><p>这就出现了养老保险的隐形债务问题。由于已经工作和退休的人员没有过去的积累，而他们又必须按新制度领取养老金，那么他们应得的，实际有没有缴纳的那部分，就是隐形的债务。</p><p>因为社会统筹的资金远远不够支付庞大的退休群体的需要。各省、市、县为了按时足额发放养老金，就挪用了本应是将来才能支付的现在在职职工个人账户的资金(社会统筹和个人账户没有分开管理)，从而造成了全国范围内养老金的有名无实，空账运行。</p><p>公开数据显示，我国养老保险个人账户空账规模已经超过1万多亿，虽然做实空账工作已经开展几年，但是空账规模扔在扩大。从债务关系来说，养老金的空账运转是现在向未来透支，是老一代向年轻一代的透支。长此下去必然蕴涵巨大的资金风险，</p><h3 id="如何应对延迟退休"><a href="#如何应对延迟退休" class="headerlink" title="如何应对延迟退休"></a>如何应对延迟退休</h3><p>首先我们要摒弃一个观念，即退休之后，完全靠退休金生活（体制内除外），不信，看下面各个年代的口号：</p><blockquote><p>1985年，宣传口号是”计划生育好，政府来养老”</p></blockquote><blockquote><p>1995年，宣传“只生一个好，政府帮养老”</p></blockquote><blockquote><p>2005年，宣传“养老不能全靠政府“</p></blockquote><blockquote><p>2012年，推出“推迟退休好，自己来养老”</p></blockquote><p>再过几年，会是啥口号呢，你猜~~</p><p>既然延迟退休是无法避免的趋势，那我们应该如何应对延迟退休呢？答案就是尽早开始自己的储蓄计划，无论是财务自由计划，还是养老金储蓄计划，都应该早早的开始。等到了真退休的时候，国家的每一笔退休金，都可以当成额外的收入，岂不美哉？</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#1——如何开始？</title>
    <link href="/2020/10/10/invest-pratice-1/"/>
    <url>/2020/10/10/invest-pratice-1/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://tjjsjwhj.me/2020/07/18/invest-pratice-0/">财务自由实证#0</a>，原本打算每月一篇，没想到这都过去两个月了。过去的就不补了，从10月份开始，立个flag，每月1篇。</p><h2 id="实证进展"><a href="#实证进展" class="headerlink" title="实证进展"></a>实证进展</h2><p>先看下当前进展。</p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/demonstration1.png" width="50%" height="50%"><p>当前进展 1.69%，本周上涨：无。图中记录的软件是且慢小账本（微信小程序），纯手动记录，由于开始几次记录的不完整，收益率等指标可能有偏差，等多记录几次就好了。</p><p>虽然这个实证计划最近才开始，但是实际上投资计划已经开始一年多了，不能完全算从0开始。开始投资的时候，还没有通过投资实现财务自由的想法，纯粹就是希望不贬值，能涨一些就更好。所以当前的账户体系比较混乱，有自己的养老金，也有小孩的教育金，还有一时冲动跟投的不同的投资组合。具体有以下几块：</p><table><thead><tr><th>计划</th><th>投资平台</th><th>备注</th></tr></thead><tbody><tr><td>长赢计划-150</td><td>且慢</td><td>主理人E大的公开计划，跟投</td></tr><tr><td>养老金计划</td><td>且慢</td><td>定投，不同指数基金的组合，瞎折腾</td></tr><tr><td>教育金计划</td><td>且慢</td><td>定投，不同指数基金的组合，瞎折腾</td></tr><tr><td>日积月累</td><td>蛋卷</td><td>主理人Alex的公开计划，跟投</td></tr><tr><td>2020短期计划</td><td>且慢</td><td>瞎折腾，指数基金</td></tr><tr><td>其它组合跟投</td><td>且慢</td><td>如云长进取等组合</td></tr></tbody></table><p>这两天重新梳理了下，觉得将非教育金计划的其它计划都归入到500万的目标中比较合理。因此当前以及之后的统计中均不会包含教育金计划。上文的截图就是除教育金计划之外的总额。</p><h2 id="如何开始自己的自由计划"><a href="#如何开始自己的自由计划" class="headerlink" title="如何开始自己的自由计划"></a>如何开始自己的自由计划</h2><blockquote><p>在真正重要的事情面前，我们一定要慎重，不能轻易的下决定，尤其是涉及到投资的时候。</p></blockquote><p>如果我们在买衣服甚至买菜的时候能花上半小时和老板讨价还价，并为节省下来的几十、几百暗爽不已，那么在面对投资的时候，就更有必要慢下来好好规划自己手上本就为数不多的本金了。</p><p>目前我的投资体系还在摸索中，同时参考其他人的方法，可以初步分为以下几个步骤：</p><ul><li>彻底了解自己</li><li>规划紧急备用金</li><li>规划必要的保险</li><li>规划3年内要用的钱</li><li>建立长期投资组合</li></ul><h3 id="彻底了解自己"><a href="#彻底了解自己" class="headerlink" title="彻底了解自己"></a>彻底了解自己</h3><p>这一步有3个目标：摸清自己手上有多少资金、平均每月支出多少、平均每月结余多少。</p><p>这一步看起来容易，却也不太容易。相信没有多少人能在10分钟内给出答案。然而这一步也是进行后面几步的前提。如果大家平时有记账习惯的话，这一步就很容易，没有的话，支付宝、微信、各银行软件等都有账本功能，能比较容易的统计出来。</p><p>所以到这，大家不妨先花时间好好梳理下，看下手里有多少钱，每月平均支出多少，又有多少结余。</p><h3 id="规划紧急备用金"><a href="#规划紧急备用金" class="headerlink" title="规划紧急备用金"></a>规划紧急备用金</h3><p>开启投资第一步，规划家庭紧急备用金。</p><p>这一步是投资新手们极易忽略却又是十分重要的一步。是否规划了紧急备用金直接关系着后面的长期投资组合能否顺利进行。</p><p>投资路上，难免会遇到各种各样的意外。小到去个急诊，大到忽然失业等。相信经历了2020年上半年之后，大家对意外情况能有一个更深的认识。</p><p>紧急备用金的作用就是当你真的突然需要用钱的时候，可以无视当前的市场行情，坦然渡过。经常有投资的朋友说，自己清楚的知道当前市场处于谷底，也清楚的知道此时正是需要坚持的时候，但是因为这样或者那样的无奈，必须把用于长期投资的资金提取出来，十分可惜。</p><p>一般而言，家庭紧急备用金需要能覆盖6个月的支出。也就是如果一家人忽然没有任何收入来源，仍然能维持当前生活水平继续生活6个月。注意，这里的支出是要全方位的覆盖，比如常规生活支出、房贷、房租、社保、医保等。</p><p>紧急备用金的要求是安全和随存随取。安全意味着比较合适的投资途径就是货币基金、国债或者银行存款。随存随取意味着比较合适的途径就是货币基金（余额宝等）和银行存款（短期存款，）了。</p><h3 id="规划必要的保险"><a href="#规划必要的保险" class="headerlink" title="规划必要的保险"></a>规划必要的保险</h3><p>保险的重要性怎么强调都不为过。哪怕你没有实现财务自由的计划和想法，也需要给自己和家人配置一份完善的保险。</p><p>大多数人家里都没矿，并且谁也不能保证不会遇到重大疾病或者事故。而且但凡遇到，就不是紧急备用金能解决的，甚至把家底掏空都有可能。所以在配置了紧急备用金之后，一定要尽快的把必要的保险都配置上，这样才能在投资长跑中没有后顾之忧</p><p>但是也不能本末倒置，保险的作用是为我们在实现既定目标的路上，保驾护航，保险并不是我们的目标。因此这部分配置完善即可，不需要过度配置。</p><h3 id="规划3年内要用的钱"><a href="#规划3年内要用的钱" class="headerlink" title="规划3年内要用的钱"></a>规划3年内要用的钱</h3><p>这一步的作用和紧急备用金的作用类似，都是为了防止突然从长期组合中取钱而影响收益。</p><p>不一样的是如果出现了需要用紧急备用金的情况，意味着这个钱是立马就需要用的，而如果是3年内要用的钱，通常都有缓冲的余地，不用立刻筹集。此外，3年内要用的钱不像紧急备用金那样可以准确估算，常见的开销有买房、买车、结婚、装修、生小孩等，所以这一步的估算大家只能根据自己的实际情况尽可能的估计了。</p><p>3年内要用的钱意味着它的流动性要求没有那么高，比较合适的投资方式就是定期理财和债券基金。如果持有事件超过半年，一般是债券基金收益更高，更推荐。</p><h3 id="建立长期投资组合"><a href="#建立长期投资组合" class="headerlink" title="建立长期投资组合"></a>建立长期投资组合</h3><p>在我的计划里，长期投资组合的目标就是财务自由的目标。所以以后每一期公布的实证进展就是长期投资组合的进展。</p><p>前面几步都是一次性配置，之后就不用管了，而长期投资组合这部分是最耗精力的。这一步，你有各种各样的选择，可以投资股票、基金、债券、黄金等，也可以投资各种股票基金、债券基金，亦或是无脑跟投你信任的主理人的组合。</p><p>关于如何建立长期投资组合，这一块需要讲述的很多。在后续的文章中我会结合我自己的经验，慢慢的展开。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>第一期实证，暂时先讲这么多。之后的实证计划中，我会详细的介绍我当前的组合，并分析优劣。希望在这个过程中，能不断的提升自己的认知，进一步完善自己的长期投资组合，同时也能向你们证明，工薪族仅仅依靠工资是能实现财务自由的。</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FAQBot 实践系列#1 —— 从开源语料入手</title>
    <link href="/2020/09/19/faq-bot-1/"/>
    <url>/2020/09/19/faq-bot-1/</url>
    
    <content type="html"><![CDATA[<h2 id="语料"><a href="#语料" class="headerlink" title="语料"></a>语料</h2><p>FAQBot构建的基础是有一份高质量的问答语料。通过不断的搜索和查找，找到一份 <code>保险行业</code> 的问答语料：<a href="https://github.com/chatopera/insuranceqa-corpus-zh">insuranceqa-corpus-zh</a></p><h3 id="语料背景"><a href="#语料背景" class="headerlink" title="语料背景"></a>语料背景</h3><p>该语料库包含从网站 <a href="https://www.insurancelibrary.com/">Insurance Library</a> 收集的问题和答案。<br>以下是官方介绍：</p><blockquote><ul><li><p>该语料库的内容由现实世界的用户提出，高质量的答案由具有深度领域知识的专业人士提供。 所以这是一个具有真正价值的语料，而不是玩具。</p></li><li><p>在上述论文中，语料库用于答复选择任务。 另一方面，这种语料库的其他用法也是可能的。 例如，通过阅读理解答案，观察学习等自主学习，使系统能够最终拿出自己的看不见的问题的答案。</p></li><li><p>数据集分为两个部分“问答语料”和“问答对语料”。问答语料是从原始英文数据翻译过来，未经其他处理的。问答对语料是基于问答语料，又做了分词和去标去停，添加label。所以，”问答对语料”可以直接对接机器学习任务。如果对于数据格式不满意或者对分词效果不满意，可以直接对”问答语料”使用其他方法进行处理，获得可以用于训练模型的数据。</p></li></ul></blockquote><h3 id="语料格式"><a href="#语料格式" class="headerlink" title="语料格式"></a>语料格式</h3><p>训练数据之前，我们先仔细看下语料的格式。</p><h4 id="原始语料"><a href="#原始语料" class="headerlink" title="原始语料"></a>原始语料</h4><p>原始语料的目录是 <code>/corpus/pool</code>。 </p><p><strong>问题</strong></p><p>train，test，valid 是存放问题的文件，分别对应着训练集、测试集和验证集。对应的 txt 文件中是中英对照的问题，json 文件中的信息比较全，包含了中英对照的问题，问题的领域（类别），对应的答案以及错误的答案（负样本）。示例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;0&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;zh&quot;</span>: <span class="hljs-string">&quot;医疗保险拿起公司支付吗？&quot;</span>,<br>        <span class="hljs-attr">&quot;en&quot;</span>: <span class="hljs-string">&quot;Does  Medicare  Pick  Up  Co  Pays?&quot;</span>,<br>        <span class="hljs-attr">&quot;domain&quot;</span>: <span class="hljs-string">&quot;medicare-insurance&quot;</span>,<br>        <span class="hljs-attr">&quot;answers&quot;</span>: [<br>            <span class="hljs-string">&quot;4436&quot;</span><br>        ],<br>        <span class="hljs-attr">&quot;negatives&quot;</span>: [<br>            <span class="hljs-string">&quot;1650&quot;</span>,<br>            <span class="hljs-string">&quot;14016&quot;</span>,<br>            <span class="hljs-string">&quot;24487&quot;</span>,<br>            <span class="hljs-string">&quot;18224&quot;</span>,<br>            <span class="hljs-string">&quot;15953&quot;</span>,<br>            <span class="hljs-string">&quot;16740&quot;</span><br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>zh</code> 是根据答案原文翻译过来的，翻译质量一般。比如示例中英文的意思其实是问【医疗保险会承担挂号费吗】（ <code>co-pay</code> 是看医生前需要支付的定额费用，类似挂号费），如果直接看翻译就不知所云了。<code>answers</code> 和 <code>negatives</code> 中的数字表示对应答案的id，下面会提到。</p><p><strong>答案</strong></p><p><code>answers</code> 中包含了答案的id和答案的中英文对照。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;0&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;zh&quot;</span>: <span class="hljs-string">&quot; 汽车跟随着。示例1：如果你被给了一辆汽车（借给），那辆车没有保险，你可以在汽车上买保险，你的保险将是主要的。另一个选择，有人帮你买车。例如，您的信用评分不足以融资，因此您的朋友在您的贷款下签署了主要付款人。您可以根据您的姓名获得保险，甚至将您的朋友列为保险单，作为损失赔偿人。在这种情况下，我们总是建议您获得贷款差距：汽车的实际现金价值与其仍然拥有的金额之间的差额。例2：你借的车有保险。您可以以您的名义购买政策，列出该政策的车辆，如果发生事故，您的政策将成为次要或超额。一旦主要汽车保险的限制用尽，您的保险将踢入，并希望支付其余费用。我特意用了这个词，因为每个事故都是独一无二的，没有实际的索赔情况就很难解释这个覆盖面。即使在给定的索赔情况下，有时索赔有两个可能的结果。&quot;</span>,<br>        <span class="hljs-attr">&quot;en&quot;</span>: <span class="hljs-string">&quot; Coverage follows the car. Example 1: If you were given a car (loaned) and the car has no insurance, you can buy insurance on the car and your insurance will be primary. Another option, someone helped you to buy a car. For example your credit score isn&#x27;t good enough to finance, so a friend of yours signed under your loan as a primary payor. You can get insurance under your name and even list your friend on the policy as a loss payee. In this case, we always suggest you get a loan gap coverage: the difference between the car&#x27;s actual cash value and the amount still owned on it. Example 2: The car you are loaned has insurance. You can buy a policy under your name, list the car on that policy and in case of the accident, your policy will become a secondary or excess. Once the limits of the primary car insurance are exhausted, your coverage would kick in and hopefully pay for the rest. I specifically used the word hopefully, because each accident is unique and it&#x27;s hard to interpret the coverage without the actual claim scenario. And even with a given claim scenario, sometimes there are 2 possible outcomes of a claim.&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="加工语料"><a href="#加工语料" class="headerlink" title="加工语料"></a>加工语料</h4><blockquote><p>使用原始语料，还需要做很多工作才能进入机器学习的模型，比如分词，去停用词，去标点符号，添加label标记。所以，在原始语料的基础上，，insuranceqa-corpus-zh提供了一个使用HanLP分词和去标，去停，添加label的数据集，这个数据集完全是基于原始语料</p></blockquote><p>加工语料的目录是：<code>corpus/pairs</code></p><p><strong>词表</strong><br><code>vocab_data</code> 包含<code>word2id</code> (dict, 从word到id), <code>id2word</code> (dict, 从id到word),<code>tf</code> (dict, 词频统计)和 <code>total</code> (单词总数)。 其中，未登录词的标识为 <code>UNKNOWN</code>，未登录词的id为0。</p><p><strong>数据格式</strong><br>train、test、valid中的数据格式一直。示例中 <code>qid</code> 对应原始语料中问题的 <code>id</code>。 <code>question</code> 中的数值表示分词后，该词对应的<code>id</code>，即 <code>word2id</code> 的查表结果。<code>utterance</code> 是回复，<code>label</code> 如果是 <code>[1,0]</code> 代表回复是正确答案，<code>[0,1]</code> 代表回复不是正确答案，所以 <code>utterance</code> 包含了正例和负例的数据。每个问题含有10个负例和1个正例。该项目并没有说明负样本的采集方式。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;qid&quot;</span>:<span class="hljs-string">&quot;344&quot;</span>,<br>    <span class="hljs-attr">&quot;question&quot;</span>:[<br>        <span class="hljs-number">2462</span>,<span class="hljs-number">3206</span>,<span class="hljs-number">8878</span>,<span class="hljs-number">17449</span>,<span class="hljs-number">11331</span><br>    ],<br>    <span class="hljs-attr">&quot;utterance&quot;</span>:[<br>        <span class="hljs-number">8878</span>,<span class="hljs-number">17449</span>,<span class="hljs-number">11331</span>,<span class="hljs-number">3206</span>,<span class="hljs-number">9757</span>,<span class="hljs-number">21338</span>,<span class="hljs-number">4757</span>,<span class="hljs-number">11331</span>,<span class="hljs-number">13381</span>,<span class="hljs-number">10310</span>,<span class="hljs-number">10114</span>,<span class="hljs-number">6069</span>,<span class="hljs-number">5231</span>,<span class="hljs-number">13346</span>,<span class="hljs-number">4185</span>,<span class="hljs-number">12750</span>,<span class="hljs-number">6568</span>,<span class="hljs-number">5425</span>,<span class="hljs-number">3206</span>,<span class="hljs-number">10114</span>,<span class="hljs-number">11705</span>,<span class="hljs-number">6194</span>,<span class="hljs-number">13402</span>,<span class="hljs-number">23991</span>,<span class="hljs-number">11273</span>,<span class="hljs-number">8231</span>,<span class="hljs-number">490</span>,<span class="hljs-number">10299</span>,<span class="hljs-number">9757</span>,<span class="hljs-number">9843</span>,<span class="hljs-number">18157</span>,<span class="hljs-number">13334</span>,<span class="hljs-number">23611</span>,<span class="hljs-number">1907</span>,<span class="hljs-number">10099</span>,<span class="hljs-number">6568</span>,<span class="hljs-number">7344</span>,<span class="hljs-number">1704</span>,<span class="hljs-number">16818</span>,<span class="hljs-number">2311</span>,<span class="hljs-number">6683</span>,<span class="hljs-number">12268</span>,<span class="hljs-number">7197</span>,<span class="hljs-number">9757</span>,<span class="hljs-number">11869</span>,<span class="hljs-number">23800</span>,<span class="hljs-number">10617</span>,<span class="hljs-number">1134</span>,<span class="hljs-number">22430</span>,<span class="hljs-number">23810</span>,<span class="hljs-number">9843</span>,<span class="hljs-number">14297</span>,<span class="hljs-number">10227</span>,<span class="hljs-number">14005</span>,<span class="hljs-number">5526</span>,<span class="hljs-number">12360</span>,<span class="hljs-number">13467</span>,<span class="hljs-number">16917</span>,<span class="hljs-number">22724</span>,<span class="hljs-number">22086</span>,<span class="hljs-number">24346</span>,<span class="hljs-number">20333</span>,<span class="hljs-number">12268</span><br>    ],<br>    <span class="hljs-attr">&quot;label&quot;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="语料统计"><a href="#语料统计" class="headerlink" title="语料统计"></a>语料统计</h3><table><thead><tr><th>语料集</th><th>类别（Q/A）</th><th>最大长度</th><th>平均长度</th></tr></thead><tbody><tr><td>train</td><td>Q</td><td>42</td><td>5</td></tr><tr><td>train</td><td>A</td><td>878</td><td>162</td></tr><tr><td>test</td><td>Q</td><td>33</td><td>5</td></tr><tr><td>test</td><td>A</td><td>878</td><td>161</td></tr><tr><td>valid</td><td>Q</td><td>31</td><td>5</td></tr><tr><td>878</td><td>A</td><td>878</td><td>165</td></tr></tbody></table><h2 id="Baseline复现"><a href="#Baseline复现" class="headerlink" title="Baseline复现"></a>Baseline复现</h2><h3 id="环境准备-训练"><a href="#环境准备-训练" class="headerlink" title="环境准备+训练"></a>环境准备+训练</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">// git <span class="hljs-built_in">clone</span><br>git <span class="hljs-built_in">clone</span> git@github.com:chatopera/insuranceqa-corpus-zh.git<br><br>// 安装环境依赖<br>pip install -r Requirements.txt<br><br>// 更新数据处理的代码<br>pip install --upgrade insuranceqa_data<br><br>// 模型训练<br>python3 deep_qa_1/network.py<br></code></pre></td></tr></table></figure><p>训练的过程中可能会出现以下错误：</p><ol><li>ssl.SSLError 问题<ul><li>原因是 insuranceqa_data 加载数据的时候，读取数据的路径是绝对路径，读不到数据文件，触发下载，需要修改 insuranceqa_data 中的加载路径为：<code>curdir = os.getcwd()</code> </li><li>本质原因是 Python3 请求https时，会对ssl进行校验，要么安装证书，要么关闭校验，具体方法百度即可。</li></ul></li><li>ImportError: Python is not installed as a framework. <ul><li>mac 下使用matplotlib画图可能会出现这个问题。根据报错提示，在涉及画图的代码中加上 <code>import matplotlib; matplotlib.use(&#39;TkAgg&#39;)</code> 即可</li></ul></li></ol><h3 id="训练结果"><a href="#训练结果" class="headerlink" title="训练结果"></a>训练结果</h3><p><strong>主要训练参数</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">hidden_layers</span> = [<span class="hljs-number">100</span>, <span class="hljs-number">50</span>]<br><span class="hljs-attr">question_max_length</span> = <span class="hljs-number">20</span><br><span class="hljs-attr">utterance_max_length</span> = <span class="hljs-number">99</span><br><span class="hljs-attr">lr</span> = <span class="hljs-number">0.001</span><br><span class="hljs-attr">epoch</span> = <span class="hljs-number">50</span><br><span class="hljs-attr">batch_size</span> = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p><strong>准确率</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/insuranceqa_baseline_accuracy.png" alt="accuracy"></p><p><strong>loss变化</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/insuranceqa_baseline_loss.png" alt="loss"></p><p>可以看到，准确率到了0.9之后几乎就不变了，loss开始下降的很快，之后在0.8附近剧烈波动，说明这个时候再进行更多的迭代训练并不会对准确率的提升有显著的效果，baseline的方法已经到了极限，需要寻找更好的算法了。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>至此，baseline 已经复现完毕。接下来的文章准备以此为基础，不断优化算法，在此基础之上尽可能的提高准确率。</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QABot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#0——自由能实现吗?</title>
    <link href="/2020/07/18/invest-pratice-0/"/>
    <url>/2020/07/18/invest-pratice-0/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>受公众号 <code>【也谈钱】</code> 的影响，以及互联网加班的摧残，觉得有必要早早的开始梳理家庭的财务状况，并且制定财务自由的目标和方案，为自由而奋斗。</p><h2 id="财务自由的目标"><a href="#财务自由的目标" class="headerlink" title="财务自由的目标"></a>财务自由的目标</h2><p>设置 <strong>财务自由</strong> 的目标前，首先需要知道财务自由的定义，明确自己需要实现的是哪种等级的财务自由，才能以此为依据，制定出切实可行的计划，并开始行动。</p><p>这里我拍脑袋定了一个目标：</p><ul><li><strong>目标</strong>：500万（流动性资产）</li><li><strong>期限</strong>：25年</li></ul><p>下面详细解释下这个脑袋是怎么拍的。</p><h3 id="什么是财务自由？"><a href="#什么是财务自由？" class="headerlink" title="什么是财务自由？"></a>什么是财务自由？</h3><p>经常能看到一些标题党文章如 <a href="https://www.sohu.com/a/309461248_120139549">2.9亿？！《2019北京财务自由等级图鉴》出炉！</a> 等等，看完之后瞬间觉得财务自由此生无望。。。</p><p><strong>实际上</strong></p><blockquote><p>财务自由是指你无需为生活开销而努力为钱工作的状态。简单地说，你的资产产生的被动收入必须至少要等于或超过你的日常开支。–<a href="https://zh.wikipedia.org/wiki/%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1">wikipedia</a></p></blockquote><p>根据上面的定义，实现了被动收入大于日常开支就能实现财务自由。听起来很简单有没有~~</p><p>被动收入的等级无法衡量，但是日常支出是可以衡量的。结合近几年财务自由越来越丰富的内涵，财务自由的等级可以戏分如下：</p><ul><li>外卖自由</li><li>打车自由</li><li>商场自由</li><li>租房自由</li><li>旅游自由</li><li>辞职自由</li><li>买车自由</li><li>买房自由<br>……</li></ul><p>我这里使用的并且希望达到的目标就是财务自由最原本的定义，即日常生活开销的自由。</p><h2 id="财务自由的可行性"><a href="#财务自由的可行性" class="headerlink" title="财务自由的可行性"></a>财务自由的可行性</h2><p>理论上被动收入没有上限，但是实现的难度也成指数上升，因此这里通过对日常生活开销的预估来倒推需要多少被动收入。</p><h3 id="日常开销预估"><a href="#日常开销预估" class="headerlink" title="日常开销预估"></a>日常开销预估</h3><p>因为实现财务自由一定是很多很多年后，我们需要根据当前的生活水平来推断20年甚至30年之后的日常开支水平。下面尝试通过一些数据的分析来预估25年后的日常开销。</p><h4 id="通货膨胀"><a href="#通货膨胀" class="headerlink" title="通货膨胀"></a>通货膨胀</h4><p>一说到财务自由的具体目标，很多小伙伴都会想到通货膨胀，说你现在定这么一个目标，多少年之后，钱早就不值钱了，有什么用？</p><p>确实，通货膨胀的因素不能不考虑。</p><blockquote><p>在实践中，一般不直接、也不可能计算通货膨胀率，而是通过价格指数的年增长率来间接表示。</p></blockquote><blockquote><p>由于居民消费价格是反映商品经过流通各环节形成的最终价格，它最全面地反映了商品流通对货币的需要量，因此，居民消费价格指数是最能充分、全面反映通货膨胀率的价格指数。目前，世界各国基本上均用居民消费价格指数，也就是CPI来反映通货膨胀的程度。</p></blockquote><p>看下几个主要国家居民消费价格指数(CPI)年率（同比）数据。</p><p><strong>中国居民消费价格指数年率</strong><br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/China_cpi_year.png" alt="中国居民消费价格指数年率"></p><p><strong>日本居民消费价格指数年率</strong><br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/Japan_cpi_year.png" alt="日本居民消费价格指数年率"></p><p><strong>美国居民消费价格指数年率</strong><br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/USA_cpi_year.png" alt="美国居民消费价格指数年率"></p><p><strong>英国居民消费价格指数年率</strong><br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/UK_cpi_year.png" alt="英国居民消费价格指数年率"></p><p><strong>德国居民消费价格指数年率</strong><br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/German_cpi_year.png" alt="德国居民消费价格指数年率"></p><p>对比5个国家发现，中国在2000年前，CPI年率有过两次高峰，2012年后，CPI年率基本稳定在3%附近，2020年初则是因为疫情的影响又高了起来。</p><p>其它4个国家都是发达国家，日本在1995年后，CPI年率一直稳定在1.3%下面，2015附近年有过一次波峰，和2010附近的波谷正好抵消。美国自1993年之后，CPI年率一直在3%下面，但整体高于日本；英国自1993年之后，CPI年率基本在3%下面，但是它的波动较大，其中一半的时间CPI年率都在2%下面；德国1996年之后绝大部分时间都在2%下面。</p><p>中国由于改革开放，造就了此后30年经济的高速增长，这也是工资、物价飞速增长的30年。但是近些年，我们能明显的感受到，经济的增长速度慢了下来，嗯，也叫经济新常态。之后还可能会进一步降低，降低到和老牌发达国家一样的低增速水平，这也意味着在接下来的一个较长的时期内，CPI年率会一直处于3%以下，并且大部分时间都达不到3%的水平。</p><p>假设当前的物价是1，那么以3%的CPI年率计算，25年后，物价是2.1，翻了一倍，也就是说，同等数量的钱，25年后购买力降低了一半。</p><h4 id="支出项预估"><a href="#支出项预估" class="headerlink" title="支出项预估"></a>支出项预估</h4><p>上面从宏观层面分析了未来20、30年物价可能出现的增长情况，这部分是我们作为个体所无法控制或者较难控制的。我们唯一能控制的就是日常支出。</p><p>然而这一部分也是最难预估的一部分。就目前而言，每月固定开销就有房租、房贷、保险、日常消费等，再过几年还会会有小孩的教育费用等各种无法预料的支出。</p><p>日常开支里，日常生活开销的其实占比很小，大头还是房贷、教育支出等。因此这部分思路如下：将人生分为两个阶段，目标完成前和目标完成后，分别考虑支出。</p><table><thead><tr><th>支出项</th><th>25年期间</th><th>25年之后</th></tr></thead><tbody><tr><td><strong>房贷</strong></td><td>有（较大）</td><td>无（房贷25年）</td></tr><tr><td><strong>子女教育支出</strong></td><td>有（较大）</td><td>无</td></tr><tr><td><strong>大病支出</strong></td><td>保险覆盖</td><td>保险覆盖</td></tr><tr><td>赡养</td><td>有（较低）</td><td>有（稍大）</td></tr><tr><td>保险支出</td><td>有</td><td>少量</td></tr><tr><td>日常家庭开支</td><td>有</td><td>有</td></tr><tr><td>其它</td><td>有</td><td>有</td></tr></tbody></table><p>这里面真正大头的是房贷、子女教育支出和大病支出。除掉这三块之后，其它的其实没有多少。也就是说，相同的钱，在这25年里和25年后，所带来的幸福感是完全不同的。</p><p>那么在一线城市，25年后，在没有房贷和子女教育费用的情况下，一年需要需要多少收入能过的比较幸福呢？</p><p>我的答案是50万。</p><p>换算到现在，依据当前物价水平，在年被动收入25万且没有房贷和子女教育支出的情况下可以过的的比较幸福。一般消费都能支撑的起，还能偶尔奢侈一把。</p><p>考虑到25年后，自己可能还在工作，或者领取退休金，所以实际的生活幸福感会更高。</p><p><strong>注：这里不考虑疾病支出是因为这部分的支出可以通过一个完备的保险计划来覆盖掉。关于如何配置好家庭保险，之后会单独拎出来介绍。</strong></p><h3 id="500万的目标是否合理"><a href="#500万的目标是否合理" class="headerlink" title="500万的目标是否合理"></a>500万的目标是否合理</h3><h4 id="500万够不够？"><a href="#500万够不够？" class="headerlink" title="500万够不够？"></a>500万够不够？</h4><p>根据上面的拍脑袋，25年后被动收入50万就能完全覆盖家庭的日常开支。</p><p>每年50万的被动收入，本金500万的情况下，需要的年化收益率是10%。这个收益率的要求是比较高的，因为那个时候，我们对资产配置的要求已经从获取超额收益变成了获取稳定收益，能承受的风险水平大大降低，相应的收益率水平也会降低。</p><p>但是假设25年后，立即退休，开始领取养老金，社保交25年对应的养老金的替代率能达到50%，有这笔收入作为补充，需要实现的稳定收益率会大大降低，大约6%-7%附近，还是可行的。</p><p>这么一看，500万的目标是合理的。</p><h4 id="能不能通过工资实现？"><a href="#能不能通过工资实现？" class="headerlink" title="能不能通过工资实现？"></a>能不能通过工资实现？</h4><p>同居民消费价格指数一样，未来20、30年，在不出现科技突破导致生产力水平再一次突飞猛进的情况下，工资水平大概率会以一个较低的增长率水平缓慢增长。</p><p>以美国为例，看一下1990年-2018年这28年间 <a href="https://www.statista.com/statistics/200838/median-household-income-in-the-united-states/">美国家庭收入中位数</a> 的变化，最低是1993年的52334，最高是2018年63179，也就是说，这28年间工资的最大增幅才20%。</p><p>当然，如果再去看一下1990年-2018年间 <a href="https://www.ceicdata.com/zh-hans/indicator/united-states/annual-household-income-per-capita">美国家庭人均收入</a> 的变化，你会惊讶的发现其呈稳定增长趋势。结合上面的美国家庭收入中位数几乎不变的事实，可以得出这样一个结论：美国的贫富差距正在迅速扩大。</p><p>中国大概率也会进入这样的状态，当然，考虑到未来一段时间内，中国的经济增长水平仍然会维持在一个中低速增长的水平，因此工资水平还是会有一段时间的中低速的增长，只是不可能会像改革开放之后30年内，出现隔一段时间就翻一番的场景了。</p><p>低速增长的工资水平和物价水平相抵消，意味着很难通过工资实现资本的快速积累，但同时这也意味着在相当长的一段时间内，我们可以维持一个相对稳定的储蓄率。</p><h4 id="能不能攒到500万？"><a href="#能不能攒到500万？" class="headerlink" title="能不能攒到500万？"></a>能不能攒到500万？</h4><p>假设初始金额为0，目标500万，不同期限下每月投入金额和需要的年化收益率的对应关系如下：</p><table><thead><tr><th>每月投入金额</th><th>年复合收益率（15年）</th><th>年复合收益率（20年）</th><th>年复合收益率（25年）</th><th>年复合收益率（30年）</th></tr></thead><tbody><tr><td>500</td><td>47.141%</td><td>31.252%</td><td>22.936%</td><td>17.879%</td></tr><tr><td>1000</td><td>39.033%</td><td>25.719%</td><td>18.724%</td><td>14.469%</td></tr><tr><td>1500</td><td>34.374%</td><td>22.492%</td><td>16.243%</td><td>12.445%</td></tr><tr><td>2000</td><td>31.095%</td><td>20.198%</td><td><strong>14.467%</strong></td><td>10.987%</td></tr><tr><td>2500</td><td>28.561%</td><td>18.411%</td><td>13.075%</td><td>9.840%</td></tr><tr><td>3000</td><td>26.493%</td><td>16.943%</td><td>11.926%</td><td>8.890%</td></tr><tr><td>5000</td><td>20.693%</td><td>12.772%</td><td>8.632%</td><td>6.143%</td></tr></tbody></table><p>综合考虑自己的个人情况，认为每月投入2000，实现15%的年化收益率这种方案比较适合自己。这里面每月投入2000很简单，但是实现15%的收益率不太容易，需要持续不断的投入精力学习各种理财知识。</p><p>那么实现接近15%的年化收益率，难度高吗？这里以沪深300指数为例，沪深300指数基日是2004年12月31日，基点是1000点，2020年1月3号是4144点，折算成年化收益率是9.941%。如果配合一定的策略，完全是可以获取更高的收益率水平的。</p><p>因此，如何构建自己的投资体系，实现15%的超额收益，也是<code>【财务自由实证系列】</code>的一个目标之一。</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>本篇算是 <code>【财务自由实证系列】</code> 的一个序，之后这个系列会定期公开自己财务自由计划的进展，记录自己在实现这个目标过程中的点点滴滴，同时证明这样的一个财务自由计划是完全有可能实现的。</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Modules 简介</title>
    <link href="/2020/06/27/Go-Modules-md/"/>
    <url>/2020/06/27/Go-Modules-md/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>In Go 1.14, module support is considered ready for production use, and all users are encouraged to migrate to modules from other dependency management systems.</p></blockquote><p>在go1.14中，模块支持被认为已经可以在生产环境中使用，因此鼓励所有用户将项目中的依赖管理系统都迁移到Go Mudules中。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="Go-版本升级"><a href="#Go-版本升级" class="headerlink" title="Go 版本升级"></a>Go 版本升级</h3><p><strong>查看Go版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go env<br></code></pre></td></tr></table></figure><p>如果显示版本低于1.14，则需要升级。</p><p><strong>下载Go最新版本</strong></p><p>官网地址：<a href="https://golang.org/dl/">https://golang.org/dl/</a> ，下载对应版本。这里以 <code>go1.14.4.darwin-amd64.tar.gz</code> 为例。</p><p><strong>删除旧版本</strong></p><ul><li>通过 <code>go env</code> 获取安装路径（即 <code>GOROOT</code> ），一般是 <code>/usr/local/go</code> 。</li><li><code> rm -rf /usr/local/go</code> </li></ul><p><strong>安装新版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo tar -C /usr/<span class="hljs-built_in">local</span> -xzf go1.14.4.darwin-amd64.tar.gz<br></code></pre></td></tr></table></figure><p>至此，Go1.14 升级完成，so easy~</p><h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><p>由于一些原因，下载Go的各种依赖包的时候，速度很慢，通过一些镜像网站下载的话，可以获得如丝滑般的下载体验。</p><p><strong>常见的Go Modules镜像网站：</strong><br>1、<a href="https://proxy.golang.org/">https://proxy.golang.org/</a><br>GOPROXY 的默认值，这是一个在大陆无法访问的地址。。<br>2、<a href="https://goproxy.io/">https://goproxy.io/</a><br>一个开源的为 Go Modules 而生的全球代理。国内开发者使用的较多，维护者是个人。<br>3、<a href="https://goproxy.cn/">https://goproxy.cn/</a><br>Goproxy 中国，最初开发者是 <a href="https://aofeisheng.com/">@盛傲飞</a>，目前是七牛云托管和维护。你甚至可以像 goproxy.baidu.com 一样将该服务用作上游代理。</p><p><strong>如何设置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">go env -w GO111MODULE=on<br>go env -w GOPROXY=https://goproxy.cn,direct<br></code></pre></td></tr></table></figure><p><strong>趣闻</strong>：<a href="https://github.com/goproxy/goproxy.cn/issues/61">goproxy.io 和 goproxy.cn 是什么关系?</a></p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><blockquote><p>如果使用 Go Modules 来管理依赖，那么你的项目就没有必要在 <code>GOPATH</code> 中了。</p></blockquote><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>1、随便创建一个项目目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir -p /tmp/scratchpad/repo<br><span class="hljs-built_in">cd</span> /tmp/scratchpad/repo<br></code></pre></td></tr></table></figure><p>2、go mod 准备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go mod init xxx/repo<br></code></pre></td></tr></table></figure><p>其中 <code>xxx</code> 是你项目托管的目录。如果是在github上，则是 <code>github.com/yourname/repo</code> 。</p><p>3、测试代码</p><p>repo 下 main.go 中添加如下测试代码</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-string">&quot;github.com/labstack/echo&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>e := echo.New()<br>e.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c echo.Context)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> c.String(http.StatusOK, <span class="hljs-string">&quot;Hello, World!&quot;</span>)<br>&#125;)<br>e.Logger.Fatal(e.Start(<span class="hljs-string">&quot;:1323&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>4、go mod xxx 相关命令</p><table><thead><tr><th>xxx</th><th>解释</th></tr></thead><tbody><tr><td>download</td><td>download modules to local cache</td></tr><tr><td>edit</td><td>edit go.mod from tools or scripts</td></tr><tr><td>graph</td><td>print module requirement graph</td></tr><tr><td>init</td><td>initialize new module in current directory</td></tr><tr><td>tidy</td><td>add missing and remove unused modules</td></tr><tr><td>vendor</td><td>make vendored copy of dependencies</td></tr><tr><td>verify</td><td>verify dependencies have expected content</td></tr><tr><td>why</td><td>explain why packages or modules are needed</td></tr></tbody></table><h3 id="日常工作流程"><a href="#日常工作流程" class="headerlink" title="日常工作流程"></a>日常工作流程</h3><p>使用 go mod 之后，你的<strong>日常工作流程</strong>应该是这样：</p><ol><li>在代码文件中写好 <code>import</code> 语句</li><li>执行 <code>go run</code> or <code>go build</code> or <code>go test</code>，或者一些其它的标准命令时，会自动下载依赖以及更新 <code>go.mod</code> 文件。</li><li>当你需要指定依赖的版本的时候，你可以使用命令 <code>go get foo@v1.2.3</code>， <code>go get foo@master</code> ，<code>go get foo@e3702bed2</code> 直接下载指定版本（这些命令都会直接更新go.mod），或者直接修改 go.mod 文件。</li></ol><p>一些你可能会用到的其它功能：</p><ol><li><code>go list -m all</code> – 查看全部直接或者间接的依赖</li><li><code>go list -u -m all</code> – 查看全部直接或者间接的依赖版本及最新版本</li><li><code>go get -u ./...</code> or <code>go get -u=patch ./...</code> ,，更新全部直接或者间接依赖到最新 <code>minor</code> 版本或者 <code>patch</code> 版本</li><li><code>go build ./...</code> or <code>go test ./...</code></li><li><code>go mod tidy</code> 精简不必要的依赖，同时增加任何必要的依赖。</li><li><code>go mod vendor</code> — 创建 vendor 目录，并复制依赖到其中。 </li></ol><h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><blockquote><p>A module is a collection of related Go packages that are versioned together as a single unit.</p></blockquote><p>仓库（repository）、模块（module）和 包（package）之间的关联：</p><ul><li>一个仓库包含了一个或多个 Go Modules</li><li>每个模块包含了一个或多个 Go Packages</li><li>每个包 包含了某个路径下的一个或多个 Go Source 文件</li></ul><p>Modules 必须被语义版本化 （遵循 <a href="https://semver.org/">semver</a> 协议），其版本描述格式如 <code>v(major).(minor).(patch)</code> </p><blockquote><ol><li>major (主版本号)：当你做了不兼容的 API 修改，</li><li>minor (次版本号)：当你做了向下兼容的功能性新增</li><li>patch (修订号)：当你做了向下兼容的问题修正</li></ol></blockquote><h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h3><p><code>go.mod</code> 文件中有4个命令：<code>module</code>， <code>require</code>，<code>replace</code>，<code>exclude</code>。</p><p><strong>example</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang">module github.com/my/thing<br><br>require (<br>    github.com/some/dependency v1<span class="hljs-number">.2</span><span class="hljs-number">.3</span><br>    github.com/another/dependency/v4 v4<span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>)<br></code></pre></td></tr></table></figure><p><code>module</code> 命令声明了当前模块的名称以及导入路径。</p><p><code>require</code> 命令标明了当前模块所依赖的模块。</p><p><code>replace</code> 和 <code>exclude</code> 命令仅对当前模块生效，即 build 主模块时，其它依赖模块中的 <code>replace</code> 和 <code>exclude</code> 命令都会被忽略掉。</p><h3 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h3><p>如果当前模块依赖的一个模块名是 M，当你还没有将 M 添加到 <code>go.mod</code> 中的时候，如果执行 <code>go build</code> 或者 <code>go test</code> 等命令，会自动拉取 M 并将其添加到 <code>go.mod</code> 中，拉取规则如下：</p><ul><li>拉取 M 最新的发行版本 v1.2.3，如果没有发行版本，则拉取最新的master的commit</li><li>如果当前模块中的依赖 A 依赖 M v1.0.0，B 依赖 M v1.2.3，那么会选择 M v1.2.3 (最小版本选择算法)</li></ul><h3 id="语义导入版本控制"><a href="#语义导入版本控制" class="headerlink" title="语义导入版本控制"></a>语义导入版本控制</h3><p>这里说的是导入模块的时候，包的路径应该与模块版本相符。</p><p>具体规则如下：</p><ul><li>模块的版本命令应该遵从 <a href="https://semver.org/">semver</a> 协议。</li><li>如果该模块的版本是 v2 或者更高，那么 <code>go.mod</code> 中声明该模块的时候，需要加上 <code>/v2</code> 的后缀，如 <code>module github.com/my/mod/v2</code> 或者 <code>require github.com/my/mod/v2 v2.0.1</code>。这种用法也被用在 <code>go get</code> 命令中，如 <code>go get github.com/my/mod/v2@v2.0.1</code></li></ul><h2 id="FAQs"><a href="#FAQs" class="headerlink" title="FAQs"></a>FAQs</h2><p><strong>1、go.mod 中模块被标记成 <code>incompatible</code> 是什么意思</strong></p><p><strong>答：</strong> 如果 <code>Module</code> 的名字没有遵循 Golang 的规范，即在模块名中附带版本信息，那这就是一个不规范的模块，就会提示 <code>incompatible</code>。以 <code>github.com/labstack/echo</code> 为例，如果其当前版本是 <code>v3.3.10</code> ，那么 go.mod 中会这样显示：<code>github.com/labstack/echo v3.3.10+incompatible</code> 。</p><p>想象一下，如果 <code>github.com/labstack/echo</code> 更新到了 <code>v4.1.1</code> ，如果你的模块依赖它，并且执行了更新全部依赖的命令会怎么样？ <code>github.com/labstack/echo</code> 会更新到 <code>v4.1.1</code>，但是根据 <a href="https://semver.org/">semver</a> 协议，v4 是不兼容 v3 的，这个时候你的模块就会出问题。如果依赖符合规范，如 <code>github.com/labstack/echo/v3</code> ，那你更新全部依赖后，也只是将版本更新到 <code>v3.9.9</code> 或者小于 <code>v4</code> 的最大一个版本，不会出现兼容性的问题。</p><p>当模块的版本小于等 v1 的时候，模块名默认不需附带版本信息。</p><p><strong>2、为什么 <code>go mod tidy</code> 会记录 <code>inderect</code> （非直接）依赖和测试依赖？</strong></p><p><strong>答：</strong> <code>go mod dity</code> 会尽可能的反应出所需要的全部环境下（有可能是系统、处理器架构或者build tags）的依赖，而 <code>go build</code> 和 <code>go test</code> 仅仅是更新 <code>go.mod</code> ，添加当前环境的依赖。</p><p><strong>3、如何在不支持 Module 的模块 A 中导入支持 Module 的 v2+ 的 模块 B?</strong></p><p><strong>答：</strong> 这需要看 module B 是如何发布 v2+ module 的。</p><ol><li>如果是在主分支，在 go.mod 中通过 <code>module</code> 声明 <code>/v3</code> <ul><li>模块 A 中不需要修改导入路径 （即使改了编译的时候也会忽略路径中的版本信息），在 <code>GOPATH</code> 模式下运行的时候，会选择 <code>GOPATH</code> 中的模块 B 的版本编译。</li></ul></li><li>如果 B 是在 子目录中创建了一个 <code>./v3</code> 目录，然后将 <code>go.mod</code> 文件放在 <code>./v3</code> 中<ul><li>A 中使用 <code>import github.com/xxx/B/v3</code> 是没有问题的。</li></ul></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://github.com/golang/go/wiki/Modules">Go Modules 官方文档</a></li><li><a href="https://juejin.im/post/5d8ee2db6fb9a04e0b0d9c8b">干货满满的 Go Modules 和 goproxy.cn</a></li><li><a href="https://rainbowmango.gitbook.io/go/chapter12/3-foreword/3.7-module-incompatible">Go 专家编程-incompatible</a></li></ol><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go Modules</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL之索引</title>
    <link href="/2020/06/21/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/"/>
    <url>/2020/06/21/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么需要索引"><a href="#为什么需要索引" class="headerlink" title="为什么需要索引"></a>为什么需要索引</h2><p>索引就像书籍的目录一样，可以更快的查找数据。</p><h2 id="常见的索引模型"><a href="#常见的索引模型" class="headerlink" title="常见的索引模型"></a>常见的索引模型</h2><blockquote><p>innodb 索引模型选用B+树是由MySQL的应用场景（等值区间查找、插入删除等操作频繁）及机械磁盘的特点（寻址耗时）决定的。像Redis等一些Nosql数据库，他们的索引模型就是哈希表、跳表等。</p></blockquote><ul><li>数组<ul><li>等值查询很快（数组有序排列的情况下，二分查找）</li><li>区间查询很快</li><li>数据的插入删除很慢</li></ul></li><li>哈希表<ul><li>等值查询极快</li><li>插入删除极快</li><li>区间查询很慢（只能一个个的查找）</li></ul></li><li>搜索树（链表）<ul><li>二叉搜索树<ul><li>等值查询、区间查询很快，效率等于数组的二分查找</li><li>插入删除效率logN，需要树的再平衡，再平衡的效率也是logN</li></ul></li><li>多叉搜索树树<ul><li>相比于二叉树，多叉树一次寻址能取出更多的数据，能大大减少寻址次数</li><li>一个节点下面，叶子节点的个数取决于硬盘上数据块的大小</li></ul></li></ul></li></ul><p>MySQL的应用场景中，等值查询和区间查询是很高频的场景，插入删除操作也十分频繁，因此综合考虑，搜索树最适合作为底层的存储引擎。又因为机械硬盘时代，磁盘寻址的时间成本很高，因此 innodb 底层的那存储引擎选用的索引模型是B+树。</p><p>本文后续主要介绍innodb的索引。</p><h2 id="Innodb中的索引"><a href="#Innodb中的索引" class="headerlink" title="Innodb中的索引"></a>Innodb中的索引</h2><h3 id="主键索引和非主键索引"><a href="#主键索引和非主键索引" class="headerlink" title="主键索引和非主键索引"></a>主键索引和非主键索引</h3><p><strong>主键索引：</strong> 主键索引的叶子结点（最后一层）存储的是数据库的行数据。</p><p><strong>非主键索引：</strong> 非主键索引的叶子节点（最后一层）存储的是主键索引。</p><p>对于一个查询操作，查询条件如果是主键索引，则直接返回结果；如果是非主键索引，则先返回主键，然后根据主键查询主键索引树，再返回结果。</p><p><em>查询原则：尽量使用主键索引查询。</em></p><h3 id="索引类别"><a href="#索引类别" class="headerlink" title="索引类别"></a>索引类别</h3><p>innodb中不同索引类别的特点如下：</p><ul><li>普通索引<ul><li>没有任何限制</li></ul></li><li>唯一索引<ul><li>索引列的值唯一</li><li>允许有空值</li><li>组合索引，列值必须唯一</li></ul></li><li>主键索引<ul><li>只能作用于一个列上</li><li>键值唯一</li><li>不能为空</li></ul></li></ul><p>业务上，如果只有一个索引，并且是唯一索引，可以直接用该字段建立索引（<strong>尽量使用主键索引查询原则</strong>）</p><h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>插入数据或者删除数据，都涉及到索引表的调整。</p><p>插入数据的时候，有可能会导致叶子节点数据的挪动，也可能导致数据页的分裂。(对性能的影响需要结合B+树的增删改查操作)</p><p>删除数据的时候，一般只是对数据标记下删除，并不会立即调整索引树，除非索引树中被删除的数据过多，浪费了大量的空间，则需要重建索引树。</p><p><strong>自增主键的优势</strong></p><ul><li>主键自增，索引树不需要维护主键的有序性</li><li>自增ID占空间较小，非主键索引树占用的空间更小</li></ul><p>索引从性能和存储上考虑，自增ID都是更好的选择。</p><blockquote><p>想象以下，一个用户信息表，如果索引选择身份证号码，那每次新增一条数据，为了保证索引有序，都有可能导致一个数据块上数据重新排列，也能导致一个数据块分裂，显然更耗时。</p><p>如果这个用户信息表还有其它非主键索引树，那它的叶子节点存储的都是18位的身份证号码，显然消耗的空间相较于自增ID要更多</p></blockquote><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><blockquote><p>覆盖索引只是一种场景，或者一种现象，构造出这种现象有利于提高查询性能。</p></blockquote><p>先看一个查询的例子。如果我们有如下的一张表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table T (<br>ID int primary key,<br>k int NOT NULL DEFAULT 0, <br>s varchar(16) NOT NULL DEFAULT &#x27;&#x27;,<br>index k(k))<br>engine=InnoDB;<br><br>insert into T values(100,1, &#x27;aa&#x27;),(200,2,&#x27;bb&#x27;),(300,3,&#x27;cc&#x27;),(500,5,&#x27;ee&#x27;),(600,6,&#x27;ff&#x27;),(700,7,&#x27;gg&#x27;);<br></code></pre></td></tr></table></figure><p>如果执行如下语句，需要查询几次？</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> k <span class="hljs-keyword">between</span> <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>答：查询非主键索引树3次，回表2次。</p><p>同样如果执行下面的语句，需要查询几次？</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select <span class="hljs-built_in">id</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> k <span class="hljs-keyword">between</span> <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>答：查询非主键索引树3次，不需要回表。</p><p>如果索引树的查询结果已经包含了我们需要的结果，不需要回表，这种情况就称为覆盖索引。<strong>覆盖索引</strong>是常用的一种性能优手段。</p><h3 id="联合索引和最左前缀原则"><a href="#联合索引和最左前缀原则" class="headerlink" title="联合索引和最左前缀原则"></a>联合索引和最左前缀原则</h3><p>联合索引和最左前缀原则并没有什么必然的联系，这里放在一起讨论是因为联合索引的查找过程会应用到最左前缀原则。</p><h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><blockquote><p>B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</p></blockquote><p>查询的时候，如果查询条件是索引的最左N个字段，或者最左N个字符，都能用上索引，加快查询速度。</p><h4 id="如何安排联合索引的顺序"><a href="#如何安排联合索引的顺序" class="headerlink" title="如何安排联合索引的顺序"></a>如何安排联合索引的顺序</h4><p>联合索引是按照索引项的顺序建立索引的，如（A，B），建立索引的时候，是先按A排序，然后对同一个A，再按B排序，检索的顺序也是如此，先检索A，再检索B。所以建立联合索引的时候，一定要考虑索引的复用 程度。复用程度越高，越要放前面。</p><p>显然如果建立了联合索引（A，B），索引A是不需要单独建立索引的。</p><p>回到之前的覆盖索引，如果有个高频的需求是根据用户的身份证查询姓名，那有必要建立身份证号和姓名的联合索引吗？答案是不考虑索引维护的成本下是有必要的。</p><p>建立了身份证和姓名的联合索引之后，只需要查询联合索引树，就能直接返回查询结果而不需要回表，大大提高查询性能。</p><p>当然，索引的维护是有代价的。因此建立冗余的索引来实现覆盖索引就需要权衡考虑了。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p><strong>题目</strong>：对于如下表，由于历史原因，联合索引（a, b）是必须的，那这里面有不必要的索引吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `geek` (<br>  `a` int(11) NOT NULL,<br>  `b` int(11) NOT NULL,<br>  `c` int(11) NOT NULL,<br>  `d` int(11) NOT NULL,<br>  PRIMARY KEY (`a`,`b`),<br>  KEY `c` (`c`),<br>  KEY `ca` (`c`,`a`),<br>  KEY `cb` (`c`,`b`)<br>) ENGINE=InnoDB;<br></code></pre></td></tr></table></figure><p><strong>答</strong>：ca是不必要的索引。</p><p>对于联合索引（a，b），其内部的组织是先根据a排序，再根据b排序，因此索引树c的内容其实是cab，即先根据c排序，再根据a排序，再根据b排序的一个B+数据。索引树（c，a）的叶子节点实际上是b，树的内容也是cab，和索引树c是一致的，因此ca索引树是不必要的。</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL实战45讲</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL之事务的隔离性</title>
    <link href="/2020/05/31/mysql%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7/"/>
    <url>/2020/05/31/mysql%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>一提到事务，我们就会想到事务的4个特性ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性和持久性）。本篇文章，主要讲的就是隔离性。</p><p>mysql里面并不是所有的存储引擎都支持事务，因此本文中针对事务的讨论都是基于存储引擎innodb。</p><h2 id="一、隔离级别"><a href="#一、隔离级别" class="headerlink" title="一、隔离级别"></a>一、隔离级别</h2><h3 id="1-1-“隔离级别”的概念"><a href="#1-1-“隔离级别”的概念" class="headerlink" title="1.1 “隔离级别”的概念"></a>1.1 “隔离级别”的概念</h3><blockquote><p>脏读（dirty read）: A 事务可以读到B事务未提交的数据，就叫脏读。<br>不可重复读（no-repeatable read）: 事务A开始时只能看到其它事务已经提交的修改。换句话说，事务A的两次查询可能看到不同的结果。（其它事务中途提交修改）。不可重复读针对的是单条记录。<br>幻读（phantom read）:当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）。</p></blockquote><p>当数据库上有多个事务 <strong>并行执行</strong> 的时候，会出现脏读（dirty read）、不可重复读（no-repeatable read）、幻读（phanton read)的问题，为了解决这些问题，就出现了”隔离级别”的概念。</p><h3 id="1-2-不同的隔离级别"><a href="#1-2-不同的隔离级别" class="headerlink" title="1.2 不同的隔离级别"></a>1.2 不同的隔离级别</h3><p>在谈隔离级别之前，我们首先要直到，你隔离的越严实，效率就会越低。因此很多时候，我们需要在二者之间寻找一个平衡点。</p><p>标准的事务隔离级别有以下几种：</p><ol><li><strong>读未提交</strong>（read uncommited）: 一个事务还没提交时，它做的变更就能被别的事务看到。</li><li><strong>读提交</strong>（read commited）: 一个事务提交之后，它做的变更才会被其他事务看到。</li><li><strong>可重复读</strong>（repeatable read）: 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li><strong>串行化</strong>（sirializable）: 对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ol><h3 id="1-3-隔离级别的修改"><a href="#1-3-隔离级别的修改" class="headerlink" title="1.3 隔离级别的修改"></a>1.3 隔离级别的修改</h3><p><strong>隔离级别的查看</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; show variables like &quot;%transaction_isolation%&quot;;</span><br><span class="hljs-section">+-----------------------+-----------------+</span><br><span class="hljs-section">| Variable_name         | Value           |</span><br><span class="hljs-section">+-----------------------+-----------------+</span><br><span class="hljs-section">| transaction_isolation | REPEATABLE-READ |</span><br><span class="hljs-section">+-----------------------+-----------------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>隔离级别的修改</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">set</span> [ <span class="hljs-keyword">global</span> | <span class="hljs-keyword">session</span> ] <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">isolation</span> <span class="hljs-keyword">level</span> [ <span class="hljs-keyword">Read</span> <span class="hljs-keyword">uncommitted</span>  | <span class="hljs-keyword">Read</span> <span class="hljs-keyword">committed</span> | <span class="hljs-keyword">Repeatable</span> <span class="hljs-keyword">read</span> | <span class="hljs-keyword">Serializable</span> ];<br></code></pre></td></tr></table></figure><p>注：<code>[]</code> 表示可选。</p><h3 id="1-4-可重复读隔离级别的演示"><a href="#1-4-可重复读隔离级别的演示" class="headerlink" title="1.4 可重复读隔离级别的演示"></a>1.4 可重复读隔离级别的演示</h3><p>由于mysql默认的隔离级别是可重复读，因此这里就以可重复读为例进行演示，其它情况可通过修改隔离级别模拟。</p><p>步骤1：创建测试表，插入测试数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> T(c <span class="hljs-type">int</span>) engine<span class="hljs-operator">=</span>InnoDB;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> T(c) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>步骤2：起2个事务模仿并发的情况，以下是两个事务中不同操作的执行顺序。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/repeatable%20read.png" alt="可重复读"></p><p>从图中可以看到，右边的事务无论是执行 update 操作，还是提交事务，左边的事务都是看不到的。当左边的事务提交之后，再次查询，才能看到更新之后的数据。完美契合可重复读的定义：事务执行期间看到数据可事务开启时看到的数据一致。</p><p>其它隔离级别读者可自行实验。</p><p><strong>提示</strong> </p><ul><li>如果是读未提交，那在上图第5步的时候，会发现数据发生变化</li><li>如果是读提交，那在上图第7步的时候，会发现数据发生变化</li><li>如果是串行化，那在执行第4步的时候，会失败，必须等左边的事务提交，右边的事务才能继续执行。</li></ul><h3 id="1-5-事务隔离的实现"><a href="#1-5-事务隔离的实现" class="headerlink" title="1.5 事务隔离的实现"></a>1.5 事务隔离的实现</h3><p>实现上，数据库会创建一个视图，访问的时候以视图的逻辑结果为准（<em><strong>注：此视图实为一致性读视图 consistend read view，不是MySQL中特指查询结果的那个视图</strong></em>）。不同时刻启动的事务，会有不同的视图，这意味着不同视图里面的同一条数据会有不同的版本，这就是数据库多版本并发控制（MVCC）。</p><p>“读未提交”隔离级别下，直接读取的最新数据，没有视图的概念；”读提交”隔离级别下，事务中每次执行查询语句前，都会新建一个视图；”可重复读”隔离级别下，事务启动的时候，会创建一个视图，整个事务执行期间都用这个视图；”串行化”隔离级别下，直接用加锁的方式来避免并行访问。</p><p><strong>以可重复读为例:</strong></p><p>在可重复读隔离级别下，不同事务在启动的时候，就拍了不同的”快照”: 一个基于整个库的快照。我们先来看下这个快照是怎么实现的。</p><p>Innodb中每个事务都有一个transaction id，这个id是在事务开始的时候向系统申请的，是按申请顺序严格递增的。</p><p>数据库中的每行数据有多个版本，每一个版本都是和一个transaction id绑定的。比如分别有事务trx_id_1，trx_id_2，trx_id_3 对某行数据进行更新，更新过程中该行数据产生了3个版本v1，v2，v3，记录的时候就会这样记：（v1, trx_id_1），（v2, trx_id_2），（v3, trx_id_3）。实际存储的时候，数据库只会记录最新的记录（v3, trx_id_3）,之前的记录则是通过undo日志计算出来的。</p><p>有了transaction id和多版本的概念，快照的实现方式可以这样描述：</p><ol><li>InnoDB 为每个事务构造了一个<strong>数组</strong>，用来保存这个事务启动瞬间，当前正在<strong>活跃</strong>的所有事务 ID。“活跃”指的就是，启动了但还没提交。</li><li>数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。(<strong>注意：这里的ID的最大值是已经创建过的所有事务ID的最大值</strong>)</li></ol><p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p><p>数据版本的可见性规则，就是基于数据的 trx_id 和这个一致性视图的对比结果得到的。</p><p>假设数据版本对应的事务id为trx_id，则可见性规则如下：</p><ol><li>如果trx_id小于低水位，则数据可见。</li><li>如果trx_id大于高水位，则数据不可见</li><li>如果trx_id在高低水位之间，有两种可能：<ol><li>如果trx_id在数组里，则数据不可见</li><li>如果trx_id不在数组里，则数据可见</li></ol></li></ol><p><strong>此外，如果是这个事务自己更新的数据，它自己还是要认的。</strong> </p><p>假设事务A启动的时候，当前系统中活跃的事务ID为[trx_id_1, trx_id_2, trx_id_3]，最小事务ID为trx_id_1，系统里已经创建过的事务ID的最大值加1为trx_id_max，当前数据版本为（V4，trx_id_x4）。</p><p>如果trx_id_x4 &gt; trx_id_max，就认为当前V4不可见，数据版本根据undolog回退到上一个版本（V3，trx_id_x3），如果trx_id_x3在高低水位之间，并且在数组里面，仍然认为V3不可见，在根据undolog回退到上一个版本(V2，trx_id_x2)，如果trx_id_x2小于低水位，认为数据可见。那么当前事务A在整个事务期间看到的这一行数据的版本都是V2。</p><p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p><ul><li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li><li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li></ul><p>InnoDB 正是利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</p><h3 id="1-5-不同隔离级别的应用场景"><a href="#1-5-不同隔离级别的应用场景" class="headerlink" title="1.5 不同隔离级别的应用场景"></a>1.5 不同隔离级别的应用场景</h3><h2 id="二、事务到底是隔离的还是非隔离的"><a href="#二、事务到底是隔离的还是非隔离的" class="headerlink" title="二、事务到底是隔离的还是非隔离的"></a>二、事务到底是隔离的还是非隔离的</h2><p>上面介绍的不同的隔离级别下看到的数据版本针对的是当前事务的操作是纯读的情况，如果当前事务事务中存在更新操作，那会是什么情况呢？</p><p>当然，串行化的隔离级别下，无论读写，都会加锁，并等待锁的释放，所以这种情况下和原来一样。其它三种级别下，事务执行过程中，如果出现update操作，就会应用这样一条规则：</p><p><strong>更新数据都是先读后写的，而这个读，只能读当前最新版本的值，称为当前读（current read）</strong></p><p>读未提交隔离级别下，一直都是读的最新版本值，所以这条规则实际影响的是 <strong>读提交</strong> 和 <strong>可重复读</strong>。</p><p>在可重复读的事务过程中，如果出现了update操作，会等其它事务的update完成，释放行锁，然后读取当前值，在执行update语句。在这之后的select语句的执行结果都是更新后的值，因为1.5中：</p><p><strong>此外，如果是这个事务自己更新的数据，它自己还是要认的。</strong> </p><h2 id="三、尽量避免使用长事务"><a href="#三、尽量避免使用长事务" class="headerlink" title="三、尽量避免使用长事务"></a>三、尽量避免使用长事务</h2><p>事务的隔离中用到一致性视图，而一致性视图需要用到回滚日志undolog。那回滚日志什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p><p>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 read-view 的时候。</p><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。</p><p>因此建议总是使用 set autocommit=1, 通过显式语句的方式来启动事务(<strong>这样之前挂起的事务会被隐式提交</strong>)。</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL实战45讲</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020年度规划</title>
    <link href="/2020/05/06/2020%E5%B9%B4%E5%BA%A6%E8%A7%84%E5%88%92/"/>
    <url>/2020/05/06/2020%E5%B9%B4%E5%BA%A6%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>临近春节，工作上没有那么忙了，正好把2020年的年度计划整理下，定上几个小目标。</p><p>为了提高计划的完成度，下面制定计划的时候，会尽可能的给出相应的时间节点和比较可行的操作步骤。</p><h3 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h3><p>19年在专业技能上的完成度比较差，所以这一部分先列出来，以体现其重要性。</p><p>对于目前的自己来说，有两个方向，一个是后端开发，另一个是算法（NLP方向）。从行业的发展来看，后端开发的需求量大，技术更新迭代较快，但是在企业，绝大部分的开发内容都是业务逻辑实现，可替代性较强，且工作强度较大，不利于工作和生活的平衡；算法（NLP方向）的数学基础要求较高，门槛高，可替代性较弱，但是随着各种开发工具的完善，算法模型的实现难度在迅速下降，并且NLP发展到今天，已经达到了一个瓶颈，距离真正的自然语言理解还很遥远。</p><p>考虑到自己的兴趣点，以及2-3年之后的职业规划，我在专业技能上的目标是成为一个具有较强的开发能力的自然语言处理算法工程师（算法工程师）。</p><p>以此为基准，2020年的专业技能提升计划如下：</p><ul><li>开发<ul><li>Redis深度历险：核心原理与应用实践<ul><li>目标：完成该书的重读和总结</li><li>时间：Q1季度结束之前</li><li>完成形式：至少三篇技术博客</li></ul></li><li>Go语言编程<ul><li>目标：完成该书的阅读</li><li>时间：Q2季度结束之前</li><li>完成形式：至少四篇技术博客</li></ul></li><li>mysql<ul><li>目标：完成极客时间的mysql实战</li><li>时间：Q2季度之前</li><li>完成形式：至少4篇技术博客</li></ul></li><li>其它相关知识<ul><li>目标：完成工作上一些技术设计的总结</li><li>时间：全年</li><li>完成形式：至少4篇技术博客</li></ul></li></ul></li><li>算法（NLP）<ul><li>自然语言处理入门<ul><li>目标：每月完成一章</li><li>时间：2020年</li><li>完成形式：完整的阅读完，并且能针对其中部分章节形成4-5篇技术博客</li></ul></li><li>机器学习实战<ul><li>目标：完成整本书的代码实现</li><li>时间：2020年</li><li>完成形式：每月完成一个章节算法的github提交</li></ul></li><li>数据结构、算法与应用<ul><li>目标：用Python和Go实现相应的数据结构及算法</li><li>时间：2020年</li><li>完成形式：每2周一篇技术博库</li></ul></li><li>其它<ul><li>leetcode刷题<ul><li>目标：完成200道题目，每周4道题</li><li>时间：2020年</li><li>完成形式：200道题目过关</li></ul></li></ul></li></ul></li></ul><h2 id="非核心能力"><a href="#非核心能力" class="headerlink" title="非核心能力"></a>非核心能力</h2><h3 id="投资"><a href="#投资" class="headerlink" title="投资"></a>投资</h3><h4 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h4><ul><li>逃不开的经济周期</li><li>哈利·布朗的永久投资组合</li></ul><h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><ul><li>投资实证公开</li><li>专业知识整理汇总，逐步形成自己系统的投资知识体系</li><li>开始研究量化投资，争取完成相关代码的开发</li></ul><h3 id="欧洲史"><a href="#欧洲史" class="headerlink" title="欧洲史"></a>欧洲史</h3><p>为明年去欧洲旅行提前做准备，哈哈~~</p><h4 id="阅读-1"><a href="#阅读-1" class="headerlink" title="阅读"></a>阅读</h4><ul><li>极简欧洲史</li><li>企鹅欧洲史</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>之前写2020年规划的时候，才刚过完年来北京。回过头去看，当时指定的目标绝大部分都没有按计划执行。果然自己的自制力还是比较差。今天重新回顾了了下之前的计划，并对其中的部分内容做了删减，感觉又有动力了！</p><hr><p><strong>一个月后见进展~~</strong></p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>年度规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 日志之 redolog</title>
    <link href="/2020/04/13/mysql%E4%B9%8Bredolog/"/>
    <url>/2020/04/13/mysql%E4%B9%8Bredolog/</url>
    
    <content type="html"><![CDATA[<h2 id="一、redolog-概述"><a href="#一、redolog-概述" class="headerlink" title="一、redolog 概述"></a>一、redolog 概述</h2><p><code>mysql</code> 有多种日志，每种日志都有其特定的用途。 <code>redolog</code> 是 <code>mysql</code> 存储引擎为 <code>innodb</code> 时，特有的日志。 <code>innodb</code> 是 <code>mysql</code> 最常用的存储引擎，它的事务的持久性就是通过 <code>redolog</code>保证的。</p><h2 id="二、redolog-介绍"><a href="#二、redolog-介绍" class="headerlink" title="二、redolog 介绍"></a>二、redolog 介绍</h2><p>为了更清晰的将 <code>redolog</code> 讲清楚，本文会围绕以下几个方面逐层展开。</p><ul><li><code>redolog</code> 是什么？</li><li><code>redolog</code> 存储形式</li><li><code>redolog</code> 是怎么产生的？</li><li><code>redolog</code> 的格式</li><li>为什么用 <code>redolog</code> 来保证事务的持久性？</li></ul><h3 id="2-1-redolog-是什么"><a href="#2-1-redolog-是什么" class="headerlink" title="2.1 redolog 是什么"></a>2.1 redolog 是什么</h3><p><code>redolog</code> 是存储引擎 <code>innodb</code> 特有的、在引擎层生成的（ <code>binlog</code> 是在 <code>server</code> 层产生的，不管用任何引擎都会生成），用于保证事务持久性的日志。 <code>redolog</code> 采用了 <code>WAL</code> ( <code>Write-Ahead Logging</code> ) 机制，即日志优先落盘，也就是说，一个事务发生之后， <code>innodb</code> 会先将数据页的变动写到 <code>redolog</code> 中，而不是实际的数据文件中，一旦 <code>redolog</code> 写入完成，就认为这个事务的操作记录完成了。之后mysql会有一套更新机制，定期的将 <code>redolog</code> 中的内容写入到数据文件中。</p><p>在 <code>mysql</code> 中， <code>redolog</code> 不会用来做物理上的主从复制，它主要的应用场景是 <code>crash-recovery</code> (崩溃恢复).</p><p>无论mysql有没有发生异常，重新启动的时候，mysql都会通过 <code>redolog</code> 恢复，确保数据没有问题。</p><h3 id="2-2-redolog-的存储形式"><a href="#2-2-redolog-的存储形式" class="headerlink" title="2.2 redolog 的存储形式"></a>2.2 redolog 的存储形式</h3><p>我们可以执行如下 <code>mysql</code> 命令查看 <code>redolog</code> 相关的部分信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &quot;%innodb_log%”;<br></code></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+------------------------------------+----------+<br>|<span class="hljs-string"> Variable_name                      </span>|<span class="hljs-string"> Value    </span>|<br>+------------------------------------+----------+<br>|<span class="hljs-string"> innodb_log_buffer_size             </span>|<span class="hljs-string"> 16777216 </span>|<br>|<span class="hljs-string"> innodb_log_checksums               </span>|<span class="hljs-string"> ON       </span>|<br>|<span class="hljs-string"> innodb_log_compressed_pages        </span>|<span class="hljs-string"> ON       </span>|<br>|<span class="hljs-string"> innodb_log_file_size               </span>|<span class="hljs-string"> 50331648 </span>|<br>|<span class="hljs-string"> innodb_log_files_in_group          </span>|<span class="hljs-string"> 2        </span>|<br>|<span class="hljs-string"> innodb_log_group_home_dir          </span>|<span class="hljs-string"> ./       </span>|<br>|<span class="hljs-string"> innodb_log_spin_cpu_abs_lwm        </span>|<span class="hljs-string"> 80       </span>|<br>|<span class="hljs-string"> innodb_log_spin_cpu_pct_hwm        </span>|<span class="hljs-string"> 50       </span>|<br>|<span class="hljs-string"> innodb_log_wait_for_flush_spin_hwm </span>|<span class="hljs-string"> 400      </span>|<br>|<span class="hljs-string"> innodb_log_write_ahead_size        </span>|<span class="hljs-string"> 8192     </span>|<br>+------------------------------------+----------+<br></code></pre></td></tr></table></figure><p>一些参数的解释：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">innodb_log_buffer_size:</span> redolog缓存区的大小，即<span class="hljs-number">16</span>m<br><span class="hljs-symbol">innodb_log_file_size:</span> redolog文件的大小，即<span class="hljs-number">48</span>m<br><span class="hljs-symbol">innodb_log_files_in_group:</span> 日志文件组中文件数量<br><span class="hljs-symbol">innodb_log_group_home_dir:</span> 日志文件组路径即 mysql/data<br></code></pre></td></tr></table></figure><p>如果 <code>mysql</code> 的安装路径是默认路径，那么：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/mysql<br>ls data<br></code></pre></td></tr></table></figure><p>形如 <code>ib_logfile0</code>、 <code>ib_logfile1</code> 之类的文件就是 <code>redolog file</code>。为什么这里会出现两个 <code>ib_logfile</code> ？这是因为 <code>redolog file</code> 其实指的是一个文件组，由多个 <code>ib_logfile</code> 合并起来共同表示。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/redolog_checkpoint.png" alt="redolog checkpoint"></p><p><code>redolog</code> 的大小是在配置中设置好的，不能无限制写入。 <code>innodb</code> 采用了循环写入的方式，图中 <code>checkpoint</code> 和 <code>writepos</code> 就是用来区分哪些数据已经从日志文件中刷新到数据文件中。<code>writepos</code> -&gt; <code>checkpoint</code> 之间的数据是已经写入到数据文件中的，是可以删除的，<code>checkpoint</code> -&gt; <code>writepos</code> 之间的数据是已经写入到日志文件中，但是还没有写入到数据文件中，是不可以擦除的。</p><p>如果有新的数据写入到日志文件上，<code>writepos</code> 的位置就会顺时钟挪动，如果发现超过了 <code>checkpoint</code> 的位置，就会强制将一部分 <code>checkpoint</code> 右边的数据刷如磁盘中的数据文件上，然后将 <code>checkpoint</code> 顺时针移动一定的位置。</p><h3 id="2-3-redolog-是怎么产生的"><a href="#2-3-redolog-是怎么产生的" class="headerlink" title="2.3 redolog 是怎么产生的"></a>2.3 redolog 是怎么产生的</h3><h4 id="2-3-1-事务的执行引起-redolog-的更新"><a href="#2-3-1-事务的执行引起-redolog-的更新" class="headerlink" title="2.3.1 事务的执行引起 redolog 的更新"></a>2.3.1 事务的执行引起 redolog 的更新</h4><p><code>redolog</code> 更新的依据是事务的执行。每一次事务执行完毕之后，所引起的数据页的变化都会先写到 <code>redolog</code> 中（当然，如果事务中是先 <code>insert</code> 再 <code>delete</code>，实际不对数据页做出改变的话， <code>redolog</code> 是不会更新的）。</p><p><em>注：<code>innodb</code> 中 <code>insert</code> 或者 <code>update</code> 语句默认都是事务。</em></p><h4 id="2-3-2-redolog-的写入流程"><a href="#2-3-2-redolog-的写入流程" class="headerlink" title="2.3.2 redolog 的写入流程"></a>2.3.2 redolog 的写入流程</h4><p>并不是事务一执行，数据页就被写入到 <code>redolog</code> 中。 <code>redolog</code> 本身是文件，频繁的写文件，会导致性能的降低，所以 <code>redolog</code> 的写入流程如下，以一个 update 操作为例：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/redolog_wiriting_process.png" alt="redolog 刷新流程"></p><p>在最后一步，将数据从缓存刷入文件的时候，其实中间还有一步，缓存中的数据会先刷到 <code>linux</code> 的文件缓存中，然后才会再被刷入到日志文件中。如果 <code>Linux</code> 机器忽然重启，就有可能丢失这部分数据， <code>redolog file</code> 就会更新失败。</p><p><code>redolog buffer</code> 何时刷入日志文件，是否需要强制刷新 <code>Linux</code> 文件缓存？ <code>innodb</code> 主要通过下面这两个参数控制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">+--------------------------------+-------+<br>| Variable_name                  | Value |<br>+--------------------------------+-------+<br>| innodb_flush_log_at_timeout    | 1     |<br>| innodb_flush_log_at_trx_commit | 1     |<br>+--------------------------------+-------+<br></code></pre></td></tr></table></figure><p><code>innodb_flush_log_at_trx_commit</code> 配置的详细说明如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Controls <span class="hljs-keyword">the</span> balance between strict ACID compliance <span class="hljs-keyword">for</span> commit operations <span class="hljs-keyword">and</span> higher performance that is possible when commit-related I/O operations are rearranged <span class="hljs-keyword">and</span> done <span class="hljs-keyword">in</span> batches. You can achieve better performance <span class="hljs-keyword">by</span> changing <span class="hljs-keyword">the</span> default <span class="hljs-built_in">value</span> but <span class="hljs-keyword">then</span> you can lose transactions <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span> crash.<br>* The default setting <span class="hljs-keyword">of</span> <span class="hljs-number">1</span> is required <span class="hljs-keyword">for</span> full ACID compliance. Logs are written <span class="hljs-keyword">and</span> flushed <span class="hljs-built_in">to</span> disk <span class="hljs-keyword">at</span> <span class="hljs-keyword">each</span> transaction commit.<br>* With <span class="hljs-keyword">a</span> setting <span class="hljs-keyword">of</span> <span class="hljs-number">0</span>, logs are written <span class="hljs-keyword">and</span> flushed <span class="hljs-built_in">to</span> disk once per <span class="hljs-keyword">second</span>. Transactions <span class="hljs-keyword">for</span> which logs have <span class="hljs-keyword">not</span> been flushed can be lost <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span> crash.<br>* With <span class="hljs-keyword">a</span> setting <span class="hljs-keyword">of</span> <span class="hljs-number">2</span>, logs are written <span class="hljs-keyword">after</span> <span class="hljs-keyword">each</span> transaction commit <span class="hljs-keyword">and</span> flushed <span class="hljs-built_in">to</span> disk once per <span class="hljs-keyword">second</span>. Transactions <span class="hljs-keyword">for</span> which logs have <span class="hljs-keyword">not</span> been flushed can be lost <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span> crash.<br>* For settings <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">2</span>, once-per-<span class="hljs-keyword">second</span> flushing is <span class="hljs-keyword">not</span> <span class="hljs-number">100</span>% guaranteed. Flushing may occur more frequently due <span class="hljs-built_in">to</span> DDL changes <span class="hljs-keyword">and</span> other internal InnoDB activities that cause logs <span class="hljs-built_in">to</span> be flushed independently <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> innodb_flush_log_at_trx_commit setting, <span class="hljs-keyword">and</span> sometimes less frequently due <span class="hljs-built_in">to</span> scheduling issues. If logs are flushed once per <span class="hljs-keyword">second</span>, up <span class="hljs-built_in">to</span> <span class="hljs-literal">one</span> <span class="hljs-keyword">second</span> <span class="hljs-keyword">of</span> transactions can be lost <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span> crash. If logs are flushed more <span class="hljs-keyword">or</span> less frequently than once per <span class="hljs-keyword">second</span>, <span class="hljs-keyword">the</span> amount <span class="hljs-keyword">of</span> transactions that can be lost varies accordingly.<br>* Log flushing frequency is controlled <span class="hljs-keyword">by</span> innodb_flush_log_at_timeout, which allows you <span class="hljs-built_in">to</span> <span class="hljs-built_in">set</span> <span class="hljs-built_in">log</span> flushing frequency <span class="hljs-built_in">to</span> N <span class="hljs-built_in">seconds</span> (where N is <span class="hljs-number">1</span> ... <span class="hljs-number">2700</span>, <span class="hljs-keyword">with</span> <span class="hljs-keyword">a</span> default <span class="hljs-built_in">value</span> <span class="hljs-keyword">of</span> <span class="hljs-number">1</span>). However, <span class="hljs-keyword">any</span> mysqld <span class="hljs-built_in">process</span> crash can erase up <span class="hljs-built_in">to</span> N <span class="hljs-built_in">seconds</span> <span class="hljs-keyword">of</span> transactions.<br>* DDL changes <span class="hljs-keyword">and</span> other internal InnoDB activities flush <span class="hljs-keyword">the</span> <span class="hljs-built_in">log</span> independently <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> innodb_flush_log_at_trx_commit setting.<br>* InnoDB crash recovery works regardless <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> innodb_flush_log_at_trx_commit setting. Transactions are either applied entirely <span class="hljs-keyword">or</span> erased entirely.<br></code></pre></td></tr></table></figure><p>根据上面的解释，<code>innodb_flush_log_at_trx_commit = 1</code> 时， <code>logbuffer</code> 实时刷入，且系统缓存也会实时刷入文件，此时数据库的四大特性：ACID 能够严格保证。 <code>innodb_flush_log_at_trx_commit</code> 等于其它值的时候，可以通过 <code>innodb_flush_log_at_timeout</code> 来控制缓存刷新的频率。</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_flush_log_at_timeout">相关配置的详细解释</a></p><h3 id="2-4-redolog-文件格式"><a href="#2-4-redolog-文件格式" class="headerlink" title="2.4 redolog 文件格式"></a>2.4 redolog 文件格式</h3><h4 id="2-4-1-redolog-文件存储地址"><a href="#2-4-1-redolog-文件存储地址" class="headerlink" title="2.4.1 redolog 文件存储地址"></a>2.4.1 redolog 文件存储地址</h4><p>根据上文中 <code>innodb_log</code> 的配置 <code>innodb_log_group_home_dir = ./</code> (这里的当前目录即mysql的数据文件目录，如果你是安装在默认路径，一般数据文件目录为 <code>/usr/local/mysql/data</code> )，文件目录如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Shell">drwxr-x---   12 _mysql  _mysql       384 Mar 13 00:31 #innodb_temp<br>drwxr-x---    3 _mysql  _mysql        96 Apr  4 22:10 appengine_common<br>-rw-r-----    1 _mysql  _mysql        56 Aug 28  2019 auto.cnf<br>-rw-r-----    1 _mysql  _mysql      7062 Mar  6 20:58 binlog.000014<br>-rw-r-----    1 _mysql  _mysql       178 Mar  7 01:47 binlog.000015<br>-rw-r-----    1 _mysql  _mysql       178 Mar  7 02:10 binlog.000016<br>-rw-r-----    1 _mysql  _mysql       178 Mar  7 02:34 binlog.000017<br>-rw-r-----    1 _mysql  _mysql       178 Mar 12 11:24 binlog.000018<br>-rw-r-----    1 _mysql  _mysql       178 Mar 12 12:25 binlog.000019<br>-rw-r-----    1 _mysql  _mysql       178 Mar 13 00:31 binlog.000020<br>-rw-r-----    1 _mysql  _mysql  51286298 Apr  4 22:26 binlog.000021<br>-rw-r-----    1 _mysql  _mysql       128 Mar 13 00:31 binlog.index<br>-rw-------    1 _mysql  _mysql      1680 Aug 28  2019 ca-key.pem<br>-rw-r--r--    1 _mysql  _mysql      1112 Aug 28  2019 ca.pem<br>-rw-r--r--    1 _mysql  _mysql      1112 Aug 28  2019 client-cert.pem<br>-rw-------    1 _mysql  _mysql      1680 Aug 28  2019 client-key.pem<br>-rw-r-----    1 _mysql  _mysql      4110 Mar 13 00:31 ib_buffer_pool<br>-rw-r-----    1 _mysql  _mysql  50331648 Apr  4 22:26 ib_logfile0<br>-rw-r-----    1 _mysql  _mysql  50331648 Apr  4 22:26 ib_logfile1<br>-rw-r-----    1 _mysql  _mysql  12582912 Apr  4 22:26 ibdata1<br>-rw-r-----    1 _mysql  _mysql  12582912 Mar 13 00:31 ibtmp1<br>drwxr-x---    8 _mysql  _mysql       256 Nov  8 23:52 mysql<br>-rw-r-----    1 _mysql  _mysql  24117248 Apr  4 22:26 mysql.ibd<br>-rw-r-----    1 _mysql  _mysql     19195 Mar 13 00:31 mysqld.local.err<br>-rw-r-----    1 _mysql  _mysql         4 Mar 13 00:31 mysqld.local.pid<br>drwxr-x---  105 _mysql  _mysql      3360 Nov  8 23:52 performance_schema<br>-rw-------    1 _mysql  _mysql      1680 Aug 28  2019 private_key.pem<br>-rw-r--r--    1 _mysql  _mysql       452 Aug 28  2019 public_key.pem<br>-rw-r--r--    1 _mysql  _mysql      1112 Aug 28  2019 server-cert.pem<br>-rw-------    1 _mysql  _mysql      1676 Aug 28  2019 server-key.pem<br>drwxr-x---    3 _mysql  _mysql        96 Nov  8 23:52 sys<br>drwxr-x---    3 _mysql  _mysql        96 Mar 30 23:15 test<br>-rw-r-----    1 _mysql  _mysql  12582912 Apr  4 22:26 undo_001<br>-rw-r-----    1 _mysql  _mysql  12582912 Apr  4 22:26 undo_002<br></code></pre></td></tr></table></figure><p>其中前缀是 <code>ib_logfile</code> 的文件就是。</p><p>如果你想看一下文件中的具体内容，可以通过命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">strings ib_logfile0<br></code></pre></td></tr></table></figure><p>大概感知一下。在文件中，我们能搜到诸如 <code>thread_id</code>，<code>space_id</code> 之类的字段。</p><h4 id="2-4-2-redolog-格式简介"><a href="#2-4-2-redolog-格式简介" class="headerlink" title="2.4.2 redolog 格式简介"></a>2.4.2 redolog 格式简介</h4><p>尽管一个 <code>redolog</code> 有多个文件，但是每个文件的格式是一致的，只是有一些数据只会存在第一个文件中。</p><p>第一个文件 <code>ib_logfile0</code> 的格式如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/indb_file0_overview.png" alt="ib_logfile0"></p><p>从图中可以看到，日志文件中包含了文件头信息和具体的日志信息，这些日志信息分别写在每一个日志块中。</p><p>其它文件 <code>ib_logfile*</code> 的格式如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/indb_file1_overview.png" alt="ib_logfile*"></p><p>其它的日志文件内容格式基本一样，主要区别在 <code>checkpoint</code> 信息（ <code>checkpoint</code> 记录的是已经更新到数据文件中的 LSN）。</p><p>在深刻理解 <code>checkpoint</code> 的含义前，首先需要理解 <code>LSN</code>（ <code>og sequence number</code> ）的概念。</p><p><strong>什么是LSN？</strong></p><p><code>LSN</code> 表示日志记录创建开始到特定的日志记录已经写入的字节数。 <code>mysql</code> 通过 <code>LSN</code> 来判断是否需要刷新 <code>buffer</code> 到 <code>redolog</code> 上以及是否需要将 <code>redolog</code> 写到磁盘上。<code>LSN</code> 是单调递增的。</p><p>以我本地的数据库为例。</p><p>第一步，查看 <code>innodb</code> 的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show engine innodb status\G;<br></code></pre></td></tr></table></figure><p>部分结果如下(后面的数据就是 <code>LSN</code> )：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">---</span><br><span class="hljs-keyword">LOG</span><br><span class="hljs-comment">---</span><br><span class="hljs-keyword">Log</span> <span class="hljs-keyword">sequence</span> number          <span class="hljs-number">85755920</span><br><span class="hljs-keyword">Log</span> buffer assigned up <span class="hljs-keyword">to</span>    <span class="hljs-number">85755920</span><br><span class="hljs-keyword">Log</span> buffer completed up <span class="hljs-keyword">to</span>   <span class="hljs-number">85755920</span><br><span class="hljs-keyword">Log</span> written up <span class="hljs-keyword">to</span>            <span class="hljs-number">85755920</span><br><span class="hljs-keyword">Log</span> flushed up <span class="hljs-keyword">to</span>            <span class="hljs-number">85755920</span><br>Added dirty pages up <span class="hljs-keyword">to</span>      <span class="hljs-number">85755920</span><br>Pages flushed up <span class="hljs-keyword">to</span>          <span class="hljs-number">85755920</span><br>Last <span class="hljs-keyword">checkpoint</span> at           <span class="hljs-number">85755920</span><br></code></pre></td></tr></table></figure><p>然后我删除了 <code>MySQL</code> 中的一个数据库，再次查看 innodb 的状态，如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">---</span><br><span class="hljs-keyword">LOG</span><br><span class="hljs-comment">---</span><br><span class="hljs-keyword">Log</span> <span class="hljs-keyword">sequence</span> number          <span class="hljs-number">85755974</span><br><span class="hljs-keyword">Log</span> buffer assigned up <span class="hljs-keyword">to</span>    <span class="hljs-number">85755974</span><br><span class="hljs-keyword">Log</span> buffer completed up <span class="hljs-keyword">to</span>   <span class="hljs-number">85755974</span><br><span class="hljs-keyword">Log</span> written up <span class="hljs-keyword">to</span>            <span class="hljs-number">85755974</span><br><span class="hljs-keyword">Log</span> flushed up <span class="hljs-keyword">to</span>            <span class="hljs-number">85755974</span><br>Added dirty pages up <span class="hljs-keyword">to</span>      <span class="hljs-number">85755974</span><br>Pages flushed up <span class="hljs-keyword">to</span>          <span class="hljs-number">85755920</span><br>Last <span class="hljs-keyword">checkpoint</span> at           <span class="hljs-number">85755920</span><br></code></pre></td></tr></table></figure><p>可以看到， <code>buffer</code> 中的 <code>LSN</code> 已经更新了，<code>redolog</code> 中日志记录的 <code>LSN</code> 也已经更新到最新，但是 <code>checkpoint</code> 还是之前的记录，因为 <code>checkpoint</code> 小于 <code>redolog</code> 最新的 <code>LSN</code> ，所以 <code>mysql</code> 认为需要将 <code>checkpoint</code> 之后的数据继续更新到数据文件中。</p><p>继续查看 <code>innodb</code> 的状态，如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">LOG</span><br><span class="hljs-comment">---</span><br><span class="hljs-keyword">Log</span> <span class="hljs-keyword">sequence</span> number          <span class="hljs-number">85755974</span><br><span class="hljs-keyword">Log</span> buffer assigned up <span class="hljs-keyword">to</span>    <span class="hljs-number">85755974</span><br><span class="hljs-keyword">Log</span> buffer completed up <span class="hljs-keyword">to</span>   <span class="hljs-number">85755974</span><br><span class="hljs-keyword">Log</span> written up <span class="hljs-keyword">to</span>            <span class="hljs-number">85755974</span><br><span class="hljs-keyword">Log</span> flushed up <span class="hljs-keyword">to</span>            <span class="hljs-number">85755974</span><br>Added dirty pages up <span class="hljs-keyword">to</span>      <span class="hljs-number">85755974</span><br>Pages flushed up <span class="hljs-keyword">to</span>          <span class="hljs-number">85755974</span><br>Last <span class="hljs-keyword">checkpoint</span> at           <span class="hljs-number">85755974</span><br></code></pre></td></tr></table></figure><p>这次可以看到，<code>checkpoin</code>t 已经更新成最新的 <code>LSN</code> 了，这表明之前没来的及更新到数据文件中 <code>redolog</code> 也已经更新进去了。所以最终全部的 <code>LSN</code> 是保持一致的。</p><p>再细的日志格式就不在这里展开了，我看的也不深，如果你想更深入的了解，一是可以去参考 <code>mysql</code> 的源码，或者参考下面的这两篇文章。</p><p><strong>注</strong>：这一节内容主要参考了文章 <a href="https://blog.51cto.com/wangwei007/2287431">MySQL InnoDB redo Log 浅析</a> 和 <a href="http://mysql.taobao.org/monthly/2017/09/07/">MySQL · 源码分析 · Innodb 引擎Redo日志存储格式简介</a>。</p><h3 id="2-5-为什么用-redolog-来保证事务的持久性？"><a href="#2-5-为什么用-redolog-来保证事务的持久性？" class="headerlink" title="2.5 为什么用 redolog 来保证事务的持久性？"></a>2.5 为什么用 redolog 来保证事务的持久性？</h3><blockquote><p>事务的持久性是指事务一旦提交就会永久生效</p></blockquote><p><code>redolog</code> 采用的机制是 <code>WAL</code> (Write-Ahead Logging) 机制，因此事务的持久性是通过日志的持久性实现的，即每次事务提交，在持久化一个数据页的时候，首先将数据页内容持久化到日志中。</p><p>为什么要采用 <code>WAL</code> 机制？因为将数据页写到日志中的时间要远远快于写到数据存储文件中。我们知道，<code>innodb</code> 底层的存储实现是 <code>B+Tree</code>，对数据页的寻址是通过指针决定的。如果执行多条 <code>update</code> 语句，影响的数据页在不同的磁盘块上，那么对计算机来说磁盘块的寻址会消耗很多时间；而如果是将这些数据页的变动直接写到日志文件中，因为是顺序写入，消耗的时间远远小于前者。</p><p>从 IO 次数来说，<code>WAL</code> 刷新是少量 IO，DaTa 刷新是大量 IO， <code>WAL</code> 刷新次数少得多；<br>从 IO 花销来说， <code>WAL</code> 刷新是连续IO，Data 刷新是随机IO， <code>WAL</code> 刷新花销小得多.</p><p>因此WAL机制在保证事务持久性和数据完整性的同时，成功地提升了系统性能。</p><p><strong>Tips</strong></p><p>redolog 除了用来保证事务的持久性，它所采用的 <strong>两阶段提交</strong> 机制也保证了事务的一致性。<strong>两阶段提交</strong> 涉及到 <code>binlog</code>，后续讲 <code>binlog</code> 的时候，会重点讲解下。</p><p>参考课程：<a href="https://time.geekbang.org/column/intro/100020801?code=rNEW29DDq73FD01HP-2AEicuNieaJ24KUQ9tYhCk1Ow=">https://time.geekbang.org/column/intro/100020801?code=rNEW29DDq73FD01HP-2AEicuNieaJ24KUQ9tYhCk1Ow%3D</a></p><h2 id="三、结语"><a href="#三、结语" class="headerlink" title="三、结语"></a>三、结语</h2><p>相信经过上面的讲解，你应该对 <code>redolog</code> 的概念、用处有了一个清晰的认识，并且能根据不同的生产环境对相关的配置做出合适的调整。如果你希望对 <code>redolog</code> 的具体格式以及实现有更深入的理解，可以结合上文提到文章和源码继续深入了解。</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL实战45讲</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openssl升级教程</title>
    <link href="/2020/01/09/openssl%E5%8D%87%E7%BA%A7%E6%95%99%E7%A8%8B/"/>
    <url>/2020/01/09/openssl%E5%8D%87%E7%BA%A7%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>openssl版本号的含义</strong></p><blockquote><p>OpenSSL version numbers are formatted as n1.n2.n3x, where n1-3 are numbers and x, if present, is one or more letters. These can change depending on the release type:</p><p>Major releases that change one/both of the first two digits, which can break compatibility with previous versions</p><p>Minor releases that change the last digit, e.g. 1.1.0 vs. 1.1.1, can and are likely to contain new features, but in a way that does not break binary compatibility. This means that an application compiled and dynamically linked with 1.1.0 does not need to be recompiled when the shared library is updated to 1.1.1. It should be noted that some features are transparent to the application such as the maximum negotiated TLS version and cipher suites, performance improvements and so on. There is no need to recompile applications to benefit from these features.</p><p>Letter releases, such as 1.0.2a, exclusively contain bug and security fixes and no new features.</p></blockquote><p>后面的字母表示bug的修复记录，那显然选字母越靠后，版本越稳定。</p><h2 id="openssl升级步骤"><a href="#openssl升级步骤" class="headerlink" title="openssl升级步骤"></a>openssl升级步骤</h2><h4 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h4><p><a href="https://www.openssl.org/source/">下载地址</a></p><h4 id="解压编译"><a href="#解压编译" class="headerlink" title="解压编译"></a>解压编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xzf openssl-1.1.1d.tar.gz<br><span class="hljs-built_in">cd</span> openssl-1.1.1d<br><span class="hljs-comment"># --prefix是安装路径，--openssl是配置文件路径</span><br>./config shared --prefix=/opt/openssl --openssldir=/usr/<span class="hljs-built_in">local</span>/ssl -D_GNU_SOURCE<br>make clean<br>make<br>make install<br></code></pre></td></tr></table></figure><p><code>-D_GNU_SOURCE</code>并不是必须的，只有当出现错误提示 <code>&#39;pthread_mutex_recursive&#39; undeclared (first use in this function)</code> 才需要带上，这个一般是因为系统太老。(<a href="https://github.com/openssl/openssl/issues/2261">相关问题链接</a>)</p><h4 id="检查动态链接"><a href="#检查动态链接" class="headerlink" title="检查动态链接"></a>检查动态链接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ldd /opt/openssl/bin/openssl<br></code></pre></td></tr></table></figure><p><strong>如果提示</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">libssl.so.1.1 =&gt; not found<br>libcrypto.so.1.1 =&gt; not found<br>libdl.so.2 =&gt; /lib64/libdl.so.2 (0x0000003f0b300000)<br>libpthread.so.0 =&gt; /lib64/tls/libpthread.so.0 (0x0000003f0b900000)<br>libc.so.6 =&gt; /lib64/tls/libc.so.6 (0x0000003f0b000000)<br>/lib64/ld-linux-x86-64.so.2 (0x0000003f0ae00000)<br></code></pre></td></tr></table></figure><p>说明 <code>libssl.so.1.1</code> 等没有链接上，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ln -s /opt/openssl/lib/libssl.so.1.1 /usr/lib64/libssl.so.1.1<br>sudo ln -s /opt/openssl/lib/libcrypto.so.1.1 /opt/openssl/lib/libcrypto.so.1.1<br></code></pre></td></tr></table></figure><h4 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h4><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/opt/openssl/bin/openssl version<br></code></pre></td></tr></table></figure><p>显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">OpenSSL 1.1.1d  10 Sep 2019<br></code></pre></td></tr></table></figure><h2 id="PHP下升级openssl"><a href="#PHP下升级openssl" class="headerlink" title="PHP下升级openssl"></a>PHP下升级openssl</h2><p><strong>php下添加openss扩展有两种方式</strong></p><ol><li>PHP源码编译安装的时候，带上 <code>--with-openssl[=DIR]</code> ,</li><li>如果php已经安装完成了，不支持openssl，但是又不想重新编译，可以下载对应版本的php源码，解压进入到php/ext/openssl目录，执行 php/bin/phpize，生成configure文件，然后指定编译配置 <code>./configure --with-openssl[=DIR] --with-php-config=/php/bin/php-config</code>，<code>make</code>编译，生成 openssl.so，再在php.ini中开启即可。</li></ol><h2 id="PHP如何实现SM3签名算法？"><a href="#PHP如何实现SM3签名算法？" class="headerlink" title="PHP如何实现SM3签名算法？"></a>PHP如何实现SM3签名算法？</h2><blockquote><p>SM2、SMS3等加密签名算法是国密算法，openssl从1.1.1版本开始支持</p></blockquote><p>由于希望能在PHP中实现<code>SM3</code>算法，想着能否通过升级openssl的方式实现，调研了一天发现，仅通过<code>openssl</code>的升级，无法快速实现。</p><p><strong>原因如下</strong></p><blockquote><p>openssl1.1.1d的安装只是说在系统层面增加了openssl这个工具，安转完之后即可通过命令行的方式实现各种加密算法</p><p>php实现openssl扩展，其原理是通过php/ext/openssl下面的源码，编译实现从openssl工具到php中使用的加密函数的一个映射，检查php/ext/openssl下面的openssl.c文件发现，并没有包含openssl源码中实现SMS3等算法的头文件，所以不管怎么编译，生成的php下的openssl扩展都没有SM3函数</p></blockquote><p><strong>那如何实现在PHP中使用SMS3算法？</strong></p><ol><li>修改php/ext/openssl下面的代码，增加SM3等算法的映射，重新编译生成openssl.so （工程量较大，需要熟悉源码）</li><li>使用openssl的一个分支版本Gmssl。Gmssl在openssl的基础上实现了对一般国密算法的支持，同时提供了用于编译openssl.so的php/ext/openssl源码，编译生成openssl.so即可 (<strong>该方法尚未验证成，怀疑和PHP版本有关</strong>)</li><li>安装完openssl工具后，在PHP代码中直接执行linux命令：<code>echo -n &quot;abc&quot; | /opt/openssl/bin/openssl dgst -SM3</code> </li></ol><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>php</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>openssl</tag>
      
      <tag>sm3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>价值投资的关键</title>
    <link href="/2020/01/06/%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9A%84%E5%85%B3%E9%94%AE/"/>
    <url>/2020/01/06/%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9A%84%E5%85%B3%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="投资中最重要的事"><a href="#投资中最重要的事" class="headerlink" title="投资中最重要的事"></a>投资中最重要的事</h2><p><strong>认知和格局</strong></p><p>你能看到多么大的趋势，就能看到多少机会。你接触的人和信息，决定你有着怎样的视野，以及你看到的是怎样的一个世界。</p><p><strong>逻辑驱动买入，逻辑驱动卖出</strong></p><p>不要有偏见，一切以数据、和数据推演出的逻辑为准。以前涨不涨和以后涨不涨没关系，关注涨跌背后的逻辑，不要被个股波动的表象所影响。</p><h2 id="能力圈原则"><a href="#能力圈原则" class="headerlink" title="能力圈原则"></a>能力圈原则</h2><p><strong>清楚自己的能力圈</strong></p><p>围绕真正了解的企业画一个圈，排除不合格的企业。</p><p><strong>能力圈在精不在多</strong></p><p>对自己的能力圈拉爱说，最重要的不是能力圈的范围大小，而是你如何能够确定能力圈的便捷所在。</p><p><strong>坚守能力圈</strong></p><p>明白自己到底不知道什么，固收于自己相信和了解的公司。</p><p><strong>如何践行能力圈原则</strong></p><ol><li>清楚自己的状态</li><li>把自己变成行业专家</li><li>识别哪些是自己看得懂的机会（时长有时候是疯狂的，但不代表我们看不懂的东西都是疯狂的）</li></ol><p>具体而言，即：</p><ol><li>清楚自己能圈而行业知识和周期（均值回归，在股票市场上的应用，就是股价长期围绕价值中暑波动，涨多了跌，跌多了涨）</li><li>坚持一种风格</li><li>左做减法（三五个行业，十几家公司）</li><li>坚持自己的交易准则</li></ol><h2 id="完美的投资体系"><a href="#完美的投资体系" class="headerlink" title="完美的投资体系"></a>完美的投资体系</h2><ol><li>正确的方向和理念</li><li>寻找和听取能力圈公司的各种负面问题（好的公司、以及诚实的管理层非常稀缺，对于重仓持有的公司，我们尤其要挺别人的犀利观点，尤其是那些不看好的、负面的）</li></ol><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>价值投资训练营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>two sum问题(-)</title>
    <link href="/2020/01/05/two-sum(%E4%B8%80)/"/>
    <url>/2020/01/05/two-sum(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>两数之和问题，简而言之就是从数组中找到两个数的和等于某个特定的值，考察的主要思想是空间换时间。同时它还有许多变种，如三数之和、四数之和问题。</p></blockquote><h2 id="题目集合"><a href="#题目集合" class="headerlink" title="题目集合"></a>题目集合</h2><p><strong>two sum及其变种如下</strong>：</p><table><thead><tr><th align="center">题目</th><th align="center">难度等级</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/two-sum/">two sum</a></td><td align="center">easy</td><td align="center"></td></tr><tr><td align="center"><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">Two Sum II - Input array is sorted</a></td><td align="center">easy</td><td align="center"></td></tr><tr><td align="center"><a href="https://leetcode.com/problems/two-sum-iii-data-structure-design/">Two Sum III - Data structure design</a></td><td align="center">easy</td><td align="center">要订阅，暂时放弃。。。</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/subarray-sum-equals-k/">Subarray Sum Equals K</a></td><td align="center">medium</td><td align="center"></td></tr><tr><td align="center"><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/">Two Sum IV - Input is a BST</a></td><td align="center">easy</td><td align="center"></td></tr><tr><td align="center"><a href="https://leetcode.com/problems/two-sum-less-than-k/">Two Sum Less Than K</a></td><td align="center">easy</td><td align="center"></td></tr></tbody></table><h3 id="1、经典原题-two-sum"><a href="#1、经典原题-two-sum" class="headerlink" title="1、经典原题: two sum"></a>1、经典原题: two sum</h3><blockquote><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p></blockquote><p><strong>Example</strong></p><blockquote><p>Given nums = [2, 7, 11, 15], target = 9,</p><p>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p></blockquote><h4 id="解法一：暴力破解"><a href="#解法一：暴力破解" class="headerlink" title="解法一：暴力破解"></a>解法一：暴力破解</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(nums); j++ &#123;<br>            <span class="hljs-keyword">if</span> nums[i]+nums[j] == target &#123;<br>                <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;i, j&#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>runtime distribution</strong></p><blockquote><p>Runtime: 36 ms, faster than <strong>31.90%</strong> of Go online submissions for Two Sum.</p></blockquote><p><strong>memory distribution</strong></p><blockquote><p>Memory Usage: 3 MB, less than <strong>100.00%</strong> of Go online submissions for Two Sum.</p></blockquote><p><strong>思考</strong></p><blockquote><p>暴力破解是最容易想到的方法，它的时间复杂度是O(n^2)。虽然很多时候我们都对暴力解法嗤之以鼻，但是从上面的时间分布和内存分布看，优点还是很明显的，即内存消耗很小。</p><p>在计算机里面，增加内存的成本远远小于提高计算能力的成本，所以我们需要考虑如何通过空间来换时间。</p></blockquote><h4 id="解法二：哈希表法"><a href="#解法二：哈希表法" class="headerlink" title="解法二：哈希表法"></a>解法二：哈希表法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">var</span> numsMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        numsMap[nums[i]] = i<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        j, ok := numsMap[target - nums[i]]<br>        <span class="hljs-keyword">if</span> ok &amp;&amp; j != i &#123;<br>            <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;i, j&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>runtime distribution</strong></p><blockquote><p>Runtime: 4 ms, faster than <strong>95.00%</strong> of Go online submissions for Two Sum.</p></blockquote><p><strong>memory distribution</strong></p><blockquote><p>Memory Usage: 3.8 MB, less than <strong>11.54%</strong> of Go online submissions for Two Sum.</p></blockquote><p>如果把代码中numsMap的定义改成：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> numsMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(nums))<br></code></pre></td></tr></table></figure><p><strong>memory distribution</strong></p><blockquote><p>Memory Usage: 3.4 MB, less than <strong>42.31%</strong> of Go online submissions for Two Sum.</p></blockquote><p><strong>思考</strong></p><blockquote><p>暴力解法中，比较耗时的操作是第二个for循环，第二个for循环的作用是判断第二个数加第一个数是不是等于目标值，这是一个凑数的过程。如果我们反过来想，在已知第一个数的情况下，判断我们需要找的数是不是在剩下的数的集合里面，时间复杂度就变成了O(1)。</p><p>从时间分布看，超过了95%的人(说明还能继续优化)；从内存分布看，只超过了11.54%的人。但是如果在初始化numsMap的时候指定了长度，消耗的内存就会少0.4M，由此可见，Go中map类型数据指定长度初始化是有必要的。</p><p>这里面需要注意的是，如果数组中有两个元素一致，那哈西表中存的索引就是第二个元素的索引值。但是因为我们是从前往后遍历的，所以结果不影响。至于有三个及以上的元素相同的情况是不用考虑的，因为题目说只有唯一解。</p></blockquote><h4 id="解法三：哈希表法升级版"><a href="#解法三：哈希表法升级版" class="headerlink" title="解法三：哈希表法升级版"></a>解法三：哈希表法升级版</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    numsMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(nums))<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> pre, ok := numsMap[target - v]; ok &#123;<br>            <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;pre, i&#125;<br>        &#125;<br>        numsMap[v] = i<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>runtime distribution</strong></p><blockquote><p>Runtime: 4 ms, faster than <strong>95.00%</strong> of Go online submissions for Two Sum.</p></blockquote><p><strong>memory distribution</strong></p><blockquote><p>Memory Usage: 3.4 MB, less than <strong>48.08%</strong> of Go online submissions for Two Sum.</p></blockquote><p><strong>思考</strong></p><blockquote><p>解法二中，出现了两个遍历，一次是numsMap赋值的时候，一次是查找的时候。但实际上这两次是可以合并的，即一边赋值，一边查找。</p><p>至于为什么runtime排名还是小于**95%**，应该是网站的bug，时间最少的那个人的耗时是0ms，显然不可能。测试发现，如果重复提交多次，有可能出现这种情况。</p></blockquote><h3 id="2、变种一：Two-Sum-II-Input-array-is-sorted"><a href="#2、变种一：Two-Sum-II-Input-array-is-sorted" class="headerlink" title="2、变种一：Two Sum II - Input array is sorted"></a>2、变种一：Two Sum II - Input array is sorted</h3><blockquote><p>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.</p><p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</p></blockquote><p><strong>Note:</strong></p><blockquote><p>Your returned answers (both index1 and index2) are not zero-based.</p><p>You may assume that each input would have exactly one solution and you may not use the same element twice.</p></blockquote><p><strong>Examples</strong></p><blockquote><p><strong>Input:</strong> numbers = [2,7,11,15], target = 9<br><strong>Output:</strong> [1,2]<br><strong>Explanation:</strong> The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.</p></blockquote><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(numbers []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    i := <span class="hljs-number">0</span><br>    j := <span class="hljs-built_in">len</span>(numbers) - <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">for</span> i &lt; j &#123;<br>        <span class="hljs-keyword">if</span> numbers[i] + numbers[j] == target &#123;<br>            <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>&#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> numbers[i] + numbers[j] &gt; target &#123;<br>            j--<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思考</strong></p><blockquote><p>这个变种比较简单，数据按升序排好，只需要使用双指针，向中间靠拢即可</p></blockquote><h3 id="变种二：Two-Sum-IV-Input-is-a-BST"><a href="#变种二：Two-Sum-IV-Input-is-a-BST" class="headerlink" title="变种二：Two Sum IV - Input is a BST"></a>变种二：Two Sum IV - Input is a BST</h3><blockquote><p>Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.</p></blockquote><p><strong>Example:</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">Input</span>: <span class="hljs-string"></span><br>    <span class="hljs-attr">5</span><br>   <span class="hljs-meta">/</span> <span class="hljs-string">\</span><br><span class="hljs-string">  3   6</span><br> <span class="hljs-meta">/</span> <span class="hljs-string">\   \</span><br><span class="hljs-string">2   4   7</span><br><br><span class="hljs-attr">Target</span> = <span class="hljs-string">9</span><br><br><span class="hljs-attr">Output</span>: <span class="hljs-string">True</span><br></code></pre></td></tr></table></figure><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(root *TreeNode, k <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>list := printTree(root)<br>hashSet := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(list); i++ &#123;<br>except := k - list[i]<br><span class="hljs-keyword">if</span> hashSet[except] == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>        hashSet[list[i]] = <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 层序遍历</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printTree</span><span class="hljs-params">(root *TreeNode)</span> []<span class="hljs-title">int</span></span> &#123;<br>queue := <span class="hljs-built_in">make</span>([]*TreeNode, <span class="hljs-number">0</span>)<br>queue = <span class="hljs-built_in">append</span>(queue, root)<br>list := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>list = <span class="hljs-built_in">append</span>(list, queue[<span class="hljs-number">0</span>].Val)<br>left := queue[<span class="hljs-number">0</span>].Left<br>right := queue[<span class="hljs-number">0</span>].Right<br><span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, left)<br>&#125;<br><span class="hljs-keyword">if</span> right != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, right)<br>&#125;<br>queue = queue[<span class="hljs-number">1</span>:]<br>&#125;<br><span class="hljs-keyword">return</span> list<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Runtime distribution</strong></p><blockquote><p>Runtime: 24 ms, faster than 86.52% of Go online submissions for Two Sum IV - Input is a BST.</p></blockquote><p><strong>memory distribution</strong></p><blockquote><p>Memory Usage: 7.6 MB, less than 50.00% of Go online submissions for Two Sum IV - Input is a BST.</p></blockquote><p><strong>思考</strong></p><blockquote><p>通过层序遍历，将二叉搜索树转成数组，然后再通过哈希表法判断是否存在两个数的和等于目标值</p></blockquote><h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>two sum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019年个人总结</title>
    <link href="/2020/01/04/2019-review/"/>
    <url>/2020/01/04/2019-review/</url>
    
    <content type="html"><![CDATA[<p>2019年已经过去3天了，再不写个人总结，2020年怕是又要稀里糊涂的过去了。</p><p>如果给过去的这一年打个分，自认为能打到70分，算是部分满意。此外，2019年也是我从学校到工作过渡的一年，我是年初1月23号拿的毕业证，直接入职，到年底正好工作一整年。这一年，无论是工作内还是工作外，都有太多值得记录的事情。</p><h2 id="回顾2019年初的目标"><a href="#回顾2019年初的目标" class="headerlink" title="回顾2019年初的目标"></a>回顾2019年初的目标</h2><hr><p>大方向上，主要有下面几个：</p><ul><li>给自己和家人配置保险</li><li>开始自己的投资规划</li><li>学英语（这算是一个执念吧）</li><li>练字</li><li>提高自己的专业技能</li></ul><h3 id="给自己和家人配置保险"><a href="#给自己和家人配置保险" class="headerlink" title="给自己和家人配置保险"></a>给自己和家人配置保险</h3><p>一直以来就对保险充满了好感，觉得没有保险的人生是没有安全感的。对保险有好感的原因比较多，首先，我这个人比较怕死。这么多年，无论是亲身经历的，还是从电视新闻上看到的一些和生死相关的事情，都让我对死亡充满了敬畏。很多时候，生命远比我们想象的要脆弱。而保险，能让生命在最脆弱的时候，保留一份基本的尊严；其次是刚买房，家里也没什么积蓄，爸妈年纪都大了，我才刚开始工作，整个家庭的风险承受能力很低。所以，刚工作不到两个月，我就开始不断的看保险相关的知识，比对不同的保险。看的焦头烂额的时候，正好实验室的一个师姐也在了解保险，她的一个高中同学就是大都会的保险代理人。这期间通过这个代理人，了解了医疗险和重疾险的区别，再结合自身的实际情况，配置了如下的保险：</p><p><strong>自己</strong>：医疗险+重疾险+恶性肿瘤医疗险（全球版）<br><strong>媳妇</strong>：医疗险+重疾险<br><strong>父母</strong>：好医保-住院医疗险</p><p>医疗险是现在比较火的百万医疗险，报销型，保额足够了。重疾险是一份终身10万保额叠加20年期40万保额，一共50万保额。由于实在是担心自己得癌症，自己又加了一份恶性肿瘤医疗险（全球版），两个人全年保费8000左右。父母因为已经到51周岁，年级大了，不适合买重疾险，就再支付宝上买了好医保-住院医疗险，两个人全年保费1500左右。大都会的保险相比其他家的是偏贵了，之所以还选择他们家，是因为保险附带的增值服务比较多。</p><p>因为刚开始工作，也没什么积蓄，暂时就先配置这些年，短期内不再变动。等以后收入增加了，再把重疾险的额度配置上去。</p><h3 id="开始自己的投资规划"><a href="#开始自己的投资规划" class="headerlink" title="开始自己的投资规划"></a>开始自己的投资规划</h3><p>年初的时候看了不少公众号文章，都在宣传躺着赚钱，财务自由这些让人心里痒痒的观点，再加上之前自己胡乱投资基金、p2p这些，狠狠的踩了几趟雷，决定系统的开始自己的投资之路，万一走着走着就自由了呢？</p><p>我的投资学习路径是两部分：</p><ul><li><strong>理论学习</strong></li><li><strong>投资实践</strong></li></ul><p><strong>理论学习</strong>方面，主要包括财富观的培养、投资基础知识的学习。这一年，完成了以下书籍：</p><ul><li>傻瓜式投资</li><li>穷爸爸和富爸爸</li><li>小狗钱钱</li><li>指数基金投资指南</li><li>解读基金：我的投资观与实践</li><li>漫步华尔街</li></ul><p>未完成书籍：</p><ul><li>聪明的投资者</li><li>共同基金常识</li><li>逃不开的经济周期</li></ul><p>这几本书比较硬核，看的比较慢，2020年继续。</p><p><strong>投资实践</strong>方面，从抄作业开始，跟投E大的长赢计划，中途配置了教育基金和自己的养老基金，主要定投沪深300和中证500这两个指数基金。</p><p>2019年收益率16%左右，基本是抄作业的功劳，比较满意，所以已有部分继续跟投，同时继续完善理论知识，完成自己的投资体系的建立，然后实现躺尸的同时，躺赢，哈哈~~</p><h3 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h3><p>这部分进行的一般。由于工作上的变动，从算法转到了开发，自然语言处理和机器学习的学习就彻底搁置了下来。后端开发能力上，跟着业务，狠狠的补了下基础知识。主要的能力提升是对后端开发有了一个整体的认识：后端开发围绕的是数据的存储和在业务逻辑上的处理。</p><p>关于后端开发知识，主要的提升在对nginx的了解、redis的了解上，其它的一些提升比较零碎，不成体系。</p><h3 id="学英语"><a href="#学英语" class="headerlink" title="学英语"></a>学英语</h3><p>学英语是一直以来的执念，也没有什么具体的目标，就是想学，但是每次都是半途而废。</p><p>19年，在水滴上完成了《人性的弱点》和《人性的优点》两本英文原著的半精读，其它就没有了。</p><p>20年需要好好梳理下学英语到底是为了什么，需要达到一个什么样的目标，然后再重新定个计划，好好执行。</p><h3 id="练字"><a href="#练字" class="headerlink" title="练字"></a>练字</h3><p>想练一手好字。。。19年一直处于想的状态。20年需要定个轻松易行的计划，争取每年提高一些。</p><p>以上是19年年初规划的完成情况，整体看，喜忧参半。家庭规划上的完成情况比较满意，但是技能提升相关的规划完成度较差，这部分需要重新梳理一遍，并且制定出一个松紧有度的20年年度计划，希望20年结束的时候，能够完美的交出一份对的起自己的答卷。</p><h2 id="2019年感触比较深的几件事"><a href="#2019年感触比较深的几件事" class="headerlink" title="2019年感触比较深的几件事"></a>2019年感触比较深的几件事</h2><hr><h3 id="人生大事"><a href="#人生大事" class="headerlink" title="人生大事"></a>人生大事</h3><p>人生大事方面，完成了买房和领证。</p><h4 id="买房"><a href="#买房" class="headerlink" title="买房"></a>买房</h4><p>媳妇还在上学，之前研究生入学的时候，没有意识到户口的重要性，就没有把户口转到学校，幸好18年政策变化，除了入学那一次可以迁户口，每年秋季开学也可以迁户口了，就赶紧办理，到19年初户口就下来了。户口下来之后，迅速的把房子给买了。现在回想买房的过程，觉得有点太草率了，有必要记录一下买房的过程，让自己在以后做类似买房这种重大决定的时候，不要被情绪左右。</p><p>决定买房之前，和媳妇讨论要买什么样的房子，为了能买到预算范围内最合适的房子，我们首先列出了一系列的考虑因素，最终决定重点看<code>交通</code>，<code>医疗资源</code>，<code>菜市场</code>，<code>公园</code>，<code>商业配套</code> 这几个因素，由于我们都还年轻，再加上预算只有200左右（主要原因），就没有考虑学区房。交通方面，主要是地铁，所以我们以地铁线为基准，列出地铁线上每一站附近的<code>医院</code>，<code>商业配套</code>，<code>公园</code>，<code>学校</code>以及附近<code>房价</code>等情况，并以此筛选出候选站点。我们花了2个星期左右的时间，统计了1、2、3、4、5、6、9这几条地铁线，标出了一些候选，并决定每周末考察两个地铁站。</p><p>在4月初的一个周末，我们开始了考察。首先去的是1号线终点附近的几个站点，找了链家的一个中介，带着我们看了附近的几个小区，整体看下来，这一片都是居民区，小区质量一般，配套还行，生活气息浓厚，商业气息差了些，不太满意。晚上临走的时候中介推荐了5号线附近一个新开的楼盘，说是性价比很高，强烈建议我们去看看。我们其实是不太想去的，一是当时有点晚，二是本身也不着急，奈何中介极力推荐，就说第二天去看看。</p><blockquote><p>我们常常在小钱上斤斤计较，如买菜和买衣服，而在大钱上冲动无比，如买房</p></blockquote><p>第二天跟着中介到了售楼处，好家伙，里面人声鼎沸，导购介绍和签合同的场景到处都是。在经过了导购员的讲解之后，对楼盘有了个整体印象。一共是两个小区，一大一小，大的小区靠着一个正在建的永旺商场，小的隔的远了些，靠着一个正在建的市民广场。附近就是外环和高速入口，地铁站1公里左右。交通不错，商业配套和生活配套也不错，缺点是都在规划中。价格和预算一致。两个人都比较满意，这个时候导购一直在强调，最近三天搞活动，预付定金，给2个点优惠。两个人都没啥定力，被导购这么一说，再加上对房子确实很满意，都开始犹豫要不要先交定金。和家里商量了下（家里没意见，也都不懂，说只要我们觉得满意就行，唉。。。），又咨询了一个在德佑的亲戚的意见，觉得还行，两个人就在晕乎乎的情况下，交定金了。</p><p>晚上回去后，两个人都觉得草率了，但是因为本身对房子比较满意，没有发现什么地方有问题，就商量着真正交首付的时候，一定要仔细的比对合同，同时问明白一些关键指标，如果有什么地方不行，哪怕定金要不回来也不能买。付首付的时候，果然还是出问题了。一是我们发现这个房子没有阳台。当时看房型的时候，都觉得房型很好，方方正正，南北通透，愣是把阳台给漏了。二是问了下公摊，这一问，才知道公摊高达35%，105的房子套内面积才70，瞬间不想定了。后来和在德佑的那个亲戚沟通，他说这个公摊确实是很高了，但是套内面积70的三居也还行，其实套内面积差个2平米根本就感觉不出来。他这么一说，再加上内心清楚，这个房子吸引我的地方有很大一部分原因是旁边正在规划的市民广场，市民广场的规划里面有图书馆，电影院等，这个实在太吸引我了。所以和媳妇商量了好一会，犹豫再三，最终还是付了首付。</p><p>进入2020年，回过头来看，买的房子单价降了近2000，市民广场的规划发生变动，广场的一半改成商业配套。房价下降这件事情，4月份其实是有预期的，当时看了很多文章，都在说19年的政策是强调房住不炒，而且目前国家经济处于转型的过程中，经济形式不好，未来一段时间内房价肯定会下跌，所以买房不用着急，但是并没深入的去研究论据，自己只是表面相信，所以在售楼处导购员反复推销的时候，我是如此的不堪一击；另外有一个观点是如果是刚需，随时可以上车。因为4月份的房价相比18年的顶点是降了不少的。现在想来，刚需随时可以上车这句话是理解错了。对当时的自己而言，其实买房并不是刚需，媳妇21年夏天才毕业，我在北京工作，我们暂时是没有住房需求的。市民广场规划发生变化这件事，就是买期房的风险了，幸好规划变化还能接受，希望未来没有大的变动。</p><h4 id="领证"><a href="#领证" class="headerlink" title="领证"></a>领证</h4><p>因为买房用的是媳妇的户口，还贷款是我，加上父母不可能同意只以媳妇的名义买房，所以两个人就需要在签贷款合同前领证。由于买房这个决策太突然，导致领证这件事也变的很赶。两个人匆匆忙忙的去拍了结婚照，又急急忙忙的去民政局领了证。</p><p>领证的当天，早上8点多就到了民政局。时间比较早，有点冷清，交了材料后，等了一小会，就轮到我们了。填了些材料，不一会，鲜红的两个结婚证就出来了。两个人拿到结婚证后，坐在沙发上缓了好一会，都觉得有点不真实。但因为下午还要赶紧去办贷款，缓过来之后又急急忙忙的去了售楼处。领证的过程就这么匆忙的结束了，都没来的及吃顿饭庆祝一下。</p><p>回想起和媳妇相处的这几年，除了最开始的一年里面摩擦较多，后来磨合的越来越好，也不知当初两个人怎么就互相认定了。随着时间的推移，越发能体会到媳妇的好，也越发为自己当时的眼光感到得意。</p><p>希望接下来的日子里，两个人能走的越来越好，把我们的小日子过的有滋有味。</p><h3 id="工作波折"><a href="#工作波折" class="headerlink" title="工作波折"></a>工作波折</h3><h4 id="部门变动和线上事故"><a href="#部门变动和线上事故" class="headerlink" title="部门变动和线上事故"></a>部门变动和线上事故</h4><p>18年底到19年中这段时间，从实习转成了正式。这段时间里面，先是最初的业务被停掉，换了新业务，之后是部门换掉，从大搜到了手百，再就是经理也换了。中间由于各种原因，指导人换了又换，我也从最初的算法转到了开发。</p><p>换到新部门和新业务期间，指导人被重新指定。这段时间里，我刚接手的项目对当时的我来说，难度系数较高。开发的过程中，费了很大劲才能勉强跟上进度。中间有个任务，因为一些原因，需要迁移。由于开始没有能和指导人C有一个比较好的沟通，设计方案做的比较差，线上运行的时候，出了严重的事故。</p><p>之后复盘过程中，C不断的指出方案上的不足，告诉我哪些地方需要多加注意，代码评审的时候，也是一行行的过代码，前后评审10多次。短短的几天内，我学到了很多，也很感激。</p><p>后来C由于个人发展上的考虑，去了部门内的其他组。我的指导人也从C变成了组内的S。偶尔会想，如果开始的时候，C就能像最后那样，我是不是就不会经历后来的转正风波，当然也就不会迅速认识到工作和学校学习的不同和及时适应身份上的一个转变。凭良心说，C的业务能力很强，人品也没问题，可能是我的性格和他实在不搭，再加上初期的自己确实也有一些问题，导致两个人没能沟通好，这一点比较遗憾。</p><h4 id="转正风波"><a href="#转正风波" class="headerlink" title="转正风波"></a>转正风波</h4><p>由于指导人C给的评价不好，给新经理留下一个很差的印象。试用期过了一大半的时候，新的指导人S通知我说我的转正比较危险，让我做好心里准备。当时听到这个，心里顿时一沉。指导人S说他也是第一次遇到这种事情，也不知道怎么处理，建议我做两手准备，而他接下来也会尽量把任务分给我一些，希望我能多一些产出。</p><p>后来我主动找经理沟通了下我当前的状态，经理指出了我身上的一些不足，并且说给我一个月左右的观察期，同时指定了一些任务指标，希望我好好表现。这一个月里面，刚好业务上特别忙，又要准备那些任务指标，压力很大。天天晚上都是11点、12多才回去。工作日没有时间完成那些任务指标，只能周六日来弄。</p><p>这期间十分感谢指导人S的尽心指导，使得我的业务能力有了很大的提高，从而顺利的通过了转正，以后有机会一定要好好的感谢他；也非常感谢媳妇，在这段时间里面没有给我任何压力，并且不断的鼓励我，让我没有其它的后顾之忧。</p><p>转正风波这段期间，虽然说是压力很大，但是也仅此而已。首先是我和媳妇的感情很稳定，其次是虽然有房贷，但是两个人手上有一些钱足够支撑一年，经济上也没有太大压力，再次家里也很和谐。可以说这几个因素是我能顺利通过转正的坚实基础。</p><p>工作上的这两件事给刚出学校我很大的冲击，让我迅速的认识到学校学习和社会工作的不同，及时调整自己，同时尽早开始思考自己的人生规划，为将来做准备。可以说是因祸得福。希望以后的自己能不断的提高，能自信的面对任何变化，让自己成为家人坚实的依靠。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><hr><p>2019年已经过去，这一年无论发生了什么，都变成了过去时，只有成长留了下来。人生短暂，希望接下来的日子里，能和时间做朋友，在未来，成为更好的自己！</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>年度总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>证券投资的本质</title>
    <link href="/2019/07/07/%E8%AF%81%E5%88%B8%E6%8A%95%E8%B5%84%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <url>/2019/07/07/%E8%AF%81%E5%88%B8%E6%8A%95%E8%B5%84%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="A股是赌场吗？"><a href="#A股是赌场吗？" class="headerlink" title="A股是赌场吗？"></a>A股是赌场吗？</h3><p>不同的想法和理念代入到交易中，就有不同的反馈。</p><blockquote><p>资本市场是一个高度复杂的生态系统，所以从不同的角度观察，就会有不同的看法</p></blockquote><h4 id="如果把A股看成赌场"><a href="#如果把A股看成赌场" class="headerlink" title="如果把A股看成赌场"></a>如果把A股看成赌场</h4><p>赌场有个显著的特点：总价值不变，有赢就有输。</p><p>如果把A股看成赌场，双方博弈的对象就是股票的价格，看涨的买入，看跌的卖出。</p><p>如果把A股看成赌场，A股有80%的公司都是没有价值的公司(牌本身没有价值，只有在比大小的时候才有相对价值。所以公司是没有价值的，猜股票的涨跌才是有价值的。当然还是有20%的公司无法忽略，他就是有价值的）</p><p>不建议用赌场的观念看待A股：垃圾股的估值整体处在一个向下回归的过程中，这时候进行纯粹的博弈就不行了。</p><h4 id="如果认为A股不是赌场"><a href="#如果认为A股不是赌场" class="headerlink" title="如果认为A股不是赌场"></a>如果认为A股不是赌场</h4><p>A股依然有很多公司在为投资者创造价值。那么可以通过分享上市公司的增长获得价值的增值。</p><h3 id="格雷厄姆的看法"><a href="#格雷厄姆的看法" class="headerlink" title="格雷厄姆的看法"></a>格雷厄姆的看法</h3><p>投资是一种通过认真分析研究，有希望保本和获得满意收益的行为，不满足这些条件的行为就是投机。</p><h4 id="内在价值"><a href="#内在价值" class="headerlink" title="内在价值"></a>内在价值</h4><p>要根据公司的内在价值来投资，而不是根据市场的波动来投资。股票应该是公司的部分所有权，而不应该是日常价格变动的证明。</p><p>证券投资, 买的是企业所有权的一部分，买的是企业未来盈利的一部分。</p><p>内在价值不能简单的看做是公司的资产总额减去负债总额，还包括这些资产未来所能产生的收益。</p><h4 id="市场先生"><a href="#市场先生" class="headerlink" title="市场先生"></a>市场先生</h4><p>市场先生如果过于乐观，就会报出一个特别高的价格，如果过于悲观，就会报出一个特别低的价格。</p><p>市场先生从不害怕无人理会，如果今天他的报价无人理会，那么明天，他就会报出一个更低的价格。相反，如果理会的人太多，那么第二天，他就会报出一个更高的价格。</p><p>市场先生的情绪越是狂躁抑郁，对你越有利。如果你的情绪受到他的左右，那么后果不堪设想。</p><p>对我们有用的，是市场先生口袋里的报价单，而不是他的智慧。如果你不能确定远比市场先生更了解而且更能估价你的企业，那么你就没有资格玩这个游戏。</p><p><em>格雷厄姆的选股方法：三分之二市净率和低市盈率，倾向于找便宜的公司</em><br><em>需要注意这种方法的时代背景：1929年的大萧条，便宜的公司遍地都是</em></p><h4 id="安全边际"><a href="#安全边际" class="headerlink" title="安全边际"></a>安全边际</h4><p>投资者应该在他愿意付出的价格和他估计出的股票价值之间保持一个较大的差价，这个差价就叫做安全边际。</p><h3 id="巴菲特对格雷厄姆价值投资理论的发展"><a href="#巴菲特对格雷厄姆价值投资理论的发展" class="headerlink" title="巴菲特对格雷厄姆价值投资理论的发展"></a>巴菲特对格雷厄姆价值投资理论的发展</h3><h4 id="继承部分"><a href="#继承部分" class="headerlink" title="继承部分"></a>继承部分</h4><ul><li>持有股票即持有公司</li><li>投资和投机的定义和区别</li><li>市场先生</li><li>安全边际</li><li>各种套利方法和捡烟蒂理论</li></ul><h4 id="抛弃部分"><a href="#抛弃部分" class="headerlink" title="抛弃部分"></a>抛弃部分</h4><ul><li>55股债平衡理论</li><li>用市净率和市盈率等简单指标去买一堆看似便宜的公司</li><li>只依据财报看资产价值而不看未来价值</li></ul><h4 id="发展部分"><a href="#发展部分" class="headerlink" title="发展部分"></a>发展部分</h4><ul><li>护城河、能力圈、管理层等结合概率思维预测公司前景的准确性</li><li>好公司普通价格优于普通公司好价格</li><li>按机会成本行事</li><li>内在价值等于未来现金流折现</li><li>伯克希尔模式，充分发挥资本的边际效应</li><li>利用保险公司的低成本</li></ul><p><em>巴菲特的看法：价格公道的伟大企业要比价格低廉的普通企业要好得多</em></p><h3 id="几种定义方式和理解"><a href="#几种定义方式和理解" class="headerlink" title="几种定义方式和理解"></a>几种定义方式和理解</h3><p>价格低于价值情况，所有的投资都应该叫做价值投资</p><p>相对于成长股而言，买的公司要有相应的资产，利润，和现金流，而不是靠未来成长的可能性来支撑起价值。（更为现在的投资者所接受）</p><p>价值投资是资产管理者的信仰，趋势交易等理念更多的是作为一种投资工具在使用。择时已经被成熟的市场所抛弃，大量产品禁止择时。</p><p>在中国，价值投资的便签已经被滥用。有人股票被套了，就说自己是长期持有，价值投资；有人买了消费股，买了大蓝筹，大盘股，行业龙头，就说自己是价值投资；有人认为，只有买低市盈率、市净率的股票才是价值投资。</p><p>一种观点：是不是价值投资，重点看投资回报的来源是哪？如果是企业的持续盈利增长，投资人去分享红利，这才是价值投资的方式，才是基于基本面的投资.</p><h4 id="涉及到的一些概念"><a href="#涉及到的一些概念" class="headerlink" title="涉及到的一些概念"></a>涉及到的一些概念</h4><ul><li>低估值、高回报<ul><li>价值投资不等于长期持有，</li></ul></li><li>短、中、长期的有趣定义<ul><li>用时间划分长短没错，但是没有意义，持有期限是结果，不是目的，要根据操作内涵来理解</li><li>短线就是尊重市场，顺势而为，重点是不亏损，盈利没有要求</li><li>中线需要对基本面有很高的掌握，对价格估值系统有充分的认识，他的标的物是那些经营相对稳定，没有大起大落的企业，讲究的是低买高卖，预期盈利目标到20%才可入场，8%的止损位</li><li>长线的要求最高，要求对企业有很深的认识，对自己有严格的控制，清楚把握企业未来发展的趋势，以投资的心态分享企业未来的成长。他的投资标的物是千里挑一，他对利润的要求是数以十倍计，在这样的机会面前，他不会惧怕任何亏损，不会设置除基本面以外的任何止损指标</li></ul></li><li>看长做短<ul><li>A股由于波动较大，常常3个月把三年的涨幅都涨完，这种情况就大大透支了企业的基本面，这种时候就需要及时兑现利润。适合A股的一种策略就是看长做短，但是这个短一定是作为结果，而不是作为目的。看长的意思是，你买入的行业或者板块，一定要有一年以上，偏中长期的投资逻辑，而不能是仅仅几个月的利好，持有计划应该是一年以上，做短是如果短期上涨太快，要注意止盈。</li></ul></li></ul><p><strong>仅以时间作为策略区分标准的一定会走入误区，决定策略的仅应该是股票本身的不同和投资者自身的素质</strong></p><h3 id="理论基础的重要性"><a href="#理论基础的重要性" class="headerlink" title="理论基础的重要性"></a>理论基础的重要性</h3><pre><code>1. 价值投资：知和行的关系2. 胜者为王，宁可错过，不要做错3. 做好价值投资，保持健康</code></pre><p><strong>投资是艺术，不是科学</strong></p><p><strong><a href="https://pc-shop.xiaoe-tech.com/appCRApuVG28915/video_details?id=v_5c4142617c5d9_e6jBxu1Y">视频地址</a></strong> </p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>价值投资训练营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>https升级教程</title>
    <link href="/2019/06/26/https%E5%8D%87%E7%BA%A7%E6%95%99%E7%A8%8B/"/>
    <url>/2019/06/26/https%E5%8D%87%E7%BA%A7%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="升级前准备"><a href="#升级前准备" class="headerlink" title="升级前准备"></a>升级前准备</h2><p>上一章详细讲解了https的原理之后，本章节将以本博客为对象，实践https升级。</p><p><strong>升级准备工作</strong></p><ol><li>CA 选择： <a href="https://letsencrypt.org/">Let’s Encrypt</a></li><li>安装工具选择：<a href="https://certbot.eff.org/">certbot</a></li><li>实践对象：本博客: <a href="www.tjjsjwhj.me">www.tjjsjwhj.me</a></li><li>博客托管的vps配置：<ol><li>OS：CentOs 6, x86_64</li><li>RAM: 0.5G</li></ol></li><li>确保有ssh权限，即能通过ssh远程访问你的web host</li></ol><p><strong><a href="https://letsencrypt.org/">Let’s Encrypt</a>是电子前哨基金会EFF为了推广https协议，提供的免费的、自动化的和开放的CA(Certificate Authority)。<a href="https://letsencrypt.org/">Let’s Encrypt</a>的一个贡献是ACME协议，ACME协议旨在确保域名验证、发布和管理方法是完全自动化、一致、符合合规性和安全的。</strong></p><p>**支持ACME协议的工具有很多(<a href="https://letsencrypt.org/docs/client-options/)%EF%BC%8C%E6%9C%AC%E6%96%87%E9%80%89%E6%8B%A9%E7%9A%84%E6%8E%A8%E8%8D%90%E7%9A%84[certbot](https://certbot.eff.org/)**%E3%80%82">https://letsencrypt.org/docs/client-options/)，本文选择的推荐的[certbot](https://certbot.eff.org/)**。</a></p><h2 id="升级教程"><a href="#升级教程" class="headerlink" title="升级教程"></a>升级教程</h2><p><strong>首先，进入<a href="https://certbot.eff.org/">certbot</a>网站，选择对应的web服务器软件（nginx，apache等）和操作系统版本（CentOs 6）,网站会给出对应的操作指令</strong></p><p><strong>1. 获取cerbot执行脚本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://dl.eff.org/certbot-auto<br></code></pre></td></tr></table></figure><p><code>certbot-auto</code> 实际上是一个shell执行脚本</p><p><strong>2. 放到习惯的路径下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mv certbot-auto /usr/<span class="hljs-built_in">local</span>/bin/certbot-auto<br></code></pre></td></tr></table></figure><p><strong>3. 修改执行脚本的所有者</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo chown root /usr/<span class="hljs-built_in">local</span>/bin/certbot-auto<br></code></pre></td></tr></table></figure><p>由于certbot需要验证你就是改域名的持有者，所以3、4两步都需要在root权限下进行</p><p><strong>4. 修改执行脚本的权限</strong><br><code>sudo chmod 0755 /usr/local/bin/certbot-auto</code></p><p><strong>5. 自动获取证书，同时修改nginx配置文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo /usr/<span class="hljs-built_in">local</span>/bin/certbot --nginx --nginx-server-root=/usr/<span class="hljs-built_in">local</span>/nginx/conf<br></code></pre></td></tr></table></figure><p>这里有个坑，网站给出的命令是 <code>sudo /usr/local/bin/certbot --nginx</code>，这条命令默认ngxin安装在/etc/nginx，所以有可能会报错：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">nginx: [emerg] <span class="hljs-keyword">open</span>() <span class="hljs-string">&quot;/etc/nginx/nginx.conf&quot;</span> failed (2: <span class="hljs-keyword">No</span> such <span class="hljs-keyword">file</span> or directory)<br>nginx: configuration <span class="hljs-keyword">file</span> /etc/nginx/nginx.<span class="hljs-keyword">conf</span> <span class="hljs-keyword">test</span> failed<br></code></pre></td></tr></table></figure><p>所以需要用 <code>--nginx-server-root</code> 指定nginx.conf的路径</p><p>接下来的操作，按照提示操作即可。</p><p><strong>6、添加定时任务</strong><br><a href="https://letsencrypt.org/">Let’s Encrypt</a>证书的有效期是90天，90天之后就需要重新更新证书，因此需要设置一个定时任务自动更新证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;0 0,12 * * * root python -c &#x27;import random; import time; time.sleep(random.random() * 3600)&#x27; &amp;&amp; /usr/local/bin/certbot-auto renew&quot;</span> | sudo tee -a /etc/crontab &gt; /dev/null<br></code></pre></td></tr></table></figure><p>上面这行命令是网站提供的，意思是每天12点和0点自动更新证书。至于为什么需要time.sleep(random.random() * 3600)，猜测是为了让大家错开时间，降低证书请求的压力</p><p><strong>相关配置文件</strong><br>新的配置文件目录, 同之前的nginx.conf目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/<span class="hljs-built_in">local</span>/nginx/conf/vhost/<br></code></pre></td></tr></table></figure><p>证书目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/etc/letsencrypt/<br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html">HTTPS 升级指南</a></p><p><a href="https://zhuanlan.zhihu.com/p/29507417">Linux下使用acme.sh申请和管理Let’s Encrypt证书</a></p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>https原理</title>
    <link href="/2019/06/05/https%E5%8E%9F%E7%90%86/"/>
    <url>/2019/06/05/https%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="1、为什么要有https？"><a href="#1、为什么要有https？" class="headerlink" title="1、为什么要有https？"></a>1、为什么要有https？</h3><p>http协议被用于客户端和服务端之间传递消息，但是这个传输过程是以明文的方式发送内容，http协议不提供任何方式的数据加密。如果有人获取了浏览器和服务器之间的传输保报文，就可以直接读取其中的信息。因此，http协议不适合传输一些个人敏感信息，比如：个人账户密码、支付信息等。</p><p>由于http协议的安全缺陷，需要有一种协议来保证客户端和服务端通信的安全，于是就有了https。</p><h3 id="2、https主要解决了什么问题？"><a href="#2、https主要解决了什么问题？" class="headerlink" title="2、https主要解决了什么问题？"></a>2、https主要解决了什么问题？</h3><p><strong>i. 确保你想访问的对象是你希望访问的对象</strong></p><p>网络世界里，真正决定你地址的是IP。平时我们所访问的网址如 <code>www.baidu.com</code> 都需要由DNS（域名转换系统）服务商将网址翻译成对应的IP地址，也就是说我们要访问的对象实际上是一个IP地址。如果中间网址到域名的转换关系被恶意的修改（也就是DNS劫持），我们的访问请求就会打到修改之后的恶意IP上，</p><p>https首先解决了身份认证的问题，即确保你要访问的对象就是你希望访问的对象。现实生活中，如果我们和某个人A交易，为了确保交易的安全性，首先需要确认A的身份。通常我们会检查A的身份证信息，资质信息等。确认了A的身份之后，我们才开始与对方交易。</p><p>https的身份认证过程也是如此。Server端上线之初，会向权威的第三方的CA（Certificate Authority, 证书颁发机构）申请证书，然后第三方会通过线上线下核查的方式确认Server的信息，核查完之后，会给Server颁发一个证书，这个证书中记录了颁发机构的信息和Server的身份信息。</p><p>初次请求https的时候，服务端首先会返回一个证书，这个证书中包含了访问对象的身份信息，客户端验证了证书之后发现，证书中的信息就是访问对象的信息，接下来就可以正常通信了。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B.png" alt="认证过程"></p><p>有的同学可能会有疑惑，如果我伪造一个证书，客户端怎么知道呢？比如我是A，但我非要在证书里写我是B，那你怎么知道呢，就像现实中伪造的各种证书一样？CA颁发的证书有个特性是不可修改。这个涉及到非对称加密的知识了，简单来说就是CA把公司的信息通过特定的摘要算法如MD5生成一段签名，再用私钥对签名进行加密。客户端拿到证书之后，根据证书中的摘要算法对证书中的信息计算出一个签名，然后用CA的公钥对密文进行解密，对比计算出的签名和解密出的签名，如果一致，就证明证书没有被修改过。</p><p>下面是 <code>www.baidu.com</code>的证书信息（谷歌浏览器点地址栏的那个小锁）：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/baidu_https_cert.png" alt="百度的证书"></p><p>从图中可以看到百度相关的信息，签发者相关的信息，签名算法（这里的签名算法是SHA-256）以及百度的公钥。</p><p><strong>ii. 确保通过过程中的数据安全</strong></p><p>解决了如何证明你就是你的问题之后，就需要解决如何保证通信过程中你们的通信内容不被窃取到。</p><p>还是刚刚那个交易场景。你确认了和你交易的A的身份之后，你们开始放心的交易了。如果你们的交易内容是你想花大价钱从A受手里买一个产品的配方，有了这个配方之后，你就能财源滚滚，走上人生巅峰了，所以这个配方千万不能泄露出去。为了和网络通信的过程保持一致，我们假设你们不直接交易，而是需要一个传信的人帮你们传递这个配方。在原来http的协议下，这个配方就是明文传输的，如果有人劫持了这个信件就能获取到这个配方。所以就不能明文传递这个配方，得加密。那加密方式怎么选择呢？</p><blockquote><p>对称加密：对称加密指的的是采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密<br>非对称加密：非对称加密算法是一种密钥的保密方法。 非对称加密算法需要两个密钥：公开密钥（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。 公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。</p></blockquote><p>考虑到为了模拟真实的通信过程，你们是不能见面的，也就是说你不能通过耳语把你要用的密钥告诉A，所以你们否决了开始就用对称加密的方式，因为怎么把密钥传给对方是个问题。如果在传输密钥的过程中密钥泄露了，这就和明文传输配方没什么区别了。所以如何把密钥传给A？传输过程有以下几步：</p><ol><li>首先生成用于对称加密的密钥s</li><li>利用证书中A传过来的公钥，对密钥s进行加密，传给A</li><li>A利用自己的私钥，对传过来的密文进行解密，解密出密钥s</li><li>接下来双方通过密钥s来加密通信内容，互相传输</li></ol><p>再回到https的通信过程中，具体流程如下图所示：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/https_communication.png" alt="https通信过程"></p><p><strong>以上就是https原理的简介。至于如何从http升级到https，下一篇将以本博客为例，示范升级过程。</strong></p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
