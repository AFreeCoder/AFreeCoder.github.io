<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>财务自由实证#26——高层火灾如何逃生？</title>
    <link href="/2022/12/06/invest-practice-26/"/>
    <url>/2022/12/06/invest-practice-26/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a></p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气地把生命浪费在更“美好”的事物上。</p><p><strong>道阻且长，行则将至，行而不辍，未来可期！</strong></p><h2 id="1、实证进展"><a href="#1、实证进展" class="headerlink" title="1、实证进展"></a>1、实证进展</h2><h3 id="1-1-本月操作"><a href="#1-1-本月操作" class="headerlink" title="1.1 本月操作"></a>1.1 本月操作</h3><p>11 月投入 7000，操作情况如下：</p><ul><li>长赢等跟投组合：1700</li><li>主动基金组合：3000</li></ul><p><em>注：未投出部分进入现金账户。</em></p><h3 id="1-2-本月进展"><a href="#1-2-本月进展" class="headerlink" title="1.2 本月进展"></a>1.2 本月进展</h3><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/12/06/img4834.PNG" alt="IMG_4834"></p><p>当前进展 6.16%，相比上个月上升 0.93%。虽然累计收益仍然为负，但是实证账户资产终于迈上了30大关，也是一个小小的里程碑。</p><h2 id="2、高层火灾如何逃生？"><a href="#2、高层火灾如何逃生？" class="headerlink" title="2、高层火灾如何逃生？"></a>2、高层火灾如何逃生？</h2><p>从接触财务自由的概念以来，对风险的认识越来越深刻，所以逐渐配置了各种保险，从医疗到重疾险，从寿险到意外险，以及家财险，哪怕是车险，三者和驾乘的配置额度也远高于常规水平。</p><p>但是所有的保险都只是事后保障，自乌鲁木齐火灾事件发生以来，我意识到我在事前预防上花费的精力还是太少。</p><p>11 月 24 日晚 19 时 49 分，乌鲁木齐一小区高层住宅楼发生火灾，造成 10 人死亡，9 人受伤。</p><p>时代的一粒灰尘，落到个人头上，不是一座山，是一座坟。</p><p>几年、甚至几十年后，这次的火灾事故在历史中能留下多少只言片语都未可知，但是对事故中的伤亡者家属，却是一生都绕不过去的悲痛。</p><p>所以本篇文章借着乌鲁木齐的火灾来梳理一下消防安全知识，梳理一下高层火灾如何逃生。</p><p><em>注：也大之前推荐了一个模拟财务自由之后生活状态的网站（egaging-data.com）。按照每年提取 4% 本金的方式模拟，退休之后，<strong>任何一个年龄段死亡的概率都远远高于破产的概率</strong>。</em></p><h3 id="2-1-火灾致死第一真凶：浓烟！"><a href="#2-1-火灾致死第一真凶：浓烟！" class="headerlink" title="2.1 火灾致死第一真凶：浓烟！"></a>2.1 火灾致死第一真凶：浓烟！</h3><p>和大家直觉不太相符的是，火灾致死第一真凶是<strong>浓烟</strong>（有毒烟气+缺氧）。</p><p>我们看新华社对乌鲁木齐火灾的报道：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/12/06/16698210754905.jpg" alt=""></p><p>注意红色框框圈出来的描述：<strong>伤者均因吸入有毒烟气紧急送往医院救治！</strong>。此外根据应急管理部消防救援局科普文章，火灾死亡人数当中，高达 80% 是因为吸入有毒烟气[1]。</p><p>现代高层建筑，钢筋混凝土结构为主。钢筋混凝土的防火性能毋庸置疑。所以很多时候我们更需要小心的是浓烟和有毒气体。</p><p>消防上有个名词叫<strong>“烟囱效应”</strong>：</p><blockquote><p>烟囱效应，指户内空气利用热压差，沿着有垂直坡度的空间向上升或下降，造成空气加强对流的现象。有资料显示，烟气在竖向管井内的垂直扩散速度为3-4m/s，意味着高度为 100m 的高层建筑，烟火由底层直接窜至顶层只需 30s 左右。</p></blockquote><p>高层建筑中能形成烟囱的地方很多，比如排烟道、电梯井、管道井、楼梯间等。这也是为什么低楼层着火浓烟能很快蔓延至一整楼，甚至引起高层二次火灾的原因。</p><p>所以火灾逃生过程中最重要的一条就是防烟。如果躲在室内，要注意关好门窗把门缝等用湿毛毯堵上，戴好防烟面罩；如果往外跑，更要戴好防烟面罩，注意弯腰甚至贴地跑，切忌乘坐电梯。</p><p><em>注：为什么一般宣传用湿毛巾捂鼻？因为知道大家不会准备防烟面罩，所以干脆宣传湿毛巾。另外，即使是湿毛巾，需要叠<strong>8层</strong>效果才比较好（除烟率60%）。</em></p><h3 id="2-2-如何灭火？"><a href="#2-2-如何灭火？" class="headerlink" title="2.2 如何灭火？"></a>2.2 如何灭火？</h3><p>首先说明，这里的灭火指火灾初期，已经是熊熊大火的情况下普通灭火手段效果有限。</p><p>很多人可能知道电器火灾不能用水灭火，需要用干粉灭火器灭火，但是一些更复杂的火灾场景上就没有那么清楚了。</p><p>根据现行国际标准和国家标准《火灾分类》（GB/T 4968-2008），火灾分为以下 6 类：</p><ol><li>A类火灾：固体物质燃烧发生的火灾。</li><li>B类火灾：液体或可熔化的固体物质火灾。</li><li>C类火灾：气体火灾。如：各种燃气</li><li>D类火灾：金属火灾。如钾、钠、镁、钛、锆、锂、铝镁合金等火灾。</li><li>E类火灾：带电火灾。</li><li>F类火灾：烹饪器具内的烹饪物（如动植物油脂）火灾。</li></ol><p>对家庭火灾而言，最常见的就是ABCEF。</p><p>目前市面上常见的灭火器有这几种：干粉灭火器、水基灭火器、气溶胶灭火器、二氧化碳灭火器。</p><p>干粉灭火器的适用范围比较广，家庭火灾的类型基本都能应付（ABCEF），优点是便宜易储存，操作简单，缺点是污染大，事后难清理，可能复燃。</p><p>水基灭火器一般适用范围是 ABEF，优点是操作简单无污染，缺点是不耐低温，使用年限略短。</p><p>二氧化碳灭火器家用不推荐，操作需要一定技巧，容易冻伤和窒息。</p><p>气溶胶灭火器一般适用范围 BCE，优点是易储存，能适应极端天气，缺点是适用范围稍窄且稍贵。</p><p>所有灭火器都会标注<strong>灭火种类和灭火等级</strong>，虽然上面写了每种灭火器适用的场景，但是在具体的产品上也会有一些差异，需要注意。</p><p>还需要注意的是，灭火器都有存放年限限制和环境温度限制，同时需要定期更换。</p><p><em>注：对付F类火灾也可用灭火毯。</em></p><h3 id="2-3-逃生路径"><a href="#2-3-逃生路径" class="headerlink" title="2.3 逃生路径"></a>2.3 逃生路径</h3><p>高层火灾救援公认的世界性难题。因高层建筑具有体量大、高度高、<strong>结构和功能复杂</strong>、<strong>人员密集</strong>、火灾荷载大等特点，一旦发生火灾<strong>蔓延快</strong>、<strong>高温浓烟聚集</strong>、易形成立体燃烧、人员疏散困难，<strong>灭火救援难度大</strong>，社会关注度高。</p><p>结构复杂、人员密集、蔓延快等都比较好理解，这里单独说一说救援难度。一般消防云梯的高度和水枪喷射的高度都小于 50 米，这个高度对应 15～18 层，超过这个高度的楼层就不用指望消防云梯和水枪了。</p><p>所以高层火灾里，自救永远是第一位。</p><p>当高层着火时，应该怎么逃？下面是消防局官网的建议[2]：</p><ol><li>不要跳楼！</li><li>若所处楼层距离避难层较近，在楼道有烟无火的情况下，可戴上防烟面罩或用湿毛巾捂住口鼻，弯腰低姿前往避难层，<strong>一般防烟面罩的有效逃生时间是30分钟</strong>。</li><li>当所在楼层在着火层之上且距离很近，在打开房门之前，要先用手背触摸门把手，如果不烫表示火焰离你还有一段距离，然后开门判断烟气是否侵入逃生通道，如无逃生条件，应立即退回室内等待救援。</li><li>假如门把手烫手，或有烟无从门缝中钻进，应退回房中，管关好门窗，用床单被罩等浸湿后堵住缝隙，等待救援。</li><li>当所在楼层在着火层之下且距离很近，开门前，要先用手背测试门把手温度，并开门检查是否有烟气倒灌，如烟气很少，可佩戴防烟面罩或用湿毛巾捂口鼻，弯腰低姿朝楼下逃生。</li><li>逃生过程中，一定不要乘坐普通电梯。普通电梯可能断电，叠加烟囱效应，困在电梯中容易因吸入有毒浓烟和缺氧致死。</li><li>逃生过程中，记得确保消防楼梯的防火门为关闭状态（<strong>不是锁上！</strong>），防止下层烟气顺着楼道往上窜。</li></ol><p>关于避难层，一般高度超过 100 米的住宅，在 50 米处会有避难层（15～18层），具体哪一层可以问物业。</p><p>关于消防通道（楼梯间），采用的是防火门。所有消防门都是关闭的状态下，消防通道在短时间内是一个比较安全的场所。所以<strong>消防门常年保持关闭（不是锁上！）是常识</strong>，如果见到消防门处于打开状态，应及时关上或者联系物业。</p><h3 id="2-4-必备器材"><a href="#2-4-必备器材" class="headerlink" title="2.4 必备器材"></a>2.4 必备器材</h3><p>首先是烟雾报警器。每个房间都要装，最怕半夜电器失火感知不到，错过最佳逃生时机。</p><p>其次是灭火器。家庭用一般是干粉+水基组合，买的时候注意灭火种类、灭火能力、储藏温度以及储藏年限，还要记得定期更换。</p><p>然后是多套防烟面罩，必备。能跑的情况防烟面罩决定了能跑多远，别倒在半路上。别忘了 80% 都是浓烟毒气致死。不确定要不要准备正压式空气呼吸器，略贵，但是和命比起来，也不是很贵。</p><p>至于高层缓降器，从高层直接跳下逃生那种，很久之前考虑过，但是自从看了今年长沙电信大楼火灾保温层剧烈燃烧的新闻后，犹豫了。北方的高层都有保温层，如果是长沙那种情况，用缓降器跳下去反而死路一条。另外我恐高，这也是个问题。</p><p>还有一些常用的，比如灭火毯、应急手电等等。其实上面大部分东西买个消防应急包都有。</p><p>另外，如果担心楼下单元门被锁或者被铁板围住，也可以买个消防斧，很容易劈开，真的。</p><h2 id="3、最后"><a href="#3、最后" class="headerlink" title="3、最后"></a>3、最后</h2><p>知乎上一个前消防员写了一段话：</p><blockquote><p>消防安全重要吗？重要。<br>人们重视吗消防安全？重视。<br>那人们会主动学习了解消防安全知识吗？并不会。</p></blockquote><p>没办法，这就是人性。</p><p>无论什么样的财务自由，无论追求的是哪种生活方式，活着，才是最大的前提。</p><p>高层火灾逃生没有最优解，上面谈到的知识只是增大我们逃生的几率，很多时候还需要我们结合具体情况（小区消防设施、家庭装修情况等）来具体实施。</p><p>如果你重视它，那么请尽可能的去了解它，并做好准备。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>[1] 火灾死亡人数中，高达80%是因为吸入有毒烟气！，<a href="https://www.119.gov.cn/kp/zjts/hz/2022/25917.shtml">https://www.119.gov.cn/kp/zjts/hz/2022/25917.shtml</a><br>[2] 高层着火怎么办？<a href="https://www.119.gov.cn/kp/zjts/hz/2022/33975.shtml">https://www.119.gov.cn/kp/zjts/hz/2022/33975.shtml</a></p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#25——最简略的一次实证</title>
    <link href="/2022/11/16/invest-practice-25/"/>
    <url>/2022/11/16/invest-practice-25/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a></p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气地把生命浪费在更“美好”的事物上。</p><p><strong>道阻且长，行则将至，行而不辍，未来可期！</strong></p><h2 id="1、实证进展"><a href="#1、实证进展" class="headerlink" title="1、实证进展"></a>1、实证进展</h2><h3 id="1-1-本月操作"><a href="#1-1-本月操作" class="headerlink" title="1.1 本月操作"></a>1.1 本月操作</h3><p>10 月投入 8000，买入情况如下：</p><ul><li>长赢等跟投组合：1000</li><li>主动基金组合：3000</li><li>指数基金组合：4000（1份300，1份信息）</li></ul><h3 id="1-2-本月进展"><a href="#1-2-本月进展" class="headerlink" title="1.2 本月进展"></a>1.2 本月进展</h3><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/11/16/img4685.PNG" alt="IMG_4685"></p><p>当前进展 5.23%，相比上个月下降 0.14%。</p><p>最近涨了不少，已经不用伤心了。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这是目前为止拖的最久也是最简略的一次实证。</p><p>原本写了一些东西，但是觉得没什么营养价值，来来回回删减，还是不满意，索性一股脑儿都删了。</p><p>就单纯记个数字吧。</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><em>说明：本文仅为个人投资记录及思考，不构成任何具体的投资建议！</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#24——两年了</title>
    <link href="/2022/10/09/invest-pratice-24/"/>
    <url>/2022/10/09/invest-pratice-24/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a></p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气地把生命浪费在更“美好”的事物上。</p><p><strong>道阻且长，行则将至，行而不辍，未来可期！</strong></p><h2 id="1、实证进展"><a href="#1、实证进展" class="headerlink" title="1、实证进展"></a>1、实证进展</h2><h3 id="1-1-本月操作"><a href="#1-1-本月操作" class="headerlink" title="1.1 本月操作"></a>1.1 本月操作</h3><p>9 月投入 23000，买入情况如下：</p><ul><li>长赢等跟投组合：2000</li><li>主动基金组合：8000</li><li>指数基金组合：18000（2份医药，2份养老，2份300，1份恒生，1份信息，1份传媒）</li></ul><p>4 月份暴跌的记忆还没有走多远，8、9 月份的市场又狠狠地教育了投资者什么叫一切皆有可能。</p><p><em>注：累计买入大于投入，是因为之前的投入有一部分沉淀到了现金仓位。</em></p><h3 id="1-2-本月进展"><a href="#1-2-本月进展" class="headerlink" title="1.2 本月进展"></a>1.2 本月进展</h3><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/10/09/png-tu-xiang0bd5d46c3d4d1.png" alt="PNG图像-0BD5D46C3D4D-1"></p><p>当前进展 5.37%，和上个月持平。</p><p>翻了一下一年前的文章，进展是 2.87%，虽然这一年收益惨淡，但是储蓄的目标完成得很不错，超出预期，甚是满意。</p><h2 id="2、实证两年，一点收获"><a href="#2、实证两年，一点收获" class="headerlink" title="2、实证两年，一点收获"></a>2、实证两年，一点收获</h2><p>本次实证是第 24 期，一眨眼，实证又写了一年。这一年对市场关注的少了一些，但是在 A 股的磨练下，也有一些收获。</p><h3 id="2-1-市场是分化的"><a href="#2-1-市场是分化的" class="headerlink" title="2.1 市场是分化的"></a>2.1 市场是分化的</h3><p>人类的悲欢并不相通，投资也是。</p><p><em>你抄底中概，他追高新能源；</em></p><p><em>你偏爱成长风格，他喜欢低估值策略；</em></p><p><em>你网格波段不亦乐乎，他价值投资自得其乐；</em></p><p><em>你涨涨跌跌，他跌跌涨涨。</em></p><p>过去这一年，越来越强烈感受到A股是一个立体的市场，</p><p>虽然眼下已经到底部区域附近，但是回顾历史上的几次牛市，大小盘的走势分化的现象越来越明显：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/10/09/16651358457228.jpg" alt=""></p><p>18 年和 21 年初这两波行情 300 和 1000 的走势不完全同步。</p><p>眼下 A 股又一次来到了底部区域附近，但是在大部分行业进入低估区域时，消费却始终高高在上，鹤立鸡群。</p><p>然而强如消费，也曾有过低谷期：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/10/09/16651354860114.jpg" alt=""></p><p>比如 2012 年到 2014 年期间，消费的 PB 百分位在个位数附近波动，同期信息和医药的 PB 百分位接近 100，可谓是冰火两重天。</p><p>分化的市场意味着每一个细分的领域都有可能走出独立的行情，这也为下面即将提到的“市场永远不缺少机会”的观点提供了事实支撑。</p><h3 id="2-2-市场永远不缺少机会"><a href="#2-2-市场永远不缺少机会" class="headerlink" title="2.2 市场永远不缺少机会"></a>2.2 市场永远不缺少机会</h3><p>2019 年至今，短短 3 年半，堪称具备较高价值的底部区域就有 4 个：</p><ol><li>2019 年 2 月，E 大发文<a href="https://mp.weixin.qq.com/s/c2Y29WLs6CLiL0PvSBjrAw">《钻石底》</a></li><li>2020 年 3 月，受疫情影响，全球股市暴跌，上证指数最低下探到 2646。（ 3 月份 E 大发车 <strong>8</strong> 次，其中 6 次都是文字发车）</li><li>2022 年 4 月，中概暴跌，紧接着其它指数全面下跌到底部区域，E 大又发文<a href="https://mp.weixin.qq.com/s/eY43uYLh1-8H6EIDfXnXQA">《就是这里。三年半后的钻石坑》</a>。</li><li>也许现在。虽然还没有到最底部，但是有知有行温度计再一次来到了 10°C 以下，恒生、医药、信息等不停的在支撑位附近徘徊。</li></ol><p>如果再加上经历的 2018 年底的钻石坑，4 年 5 次机会，机会真的太多了。</p><p><strong>市场永远不缺少机会</strong>，这可能是每个投资者刚入门时都会听前辈们提到的一句话，但也是只有亲身经历才能理解的一句话。</p><blockquote><p>前辈们的忠告对于后来人不犯那个错、不掉那个坑没有什么帮助，即使你听过了前辈的忠告，并且这些忠告都是正确的，你仍然会掉那个坑，等到你掉到坑里的时候，你才刻骨铭心地意识到前辈们的忠告是如此的正确，接下来结合这次掉的经验教训和听过的忠告的消化理解，你以后才会不再掉同样的坑了。</p></blockquote><p>面对这次大跌，比 4 月份淡定了很多。</p><p>复盘过去 4 个月的操作，6、7 月份在保持定投的同时谨慎控制买入额度（实际买入只有定投额度的一半），8、9 月份市场急剧下跌时通过积累的现金大幅提高买入额度。虽然时间不长，说服力不够，但是对我而言确实一次很舒服的尝试。</p><p>刚开始定投，每次都恨不得打尽最后一颗子弹，生怕错过机会。而当机会真正来临时，尽管时常能后者脸皮从大王同志那申请到加仓资金，却因为过早投入太多导致加仓效果大打折扣（而且从大王同志那申请资金的难度越来越高了😥）。</p><p>经历了这么多次的机会后，终于渐渐明白“市场永远不缺少机会”背后蕴含的经验教训是多么的珍贵，但就像前面说的：</p><p>你只有掉到坑里的时候，才刻骨铭心的意识到前辈们的忠告是如此的正确，并结合自己的经验教训和前辈们的忠告，下一次才不会掉同样的坑。</p><h3 id="2-2-温度计不是万能的"><a href="#2-2-温度计不是万能的" class="headerlink" title="2.2 温度计不是万能的"></a>2.2 温度计不是万能的</h3><p>在越来越多的人谈论温度计的时候，我逐渐认识到：温度计不是万能的。</p><p>市面上的温度计很多，从最早的（我知道的）集思录的温度计，到现在有知有行的温度计，推出温度计的平台越来越多，各种“民间温度计”更是不计其数。</p><p>集思录的温度计采用的是中证全指的 PB 中位数，有知有行的温度计采用的万得全A的 PB 等权值，这两种算法既反映了 A 股真实地行情，又不能全面真实地反映 A 股行情。如果我们参考这类温度计进行资产配置或者定投，取得的收益往往不尽如人意。</p><p>这两年，有一件事情让我一直无法释怀，那就是 2022 年 2 月份沪深300 突破历史新高，主动基金规模急剧上升的时候，我无动于衷，仍然在傻傻的定投。</p><p>参考有知有行的温度计：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/10/09/16651550956832.jpg" alt=""></p><p>2021 年 2 月 19 日这一天，全市场温度 25°C，处于低估状态。按照温度计的建议，这个时候我们应该加倍定投，但真实的行情是此刻沪深300破历史新高，主动基金抱团行为演绎到极致。</p><p>左边是低估的温度计，右边是主动基金的烈火烹油。</p><p>不可否认，温度计确实反映了市场真实的行情，因为中小盘确实在底部区域。但是对普通投资者来说，手上能持有多少小盘股呢？</p><p>温度计反映了市场整体的水平，但是并不能反映投资者持仓的真实情况。</p><p>除了温度计，一些比较知名的指标比如投资星级、股债性价比等指标也有这个问题。这些指标都很有代表性，但是都不能准确代表投资者真实的持仓。</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><em>说明：本文仅为个人投资记录及思考，不构成任何具体的投资建议！</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#23——弹性和打卡的一点思考</title>
    <link href="/2022/09/10/invest-pratice-23/"/>
    <url>/2022/09/10/invest-pratice-23/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a></p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气地把生命浪费在更“美好”的事物上。</p><p><strong>道阻且长，行则将至，行而不辍，未来可期！</strong></p><h2 id="1、实证进展"><a href="#1、实证进展" class="headerlink" title="1、实证进展"></a>1、实证进展</h2><h3 id="1-1-本月操作"><a href="#1-1-本月操作" class="headerlink" title="1.1 本月操作"></a>1.1 本月操作</h3><p>8 月投入 6000，买入情况如下：</p><ul><li>长赢等跟投组合：1300</li><li>主动基金组合：8000</li><li>指数基金组合：6000（2份医药，1份养老）</li></ul><p><em>注：累计买入大于投入，是因为之前的投入有一部分沉淀到了现金仓位。</em></p><h3 id="1-2-本月进展"><a href="#1-2-本月进展" class="headerlink" title="1.2 本月进展"></a>1.2 本月进展</h3><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/09/10/img4412.PNG" alt="IMG_4412"></p><p>当前进展 5.37%，相比上个月增加 0.07%。刚回正的累计收益又绿了。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/09/10/imgff5174a5d1791.jpeg" alt="IMG_FF5174A5D179-1"></p><p>虽然 2022 年的收益率挺惨，但是和其他指数一对比，似乎也没那么惨。</p><p>偶尔瞟两眼小群，看到有小伙伴说“感觉看不到希望了，又开始倒着走了，负的越来越多”、“都没勇气捡了”，虽然可能只是吐槽，但也侧面反映了当下部分投资者的情绪。</p><p>可能是因为最近忙于适应新工作，无暇关注市场（前段时间买了一份恒生，隔了几天才发现因为忙竟然没有付款），只有写实证统计进展的时候才感觉到行情确实不好。</p><p>老钱之前提过一个观点，大意是人们很难对危机有多少共情。回想 2018 年底或者今年 3 月份中概暴跌的至暗时刻，当时的恐惧心情你还能回忆多少？</p><p>如果觉得现在是危机，不妨仔细记录一下自己的心情和操作，留待以后的自己分析和回味。</p><h2 id="2、弹性和打卡"><a href="#2、弹性和打卡" class="headerlink" title="2、弹性和打卡"></a>2、弹性和打卡</h2><p>入职到现在一个月整，工作节奏和工作内容相比之前有很大的变化。适应的过程中，我感受最深的就是打卡制度。</p><p>上一份工作在互联网，实行的是互联网公司普遍采用的弹性上下班制度。弹性上下班指在保证完成一定工作量（工作时间）的基础上自由的安排上下班时间，听着很美好，但我实际体验下来却觉得很糟糕，加班严重，工作和生活几乎无法分开，十分疲惫，。</p><p>现在的工作有明确的打卡要求，表面上约束更多，但是整体工作时间更短，工作和生活的界限比较清晰，体验下来反而更自由。</p><p>为何更自由的弹性上下班更累，而有约束的打卡更自由？</p><h3 id="1）囚徒困境"><a href="#1）囚徒困境" class="headerlink" title="1）囚徒困境"></a>1）囚徒困境</h3><p>弹性上下班因为没有明确的下班时间，很多人会用同事甚至领导的下班时间作为参照。当所有人都这么做的时候，下班就陷入了一种“囚徒困境”之中。</p><p>如果假设都不加班和都加班的收益均为 0，加班相比于不加班的收益为 1，不加班相比于加班的收益为 -1（考虑到在都加班的情况下不加班会形成负面印象），在团队只有两人的场景下，博弈矩阵如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/09/10/jia-ban-bo-yi.jpg" alt="加班博弈"></p><p>显然，无论甲的策略是什么，乙的更优策略都是加班，同样无论乙的策略是什么，甲的更优策略也是加班，因此该博弈中的纳什均衡为甲乙两人都加班。甲乙两人都基于对方做出了最优的选择，但是最终的选择组合却是收益最小。</p><p>如果考虑到加班对身体健康和家庭的影响，实际收益为负，“囚徒困境”就更加的名副其实了。</p><h3 id="2）沟通成本"><a href="#2）沟通成本" class="headerlink" title="2）沟通成本"></a>2）沟通成本</h3><p>除了“囚徒困境”外，弹性上下班制度还会导致沟通成本的上升，在沟通效率的要求下，最终上升的成本需要所有人一起承担。</p><p>作为软件开发人员，日常工作中不仅有代码，还有大量的需求沟通、测试沟通和问题排查沟通，因此沟通效率十分关键。</p><p>弹性上下班制度下，错峰上下班意味着彼此交集的工作时间减少。如果工作内容比较独立还好，但是像软件开发这种需要大量沟通的工作，为了保证沟通效率，常常需要临时调整自己的作息以迁就别人，</p><p>经常面临这种场景：某一天想早到早走，临走前忽然接到产品的沟通需求，或者兄弟团队的协助需求，只能重新回到工位沟通需求或者处理问题，导致早走的计划泡汤。</p><p>这种情况发生的次数多了后，由于下班时间不可预知，所有人会不自觉的一起晚走，进一步的一起晚到，最终导致弹性上下班名存实亡。</p><h2 id="3、8-月番茄回顾"><a href="#3、8-月番茄回顾" class="headerlink" title="3、8 月番茄回顾"></a>3、8 月番茄回顾</h2><p>8 月份一共完成 83 个 🍅。</p><p>下面是 8 月份的时间分配：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/09/10/16623913650715.jpg" alt=""></p><p>换工作后，由于工作方式的较大差异，还没有完全适应，工作相关的统计数据缺失较多，但是其它标签的数据还是能体现一些东西。</p><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>学习相关的🍅大约 27 个，平均一天一个。</p><p>从互联网到传统行业，深刻感受到了软件开发基础设施的巨大差异，原来只需要当一一颗螺丝钉，现在是啥啥都要自己弄，因此下班后不得不花不少时间学习。</p><p>有点找到了当初刚毕业时候的学习热情了。</p><h3 id="折腾"><a href="#折腾" class="headerlink" title="折腾"></a>折腾</h3><p>把写一些小工具、代码什么的都归到了折腾这个标签。</p><p>折腾这一项累计投入 19 个🍅，不是很多，但也是看得见的投入。</p><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>写作相关的🍅一共 9 个（其实就是上一篇实证）。</p><p>经过几个月的统计，发现我写一篇文章需要的番茄在 8～10 这个区间，十分稳定。</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><em>说明：本文仅为个人投资记录及思考，不构成任何具体的投资建议！</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#22——离开北上广，还能自由吗？</title>
    <link href="/2022/08/05/invest-pratice-22/"/>
    <url>/2022/08/05/invest-pratice-22/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a></p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气地把生命浪费在更“美好”的事物上。</p><p><strong>道阻且长，行则将至，行而不辍，未来可期！</strong></p><h2 id="1、实证进展"><a href="#1、实证进展" class="headerlink" title="1、实证进展"></a>1、实证进展</h2><h3 id="1-1-本月操作"><a href="#1-1-本月操作" class="headerlink" title="1.1 本月操作"></a>1.1 本月操作</h3><p>7 月投入 6000，其中：</p><ul><li>长赢等跟投组合：1000</li><li>主动基金组合：2000</li><li>指数基金组合：0</li><li>现金：2700</li></ul><p>此外，受投顾政策影响，将之前持有的日积月累组合剩余部分全部卖出到现金仓位。</p><h3 id="1-2-本月进展"><a href="#1-2-本月进展" class="headerlink" title="1.2 本月进展"></a>1.2 本月进展</h3><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/08/05/img4326.PNG" alt="IMG_4326"></p><p>当前进展 5.3%，相比上个月下降 0.17%。看了下实证记录，这是写实证以来第一次出现进展回退的情况。</p><p>想过要不要补个仓，制造账户资产始终上升的假象，最终还是觉得骗自己没有意义，遂作罢。。。</p><h2 id="2、辞职，离开北京"><a href="#2、辞职，离开北京" class="headerlink" title="2、辞职，离开北京"></a>2、辞职，离开北京</h2><p>离开北京，是很早之前就计划好的事情，年初大王同志工作定下来之后，离京就进入了倒计时。</p><p>或许是因为一开始就没打算留下来，始终把自己当成一个过客，走的那天发现自己对这个城市竟然没有一丝留念。</p><p>犹记得刚毕业来北京的情景，下了地铁拖着箱子走了 2 公里多到租房的小区。小区是新建的回迁房，很新很大，但是很多配套设施都没有建好。施工的道路，开挖的地基，随处可见的防护钢板，碎石块，整个天空都笼罩在灰蒙蒙的黄沙之中。</p><p>一晃眼三年过去，这三年，我从小区的四期换到了三期，因为自如涨价，换到了二期，又因为房东不续租，换到了一期；这三年，小区楼下社区超市（便利店）从原来的一家变成了八家；这三年，眼见着小区后面的空地从土坑变成了商场，我也成了星巴克的常客。</p><p>工作这三年，每天过着两点一线的单调日子。在互联网公司所谓的“弹性工作制”下，起的越来越晚，睡的也越来越晚，作息彻底紊乱。周六日除了呆在家里，就是去小区后面的星巴克，偶尔学习，多数时间玩手机，发呆，早已没有了最初的激情。</p><p>我大抵是乏了，日常横竖都开心不起来，这悲伤是没来由的。看着窗外的树木，远处的群山和夕阳，只觉得离我很遥远，没有一丝归属感，大抵到了该离开的时候了。</p><h2 id="3、离开北上广，还能自由吗？"><a href="#3、离开北上广，还能自由吗？" class="headerlink" title="3、离开北上广，还能自由吗？"></a>3、离开北上广，还能自由吗？</h2><p>离开北上广，还能自由吗？</p><p>我想这个问题很多小伙伴都思考过。我认真地思考了这个问题。</p><p>对我而言，追求财务自由的同时，仍然会面临买房、生小孩的问题，所以需要考虑能否承受一线城市的房价，能否给小孩一个还不错的教育环境。这也是绝大部分打算留在北上广的人都会面临的问题。</p><p>选择留在北上广，有 2 个槛：户口和房子。去年底我和大王同志深入的聊过这个问题。对我们而言，户口的问题好解决，难的是房子。按北京的购房政策，因为我们有贷款记录，再买就算二套，首付至少 60%，这个压力太大了。</p><p>我问大王同志，能不能接受人到中年、上有老下有小的时候，掏空所有积蓄拼命上车？大王同志想了想，说不想过那种如履薄冰的日子。</p><p>有时候也会想，如果没有首付 60% 的门槛，是不是就有可能留下了？但是一想到人生大半辈子被房子束缚住的恐惧，又忍不住庆幸不用纠结这种可能性。</p><p>北上广意味着更多的发展机会，更高的薪资，但这背后的代价是必须把大部分精力都放在工作上，牺牲生活，牺牲家庭，每天都活在焦虑中。这样的生活，即使有 500 万，又何谈自由？</p><p>那么，离开北上广呢？离开就能自由吗？</p><p>我把当初写的 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a> 翻了出来，重新回顾了一遍。</p><h3 id="3-1-500-万的目标是否合理？"><a href="#3-1-500-万的目标是否合理？" class="headerlink" title="3.1 500 万的目标是否合理？"></a>3.1 500 万的目标是否合理？</h3><p>我给自己定的目标是 25 年 500 万，如果说之前的目标是合理的，那么换城市后生活成本更低，就更合理了。</p><p>很多人都会担心通货膨胀，但是根据之前的观察，经济水平进入到平稳期后，CPI 会维持在一个比较低的水平。按 3% 计算，25 年，货币会贬值一半，这个幅度并不高。</p><p>另外，虽然追求财务自由，但并不意味着就彻底不工作，所以仍然会有工资收入，退休后还会有养老金收入。这些都是自由的后盾。</p><h3 id="3-2-当前定投额度能否保持？"><a href="#3-2-当前定投额度能否保持？" class="headerlink" title="3.2 当前定投额度能否保持？"></a>3.2 当前定投额度能否保持？</h3><p>换工作后，预期收入会有不小的跌幅，但是随着大王同志开始工作，这部分的损失刚好弥补，影响不大。</p><p>支出上，房贷、保险这些保持不变，房租会消失，交通成本会有大幅上升，两项相抵，整体支出会有下降，但降幅有限。未来支出最大的不确定性因素就是小孩，再有就是赡养父母。</p><p>但是考虑到未来两个人的收入还会有增长，以及当前定投额度是一个比较保守的值，未来保持该定投额度的可能性仍然较高。</p><p><em>8.4 更新</em></p><p>今天和同事聊天，聊到小孩的支出成本，同事说这边大部分父母比较佛系，鸡娃没那么明显，所以实际成本并不高。</p><h3 id="3-3-年化收益率-10-能否达到？"><a href="#3-3-年化收益率-10-能否达到？" class="headerlink" title="3.3 年化收益率 10% 能否达到？"></a>3.3 年化收益率 10% 能否达到？</h3><p>最初预期的年化收益率是 14.5%，但是这几年，经历了 19 年初的钻石坑，经历了贸易战，经历了疫情，也经历了 19-21 的暴涨，经历了中概股的暴跌，还有今年 4 月份的钻石坑，我对具体的收益率数字已经没有了执念。</p><p>因上努力，果上随缘，我对长期投资的信念越来越深，对收益率却看的越来越淡，哪怕最终年化收益率只有 10% 甚至 7%、8%，我也能坦然接受。</p><p>而且无论最终收益率是多少，这个值都仅仅取决于市场行情和我的投资水平，和我在哪个城市工作没有任何关系。</p><p>既然目标没有问题，计划投入也没有问题，那么离开北上广还能否自由，答案已经不言而喻。</p><h2 id="4、本月回顾"><a href="#4、本月回顾" class="headerlink" title="4、本月回顾"></a>4、本月回顾</h2><p>7 月份很多时间都在忙离职交接、搬家等事情，番茄工作法执行的比较差，一共才完成 77 个 🍅，所以暂时就不回顾具体细节了。</p><p>进入 8 月份后，工作生活基本稳定了下来。由于现在的作息和之前相比变化较大，目前还在适应中，预计之前的番茄工作法的计划也会有一些调整。</p><p>就这样。</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><em>说明：本文仅为个人投资记录及思考，不构成任何具体的投资建议！</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基金公司</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#21——2022上半年投资记账总结</title>
    <link href="/2022/07/05/invest-pratice-21/"/>
    <url>/2022/07/05/invest-pratice-21/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a></p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气地把生命浪费在更“美好”的事物上。</p><p><strong>道阻且长，行则将至，行而不辍，未来可期！</strong></p><h2 id="1、实证进展"><a href="#1、实证进展" class="headerlink" title="1、实证进展"></a>1、实证进展</h2><h3 id="1-1-本月操作"><a href="#1-1-本月操作" class="headerlink" title="1.1 本月操作"></a>1.1 本月操作</h3><p>6 月投入 6000，其中：</p><ul><li>长赢等跟投组合：1300</li><li>主动基金组合：2000</li><li>指数基金组合：0</li><li>现金：2700</li></ul><p>本月没啥操作，投入额度也恢复了正常。</p><h3 id="1-2-本月进展"><a href="#1-2-本月进展" class="headerlink" title="1.2 本月进展"></a>1.2 本月进展</h3><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/07/05/img4205.PNG" alt="IMG_4205"></p><p>当前进展 5.47%，相比上个月增加了 0.52%。经过 6 月份的全面反弹，累计收益、收益率和年化收益率已经全面回正。</p><p>这红色的收益率，是如此的鲜艳和活泼！</p><h2 id="2、上半年投资回顾"><a href="#2、上半年投资回顾" class="headerlink" title="2、上半年投资回顾"></a>2、上半年投资回顾</h2><p>相比于实证账户收益率的全面转正，更有意义的是下面一组数据（有知有行账本的年度收益对比）：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/07/05/imgbccaa30bbcfb1.jpeg" alt="IMG_BCCAA30BBCFB-1"></p><p>2022 年上半年，资金加权收益率 -3.16%，跑赢图中全部权益基准指数。</p><p>严格来说这个跑赢还有一些水分，1-5 月份计划外的加仓有很多，强行拉低了平均成本。只看组合本身的收益率（时间加权），会逊色不少，当然还是比大部分基准指数要好一些。</p><p>在之前的文章 <a href="https://mp.weixin.qq.com/s/r0eUdg-3GWJK1DBw38NCrw">财务自由实证#13——介绍下新开的两个组合</a> 中，介绍了用于对比的两个组合：</p><ul><li>主动基金组合：它山之石</li><li>指数基金组合：积水成渊</li></ul><p>目前这两个组合已经运行大半年，今天来检查一下这两个组合的运行情况。</p><h3 id="2-1-它山之石"><a href="#2-1-它山之石" class="headerlink" title="2.1 它山之石"></a>2.1 它山之石</h3><p>它山之石的运行情况如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/07/05/img1b18e52420c31.jpeg" alt="IMG_1B18E52420C3-1"></p><p>该组合成立至今（277天），跑输沪深300 1.45 个百分点，成绩比较一般。</p><p>它山之石组合中包含了三只基金：兴全合宜、兴全趋势和富国天惠。看到这里，熟悉的朋友可能会会心一笑，这不就是也大之前主动基金组合中的三只基金嘛。没错，就是它们。</p><p>由于开始没想好放哪几只基金，就先抄了也大的作业。</p><p>主动基金部分，我的思路是先找出不错的基金公司，然后在筛选出来的基金公司中选择合适的基金。</p><p>上半年已经完成了 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg5NjU0MzU1Mg==&amp;action=getalbum&amp;album_id=2105301511651033090#wechat_redirect">基金公司分析系列</a> 文章，筛选出了一些还不错的基金公司。下半年的目标是基于这些基金公司再筛选出部分主动基金，加到组合中。</p><h3 id="2-2-积水成渊"><a href="#2-2-积水成渊" class="headerlink" title="2.2 积水成渊"></a>2.2 积水成渊</h3><p>下面是积水成渊的运行数据：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/07/05/16569410446703.jpg" alt=""></p><p>左边是该组合近 6 个月的收益率走势，跑赢沪深300 4 个百分点，也跑赢了比较基准（中证800 <em> 80% + 中债 </em> 20%）3 个百分点。</p><p>虽然看起来收益率一般，但是真实情况是该组合中 12 只指数，目前仅有 2 只中概还亏损，其余均已盈利。</p><p>右边的图是天天基金新版的统计（新版只能统计近 6 个月），近 6 个月收益率 6%，跑赢 97.06% 的同期基民。由于该账户中只有这一个组合，所以右边的图约等于积水成渊同期的收益率。</p><p>如果把积水成渊组合想象成某只基金，上面这两张图生动地展示了什么叫：</p><p><strong>基金（组合）的收益率 ≠ 你的收益率！</strong></p><h3 id="2-3-下一步优化的方向？"><a href="#2-3-下一步优化的方向？" class="headerlink" title="2.3 下一步优化的方向？"></a>2.3 下一步优化的方向？</h3><p>之前无脑跟投组合的时候，对很多概念都似懂非懂。有时候觉得投资就那么回事，有时候又觉得自己一无所知，始终在投资的门外徘徊。</p><p>自从建了两个组合后，很多前人说烂了的问题，我也不可避免的一一遇到。不同的投资者对这些问题有不同的解决方案，但纸上得来终觉浅，每个人的情况不同，属于自己的答案，只能自己寻找。</p><p>这些问题很多我也没想好，这里只是记录一下后续会尝试的优化方向。</p><h4 id="方向一：仓位控制。"><a href="#方向一：仓位控制。" class="headerlink" title="方向一：仓位控制。"></a>方向一：仓位控制。</h4><p>随着实证账户的数字不断增长，新投入资金对收益率的影响越来越小，已投入资金才是收益率决定性因素。另外当有一笔较大收入（比如年终奖）时，如何分配也是个问题？</p><p>这些问题都需要用仓位控制的手段来解决。不过仓位该怎么控制？用什么样的指标？再具体到组合内部，大盘股，中小盘，行业，又应该控制多少仓位？主动基金和指数基金又应该怎么分配？</p><p>这都是接下来亟需解决的问题。</p><h4 id="方向二：全市场行情的判断"><a href="#方向二：全市场行情的判断" class="headerlink" title="方向二：全市场行情的判断"></a>方向二：全市场行情的判断</h4><p>这个是研究全市场估值的时候发现的问题。无论是全市场指数，还是特定的宽基指数（300、500）的估值，都不能完全解释过去每一次的高估和低估。</p><p>比如全市场指数在 21 年基金抱团时仍然显示低估，300 在 2015 年市场顶部的时候只是接近高估，500 自 2015 年之后再也没有显示过高估。</p><p>随着 A 股结构化行情越来越明显，需要警惕通过单项指标来判断市场行情的想法。</p><h4 id="方向三：时间和空间的计算"><a href="#方向三：时间和空间的计算" class="headerlink" title="方向三：时间和空间的计算"></a>方向三：时间和空间的计算</h4><p>估值是个比较模糊的范围，如果某个指数持续低估，那么这一段时间内是每天都买入，还是隔一段时间买入？亦或是每跌幅多少买入？这也是个问题。</p><p>时间和空间对应的是投资纪律，并不决定最终的收益。但是纪律意味着克制，意味着无论面对什么样的市场环境，都有应对方案，对心态的影响很大。</p><p>想成为一个成熟的投资者，需要具备主动给自己设限，明确操作的边界的能力。</p><h4 id="方向四：主动基金的择时"><a href="#方向四：主动基金的择时" class="headerlink" title="方向四：主动基金的择时"></a>方向四：主动基金的择时</h4><p>通常的观点是主动基金不需要择时。可是就我近一年的持仓感受来说，不择时而承受全部的回撤让我十分痛苦。当前的思路是利用比较基准的估值对低估和高估进行模糊的择时。</p><p>择时能带来多少收益还需要进一步验证。</p><p>以上是接下来主要的优化方向。​</p><p>有预感解决这些问题后，我的投资体系能直接进化到 V1.0 版本，一个能用的成体系的版本。</p><h2 id="3、记账体系-V1-0"><a href="#3、记账体系-V1-0" class="headerlink" title="3、记账体系 V1.0"></a>3、记账体系 V1.0</h2><p>熟悉软件开发版本号命名规范的同学都知道，当版本号第一位是 1 时，意味着该软件从开发版变成了稳定版，可以用于生产环境正式提供给用户使用了。</p><p>经过 3 年多的实践，今年上半年我形成了属于自己的记账体系 V1.0：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/07/05/ji-zhang-ti-xi.jpg" alt="记账体系"></p><p>这个记账体系有两个特点：</p><ol><li>先预算，后消费。预算指导消费。</li><li>只记录消费和投资（包含备用金）。</li></ol><p>第一点，先预算后消费，预算指导消费。为什么要先预算，后消费？因为单纯的记录流水账没有意义。记录消费支出的目的是希望我们能从容的掌控支出，为自由的可能性提供现实依据。</p><p>自由的边界是自律，没有约束，就没有自由。同理，预算就是财务自由的边界，没有预算，财务自由又从何谈起？</p><p>第二点，只记录消费和投资，不关心收入。在我看来，<strong>每一笔收入最终都会变成消费或者资产</strong>，这也是财务自由真正关心的目标：资产和支出。</p><p>而且这样做还有两个好处：</p><ol><li>省去对账的烦恼。很多人记账都会面临余额不平衡，需要反复对账的烦恼，尤其是强迫症患者，余额误差 1 块钱可能得用数小时来检查。</li><li>给生活留一些弹性。一笔收入，不可能减掉消费预算和固定投资额度后变成 0，生活总有意外，预算也可能超支，所以总要留一部分灵活资金。这笔钱可能变成资产，也可能会被消费掉，但是在没有真正发生前，没必要记录。</li></ol><p>具体的操作上，资产端，有知有行负责记录所有的金融资产，汇总之后的账本即表示家庭总资产；消费端，MoneyWiz 负责记录所有的消费支出。需要注意的是，每一笔消费都需要记录到对应的预算账户下，且不能有遗漏。</p><p>除了记账体系升级，还有一个很大的收获就是<strong>记账从我的自娱自乐变成了家庭行为</strong>。</p><p>记得刚开始记账时，和大王同志还发生了一些争执。大王同志认为记账就是在限制她花钱，坚决不同意，也不参与。</p><p>没办法，我只能自己折腾。开始是事无巨细的记录每一笔支出、收入和转账，后来觉得太麻烦，改成了每月按大类汇总记录，还是觉得有问题。就这样不停的记录不停的调整，终于在今年年初梳理清楚了支出分类体系和预算记账法。</p><p>同时年初把 MoneyWiz3 升级成了订阅版。本着不管你用不用，我都给你装上的想法，我也在大王同志的手机上安装了该软件。</p><p>忽然有一天，或许那天大王同志正好兴致不错，或许是大王同志怜悯我三年的努力，又或许是 MoneyWiz 的图标比较鲜艳，大王同志突然主动问我怎么记账。在我献宝似的演示了记账方法后，大王同志尝试记录了两笔。</p><p>时隔多月，犹记得大王同志发出的那一声欢呼：原来记账这么简单！</p><p>如今大王同志已经记账数月有余，没有意外的情况下日日记账，并乐此不疲。</p><p>记得也大之前写过一篇文章<a href="https://mp.weixin.qq.com/s/F_AgNBVn98xfhjLX1cLIDw">《如何让另一半接受记账理财》</a>，解决方法是不断提升自己的能力，用行为影响另一半。</p><p>现在回过头来看，我的经历正好完美的印证了也大的观点。</p><h2 id="4、本月回顾"><a href="#4、本月回顾" class="headerlink" title="4、本月回顾"></a>4、本月回顾</h2><p>前段时间读完了《软技能》，刷新了我对番茄工作法的认知：</p><p><strong>番茄工作法只有被当作估算和评估的工具使用时，才能发挥它的真正价值！</strong></p><p>按照书中介绍的应用原则，我对每周需要完成的工作进行了列举，对总的工作量进行了目标设定。初期设置的目标比较宽松，每日 6 个 🍅。</p><p>下面是 6 月份实践的一些数据。</p><h3 id="工作量完成率"><a href="#工作量完成率" class="headerlink" title="工作量完成率"></a>工作量完成率</h3><p>按天统计，6 月有 15 天完成目标，完成率 50%；按总量统计，6 月完成 158 个🍅，完成率 158/180 = 87.8%。</p><p>以工作量作为评估依据，6 月份完成率为 87.8%。考虑到 6 月份是首个实践的月份，中间有诸多调整，也还算满意。</p><p>7 月份工作量目标不变，还是每日 6 个 🍅。</p><h3 id="一些有趣的数据"><a href="#一些有趣的数据" class="headerlink" title="一些有趣的数据"></a>一些有趣的数据</h3><p>除了完成率外，还有一些有意思的数据。比如：</p><p><em>1、工作上摸鱼明显</em></p><p>工作累计消耗 53 个 🍅，平均一个工作日 2.5 个 🍅。虽然我只统计了写文档、问题排查和写代码等事项，没有统计各种沟通、开会。但是每天 2.5 个 🍅，还是有点说不过去。。。</p><p>我是不是快被裁了🤔</p><p><em>2、书读得有点少</em></p><p>6 月份阅读消耗 11 个 🍅，平均三天一个。</p><p>难怪总觉得腹中空空，胸无点墨。</p><p><em>3、写作还是很难</em></p><p>6 月份写作 4 篇共消耗 35 个 🍅，平均每篇 9 个 🍅。</p><p>阅读少，果然写作难。</p><p><em>4、个人项目进展显著</em></p><p>个人项目消耗 16 个 🍅，进展显著。</p><p>我认为番茄工作法对这项任务的改善最明显。</p><p><em>5、信息整理很耗时</em></p><p>整理各种有价值的信息消耗了 26 个 🍅，仅次于工作和写作，这个是我没有预料到的。看来需要给信息整理分配更多的 🍅。</p><p>6 月份是实践番茄工作法的第一个月，通过上面的统计，摸清了一些任务需要的固定工作量，发现了一些工作量不达预期，另一些任务工作量超出预期。7 月份有必要对其中一部分任务进行调整，让 🍅 分配得更合理。</p><p>就这样。</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><em>说明：本文仅为个人投资记录及思考，不构成任何具体的投资建议！</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基金公司分析（九）——睿远基金</title>
    <link href="/2022/06/26/fund-company-analysis-9/"/>
    <url>/2022/06/26/fund-company-analysis-9/</url>
    
    <content type="html"><![CDATA[<p>在之前的文章 👉 <a href="https://mp.weixin.qq.com/s?__biz=Mzg5NjU0MzU1Mg==&amp;mid=2247484354&amp;idx=1&amp;sn=08665af13118aef6c5971bfed58605cf&amp;chksm=c07e3dedf709b4fb7b77ab64ffa4fa5ff775db9090afc9347cf0c215d00c957a276bf108c384#rd">筛选了一份基金公司名单！</a> 中，为了降低分析成本，利用一些简单的指标，我筛选出了以下几个基金公司（名单不分先后）：</p><div class="table-container"><table><thead><tr><th>基金公司</th><th>状态</th><th>是否考虑旗下产品</th></tr></thead><tbody><tr><td>中银基金管理有限公司</td><td><em>已完成</em></td><td>否</td></tr><tr><td>交银施罗德基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>兴证全球基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>嘉实基金管理有限公司</td><td><em>已完成</em></td><td>否</td></tr><tr><td>富国基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>工银瑞信基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>易方达基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>银华基金管理股份有限公司</td><td><em>已完成</em></td><td>否</td></tr></tbody></table></div><p>在这个名单里，并不意味着基金公司就十分优秀；同样，不在这个名单里，也不意味着实力不行。</p><p>除了表格中的基金公司，还有一些实力突出的基金公司也值得关注。比如有读者朋友建议分析一下睿远基金、中欧基金等。所以尽管表格中的基金公司已经分析完毕，但是这个系列并不会就此结束，接下来还会陆陆续续的分析一些大家关注的公司。</p><div class="table-container"><table><thead><tr><th>基金公司</th><th>状态</th><th>是否考虑旗下产品</th></tr></thead><tbody><tr><td>睿远基金管理有限公司</td><td><em>已完成</em></td><td>否</td></tr><tr><td>中欧基金管理有限公司</td><td>待分析</td></tr></tbody></table></div><p>今天就来看一下这两年人气比较高的睿远基金</p><h2 id="1、公司简介"><a href="#1、公司简介" class="headerlink" title="1、公司简介"></a>1、公司简介</h2><p>睿远基金成立于 2018 年 10 月 29 日，注册资本 1 亿元。相比于之前分析的基金公司，可以说是非常非常年轻了。</p><p>公司的股权结构如下图所示：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/26/16561570310739.jpg" alt=""><br>睿远的股东全部是个人股东（股权结构中的xx企业管理中心均是员工持股平台），实际控制人是陈光明。</p><h2 id="2、基本数据"><a href="#2、基本数据" class="headerlink" title="2、基本数据"></a>2、基本数据</h2><p>下表是睿远基金的基本数据（2022-06-24）：</p><div class="table-container"><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">数值</th><th style="text-align:left">排名</th></tr></thead><tbody><tr><td style="text-align:left">非货币型基金规模</td><td style="text-align:left">520.97亿</td><td style="text-align:left">65</td></tr><tr><td style="text-align:left">非货币型基金平均规模</td><td style="text-align:left">86.83亿</td><td style="text-align:left"><strong>1</strong></td></tr><tr><td style="text-align:left">近5年股票型基金平均收益</td><td style="text-align:left">-</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left">近5年混合型基金平均收益</td><td style="text-align:left">-</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left">金牛奖获奖数</td><td style="text-align:left">-</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left">基金经理平均任职年限</td><td style="text-align:left">-</td><td style="text-align:left">-</td></tr></tbody></table></div><p>睿远基金成立时间较短，因此很多数据都没有。就仅有的两项而言，非货币型基金平均规模 86.33 亿，排名第一，十分惊艳。</p><p>之前分析的兴全，平均规模数据数据排名第 2，也正是那个时候，注意到了睿远。虽然平均规模数据并不能证明基金公司的能力，但是至少反映了基金公司不希望以量取胜、希望走精品路线的态度。</p><h3 id="2-1-各类型基金规模占比"><a href="#2-1-各类型基金规模占比" class="headerlink" title="2.1 各类型基金规模占比"></a>2.1 各类型基金规模占比</h3><p>睿远基金各类型基金规模占比如下图所示：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/26/16561688208328.jpg" alt=""></p><p>混合型基金占比 100%，可见，当前睿远基金的主攻方向就是混合型基金。</p><h3 id="2-2-股票型基金数据"><a href="#2-2-股票型基金数据" class="headerlink" title="2.2 股票型基金数据"></a>2.2 股票型基金数据</h3><p>此项数据无，略。</p><h3 id="2-3-混合型基金数据"><a href="#2-3-混合型基金数据" class="headerlink" title="2.3 混合型基金数据"></a>2.3 混合型基金数据</h3><p>睿远基金混合型基金规模 520.97 亿，排名 21:</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/26/16561689976259.jpg" alt=""></p><p>近 3 年平均收益超过平均水平，无近 5 平均收益水平。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/26/16561690470573.jpg" alt=""></p><p>由于睿远基金成立时间不满 5 年，上面这些数据参考意义不大。</p><p>值得一提的是，虽然睿远成立时间短，但是它的每一只基金的募集均可用盛况来形容。当前睿远发行的 3 只基金（合并 A/C 类）分别是：</p><div class="table-container"><table><thead><tr><th>基金名称</th><th>成立时间</th><th>规模</th><th>累计收益（A类）</th><th>基金经理</th><th>排名（A类）</th></tr></thead><tbody><tr><td>睿远成长价值混合</td><td>2019.03.26</td><td>280.89亿</td><td>74.16%</td><td>傅鹏博、朱璘</td><td>1004/2694</td></tr><tr><td>睿远均衡价值三年持有混合</td><td>2020.02.21</td><td>141.51亿</td><td>46.81%</td><td>赵枫</td><td>710/3217</td></tr><tr><td>睿远稳进配置两年持有混合</td><td>2021.12.06</td><td>98.16亿</td><td>-3.30%</td><td>饶刚</td><td>1815/5576</td></tr></tbody></table></div><p>第一只基金睿远成长价值，甫一出道，在“陈光明+傅鹏博”光环的加持下，吸引了大量申购。原计划募集 60 亿，首日认购超过 700 亿，配售比不足 10%！</p><p>第二只睿远均衡价值更甚，同样计划募集 60 亿，单日申请认购 1224 亿，创下当时公募基金单日最高认购记录，最终配售比仅 4.9%！</p><p>第三只睿远稳进配置，混合偏债，在市场震荡波动、基金募集热度有所缓和的背景下，单日仍然吸引认购超 1200 亿，配售比不足 10%！</p><p>一两只爆款说明不了什么，但是每只均如此，足见睿远基金在广大投资者心中的地位。</p><h3 id="2-4-债券型基金数据"><a href="#2-4-债券型基金数据" class="headerlink" title="2.4 债券型基金数据"></a>2.4 债券型基金数据</h3><p>此项数据无，略。</p><h2 id="3、投资理念"><a href="#3、投资理念" class="headerlink" title="3、投资理念"></a>3、投资理念</h2><p>以下在睿远基金官网找到的关于投资理念的描述：</p><blockquote><p>公司是一家以价值投资、研究驱动和长期投资风格为主的长期价值投资机构，拥有经验丰富的投资团队，领先的行业专家型研究团队，秉承价值投资理念和长期投资理念，聚焦于权益投资和固定收益投资领域，为个人和机构投资者提供投资理财产品和服务。</p></blockquote><p>除了投资理念的描述，在企业文化——价值观部分，睿远写到：</p><blockquote><p><strong>善良为先</strong>、智慧为道、奋斗为本、进化不息</p></blockquote><p>睿远是我看到的第一个将“善良”写进价值观的基金公司。离钱更近的地方，“善良”比“聪明”更重要。</p><p>有的公司压根就没想到投资还需要善良吧😶。</p><p>睿远基金在投资者教育上做的比绝大部分基金公司要好很多。除了官方公众号，睿远有一个专门进行投资者教育公众号：睿远FUND。</p><p>该公众号下的文章包含很多模块，有教如何投资基金的权益类基金投资手册、基金定投，有讲投资观念的价值投资，还有分析投资心理的投资旅程。用心程度可见一般。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/26/16562400169915.jpg" alt=""></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/26/16562400379321.jpg" alt=""></p><p>基金的收益源于基金经理和投资者的共同努力，愿意花时间、花精力真诚得对投资者进行教育的基金公司，投资者自然也更容易信任它。</p><h2 id="4、投研团队"><a href="#4、投研团队" class="headerlink" title="4、投研团队"></a>4、投研团队</h2><p>根据睿远基金官网的介绍，投研团队的核心成员有：陈光明、傅鹏博、赵枫、饶刚、黄真和童卓。</p><p>这里面的陈光明、傅鹏博、赵枫和饶刚，无一不是业绩辉煌，声名在外，无需我多介绍，相信绝大部分的投资者都有所耳闻。也正是因为投资者对这些明星基金经理的认可，睿远的三只基金在发行时，才能不断创出单日认购记录。</p><p>但是不能忽视的是，由于成立时间较短，当前睿远的投研团队仍然处在过度依赖明星基金经理个人能力的阶段，还没有形成规模化的投研平台和完善的人才梯队。如果这些基金经理出现人事变动，基金业绩如何保证，投资者又该如何？</p><p>毕竟，傅鹏博已经 60 岁了，距离退休还有多久呢？</p><h2 id="5、合规信息"><a href="#5、合规信息" class="headerlink" title="5、合规信息"></a>5、合规信息</h2><p>无。</p><h2 id="6、结论"><a href="#6、结论" class="headerlink" title="6、结论"></a>6、结论</h2><p>至此，睿远基金的分析告一段落，结论如下：</p><ol><li>规模上，因为成立时间较短，目前只有三只混合型基金，总规模不是很大，但是平均规模数据很鲜艳，排名第 1。</li><li>收益上，暂时没有近 5 年平均收益水平，近 3 年平均收益水平超过同类平均，表现正常。</li><li>投研团队上，比较依赖基金经理，缺少规模化的投研平台和人才培养机制，存在断层的风险。</li></ol><p>就我个人而言，会关注，但暂时不会考虑睿远基金的产品。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>给自己打个广告。</p><p>由于深知闭门造车的弊端，我建了个微信群，用于交流投资理财心得，欢迎感兴趣的同学入群交流（公众号回复【联系方式】）。</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><em>说明：本文仅为个人投资记录及思考，不构成任何具体的投资建议！</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基金公司</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基金公司分析（八）——银华基金</title>
    <link href="/2022/06/19/fund-company-analysis-8/"/>
    <url>/2022/06/19/fund-company-analysis-8/</url>
    
    <content type="html"><![CDATA[<p>在之前的文章 👉 <a href="https://mp.weixin.qq.com/s?__biz=Mzg5NjU0MzU1Mg==&amp;mid=2247484354&amp;idx=1&amp;sn=08665af13118aef6c5971bfed58605cf&amp;chksm=c07e3dedf709b4fb7b77ab64ffa4fa5ff775db9090afc9347cf0c215d00c957a276bf108c384#rd">筛选了一份基金公司名单！</a> 中，为了降低分析成本，利用一些简单的指标，我筛选出了以下几个基金公司（名单不分先后）：</p><div class="table-container"><table><thead><tr><th>基金公司</th><th>状态</th><th>是否长期关注</th></tr></thead><tbody><tr><td>中银基金管理有限公司</td><td><em>已完成</em></td><td>否</td></tr><tr><td>交银施罗德基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>兴证全球基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>嘉实基金管理有限公司</td><td><em>已完成</em></td><td>否</td></tr><tr><td>富国基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>工银瑞信基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>易方达基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>银华基金管理股份有限公司</td><td><em>已完成</em></td><td>否</td></tr></tbody></table></div><p>按照顺序，今天来分析表格中的最后一个基金公司——银华基金。</p><h2 id="1、公司简介"><a href="#1、公司简介" class="headerlink" title="1、公司简介"></a>1、公司简介</h2><p>银华基金成立于 2001 年 5 月，注册资本 2.222 亿，是一家全牌照、综合型资产管理公司。</p><p>银华基金的股权结构如下图所示：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/19/16556210988023.jpg" alt=""></p><p>由此可见，银华基金是一家完完全全的中资基金。</p><p>值得一提是的，股权结构中的山西海鑫实业，原法人代表是李兆会，前山西省首富，就是那个年少因故接班海鑫钢铁的富二代。当年他和影视明星车晓结婚的新闻，人尽皆知。如今却欠下巨额债务，下落不明。</p><h2 id="2、基本数据"><a href="#2、基本数据" class="headerlink" title="2、基本数据"></a>2、基本数据</h2><p>下表是银华基金的基本数据（2022-06-17）：</p><div class="table-container"><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">数值</th><th style="text-align:left">排名</th></tr></thead><tbody><tr><td style="text-align:left">非货币型基金规模</td><td style="text-align:left">2335.18亿</td><td style="text-align:left">20</td></tr><tr><td style="text-align:left">非货币型基金平均规模</td><td style="text-align:left">10.66亿</td><td style="text-align:left">33</td></tr><tr><td style="text-align:left">近5年股票型基金平均收益</td><td style="text-align:left">63.75%</td><td style="text-align:left">26</td></tr><tr><td style="text-align:left">近5年混合型基金平均收益</td><td style="text-align:left">74.56%</td><td style="text-align:left">44</td></tr><tr><td style="text-align:left">金牛奖获奖数</td><td style="text-align:left">8</td><td style="text-align:left"><em>7</em></td></tr><tr><td style="text-align:left">基金经理平均任职年限</td><td style="text-align:left">2年又78天</td><td style="text-align:left">46</td></tr></tbody></table></div><p>非货币性基金规模排名 20，平均规模排名 33，在前面分析的几家公司中属于很一般的水平。</p><p>近 5 年股票型基金平均收益排名 26，混合型基金平均收益排名 44，也比较一般。</p><p>基金公司金牛奖 8 个，排名第 7，这个数据倒是很亮眼。</p><p>基金经理平均任职年限排名 46，亦是很一般。</p><p><strong>按照之前的基金公司筛选标准，银华基金当前的收益水平已经无法进入候选名单</strong>。也就是说，2022 年 1 月至今，银华基金的权益基金平均收益排名又下降了不少。</p><p>不过本着有始有终的态度，今天还是把银华基金分析一下。</p><h3 id="2-1-各类型基金规模占比"><a href="#2-1-各类型基金规模占比" class="headerlink" title="2.1 各类型基金规模占比"></a>2.1 各类型基金规模占比</h3><p>银华基金各类型基金规模占比如下图所示：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/19/16556247187329.jpg" alt=""></p><p>货币基金占比 59%，超过一半，这在已经分析过的基金公司中是头一个。剩下的份额中，混合型基金和债券型基金占了绝大部分。</p><p>一家基金公司的大头是货币型基金，这很难不让人怀疑它的进取心。</p><h3 id="2-2-股票型基金数据"><a href="#2-2-股票型基金数据" class="headerlink" title="2.2 股票型基金数据"></a>2.2 股票型基金数据</h3><p>银华基金股票型基金规模 224 亿，排名 21:</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/19/16556261504661.jpg" alt=""></p><p>近 5 年平均收益水平跑赢了平均水平：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/19/16556261725238.jpg" alt=""></p><p>起初银华基金能被筛选进名单，就是因为它的股票型基金的平均收益较高。但是通过前面的占比图可知，银华基金的股票型基金在整体规模中占比才 3.39%，还不如指数基金。</p><p>由此可见，这个平均收益水平的含金量较低，没有参考意义。</p><h3 id="2-3-混合型基金数据"><a href="#2-3-混合型基金数据" class="headerlink" title="2.3 混合型基金数据"></a>2.3 混合型基金数据</h3><p>银华基金混合型基金规模 1338 亿，排名 17:</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/19/16556262269909.jpg" alt=""></p><p>近 5 年平均收益一般，勉强和同类平均水平持平：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/19/16556261887474.jpg" alt=""></p><p>第 17 的规模排名以及第 44 的平均收益排名，名副其实的大而不强。</p><h3 id="2-4-债券型基金数据"><a href="#2-4-债券型基金数据" class="headerlink" title="2.4 债券型基金数据"></a>2.4 债券型基金数据</h3><p>银华基金债券型基金规模 762 亿，排名 29:</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/19/16556262428002.jpg" alt=""></p><p>下面是它的平均收益水平：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/19/16556262015113.jpg" alt=""></p><p>近 5 年平均收益排名 53，无论是近 3 年还是近 5 年的平均收益水平都跑输同类平均，也是大而不强。</p><h2 id="3、投资理念"><a href="#3、投资理念" class="headerlink" title="3、投资理念"></a>3、投资理念</h2><p>银华基金官网关于投资理念的描述只有简短的一句：</p><blockquote><p>成立以来，银华基金始终坚持做价值投资理念的坚定追随者，不盲目追求短期收益，注重控制投资风险，以细水长流的方式积蓄力量，追求长期持续的稳健回报。</p></blockquote><p>官网这个投资理念看看就好，没什么参考价值。</p><h2 id="4、投研团队"><a href="#4、投研团队" class="headerlink" title="4、投研团队"></a>4、投研团队</h2><p>银华基金的官网并没有关于投研团队的介绍，仅有一页“基金经理秀”，陈列了全部基金经理的简介。</p><p>为了解决基金经理个人能力边界问题，银华基金在投研团队中实行“小组管理制”，小组人员配置齐全，投资风格、逻辑、类型各不相同，尽可能覆盖全行业研究。</p><p>这种制度在一定程度上能帮助基金经理扩大研究面，但是因为是“小”组，分到每个方向的研究人员数量有限，研究程度能有多深，我觉得要打个问号。</p><p>银华基金的明星基金经理李晓星，其小组一共 7 人，每一位都是不同领域的专家，共同管理团队旗下的基金产品，所以我们看到，李晓星当前管理的基金多达 <strong>10</strong> 只，累计规模 480 亿，占银华基金混合型基金总规模的 35.8%！</p><p>相比起来，我还是更喜欢易方达的“大平台，小团队”的模式——研究员选出股票池子，基金经理按照自己的能力圈再从中选出合适的股票。</p><h2 id="5、合规信息"><a href="#5、合规信息" class="headerlink" title="5、合规信息"></a>5、合规信息</h2><p>2017 年，证监会对郭建兴发出市场禁入和行政处罚决定书。2013 年 6 月 1 日至 2015 年 9 月 8 日，时任银华基金经理的郭建兴将因任职基金经理获取的基金未公开信息泄露给张超，共同利用未公开信息从事相关证券交易活动。根据相关法律法规，证监会对郭建兴及张超责令改正，没收违法所得约 273 万元，并处以约 821 万元罚款；同时对郭建兴采取 5 年证券市场禁入措施[1]。</p><p>2020 年 7 月 15 日，天津证监局对银华富裕基金经理周可彦做出行政处罚兴证书。2013 年 10 月 22 日至 2018 年 12 月 26 日期间，周可彦在他担任“银华富裕基金”基金经理期间，把他掌握的“银华富裕基金”未公开交易信息提供给她妻子进行操作，先于、同期或稍晚于“银华富裕基金”账户趋同交易股票 95只，共赚了 121 万，最后被证监会罚没 242.08 万，证券市场禁入5年[2]。</p><h2 id="6、结论"><a href="#6、结论" class="headerlink" title="6、结论"></a>6、结论</h2><p>至此，银华基金的分析告一段落，结论如下：</p><ol><li>规模上，货币型基金占比较高，非货币型基金。</li><li>收益上，非货币积极中占主要部分的混合型基金和债券型基金都表现一般，大二不强。</li><li>合规方面，表现一般，主要是基金经理老鼠仓问题。</li></ol><p>就我个人而言，短期内不会考虑银华基金的产品。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]. 中国证监会市场禁入决定书（郭建兴）, <a href="http://www.csrc.gov.cn/csrc/c101927/c1042096/content.shtml">http://www.csrc.gov.cn/csrc/c101927/c1042096/content.shtml</a><br>[2]. 中国证券监督管理委员会天津监管局行政处罚决定书（周可彦）, <a href="http://www.csrc.gov.cn/tianjin/c103598/c1350412/content.shtml">http://www.csrc.gov.cn/tianjin/c103598/c1350412/content.shtml</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>给自己打个广告。</p><p>由于深知闭门造车的弊端，我建了个微信群，用于交流投资理财心得，欢迎感兴趣的同学入群交流（公众号回复【联系方式】）。</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><em>说明：本文仅为个人投资记录及思考，不构成任何具体的投资建议！</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基金公司</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基金公司分析（七）——易方达</title>
    <link href="/2022/06/12/fund-company-analysis-7/"/>
    <url>/2022/06/12/fund-company-analysis-7/</url>
    
    <content type="html"><![CDATA[<p>在之前的文章 👉 <a href="https://mp.weixin.qq.com/s?__biz=Mzg5NjU0MzU1Mg==&amp;mid=2247484354&amp;idx=1&amp;sn=08665af13118aef6c5971bfed58605cf&amp;chksm=c07e3dedf709b4fb7b77ab64ffa4fa5ff775db9090afc9347cf0c215d00c957a276bf108c384#rd">筛选了一份基金公司名单！</a> 中，为了降低分析成本，利用一些简单的指标，我筛选出了以下几个基金公司（名单不分先后）：</p><div class="table-container"><table><thead><tr><th>基金公司</th><th>状态</th><th>是否长期关注</th></tr></thead><tbody><tr><td>中银基金管理有限公司</td><td><em>已完成</em></td><td>否</td></tr><tr><td>交银施罗德基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>兴证全球基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>嘉实基金管理有限公司</td><td><em>已完成</em></td><td>否</td></tr><tr><td>富国基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>工银瑞信基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>易方达基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>银华基金管理股份有限公司</td><td>待分析</td><td>-</td></tr></tbody></table></div><p>按照顺序，今天来分析一下易方达基金。</p><h2 id="1、公司简介"><a href="#1、公司简介" class="headerlink" title="1、公司简介"></a>1、公司简介</h2><p>易方达基金成立于 2001 年，是目前国内最大的基金管理公司，也是唯一一家非货币规模超过 1 万亿的基金管理公司。</p><p>以下是易方达基金的股权结构：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/12/16550098898090.jpg" alt=""><br>不同于前面分析的 6 家基金公司，易方达的股权结构呈现三个特点：</p><ul><li>股权分散</li><li>没有外资</li><li>员工参与持股</li></ul><p>最主要的三个股东，粤财信托，广东省唯一省属国有信托机构；广发证券，同时也是广发基金的控股股东；盈峰集团，法人代表何剑锋（美的创始人何享健之子），是美的集团关联公司。</p><p>基金公司引入外资，是期望通过外资提升基金公司的产品创新、经营理念、市场营销和人才培养等方面的水平，目前看确实起到很大的作用。但是易方达在没有外资参股的情况下仍然做到了管理规模第一，说明外资参股与否对基金公司的发展并没有决定性作用，还是要看基金公司管理层的能力。</p><p>员工持股（股权激励）是近年来基金公司流行的趋势，但是已经分析的 6 家基金公司竟然都没有员工持股，略微奇怪。</p><h2 id="2、基本数据"><a href="#2、基本数据" class="headerlink" title="2、基本数据"></a>2、基本数据</h2><p>下表是易方达的基本数据（2022-06-10）：</p><div class="table-container"><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">数值</th><th style="text-align:left">排名</th></tr></thead><tbody><tr><td style="text-align:left">非货币型基金规模</td><td style="text-align:left">10883.49亿</td><td style="text-align:left"><strong>1</strong></td></tr><tr><td style="text-align:left">非货币型基金平均规模</td><td style="text-align:left">23.41亿</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left">近5年股票型基金平均收益</td><td style="text-align:left">41.13%</td><td style="text-align:left">56</td></tr><tr><td style="text-align:left">近5年混合型基金平均收益</td><td style="text-align:left">99.52%</td><td style="text-align:left">11</td></tr><tr><td style="text-align:left">金牛奖获奖数</td><td style="text-align:left">10</td><td style="text-align:left"><strong>1</strong></td></tr><tr><td style="text-align:left">基金经理平均任职年限</td><td style="text-align:left">2年又239天</td><td style="text-align:left">11</td></tr></tbody></table></div><p>规模上，非货币型基金规模 10883.49 亿，排名第 1；平均规模 23.41 亿，排名第 4，遥遥领先。</p><p>平均收益上，近 5 年股票型基金收益 41.13%，排名 56，表现较差；近 5 年混合型基金收益 99.52%，排名 11，表现较好。当然实际质量还需要进一步分析。</p><p>金牛奖获奖数 10，和前面的兴证全球并列第 1，表现十分优异。</p><p>基金经理平均任职年限 2 年又 239 天，排名 11，说明易方达的基金经理稳定性较高。</p><h3 id="2-1-各类型基金规模占比"><a href="#2-1-各类型基金规模占比" class="headerlink" title="2.1 各类型基金规模占比"></a>2.1 各类型基金规模占比</h3><p>易方达各类型基金规模占比如下图所示：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/12/16550240284204.jpg" alt=""></p><p>看过前几篇分析的朋友们看这张图会不会感觉似曾相识？这个规模分布和富国基金基本一致。</p><p>混合型基金、债券型基金、货币型基金三足鼎立，各占比 25% 左右；剩下的股票型基金和指数型基金各分去小一半。</p><p>虽然易方达和富国基金的规模占比十分类似，但是规模总量却接近富国的 2 倍，更高的规模会带来的更高管理要求。</p><h3 id="2-2-股票型基金数据"><a href="#2-2-股票型基金数据" class="headerlink" title="2.2 股票型基金数据"></a>2.2 股票型基金数据</h3><p>易方达股票型基金规模 1867.94 亿，排名第 2。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/12/16550248516703.jpg" alt=""></p><p>如此高的规模下，平均收益却表现一般：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/12/16550248752193.jpg" alt=""></p><p>无论是近 3 年平均收益，还是近 5 年平均收益，均远远低于平均水平。虽然股票型基金在易方达全部类型基金中规模占比才第 4，但是 1867 亿的绝对值规模下，如此低的收益水平，还是有点说不过去。</p><h3 id="2-3-混合型基金数据"><a href="#2-3-混合型基金数据" class="headerlink" title="2.3 混合型基金数据"></a>2.3 混合型基金数据</h3><p>易方达混合型基金规模 3947.95 亿，排名第一： </p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/12/16550249570947.jpg" alt=""></p><p>不同于股票型基金，混合型基金的平均收益表现还是不错的：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/12/16550249062980.jpg" alt=""></p><p>近 3 年平均收益 79.19%，近 5 年平均收益 99.52%，均超同类平均水平。</p><h3 id="2-4-债券型基金数据"><a href="#2-4-债券型基金数据" class="headerlink" title="2.4 债券型基金数据"></a>2.4 债券型基金数据</h3><p>易方达混合型基金规模 4319.91 亿，排名第一： </p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/12/16550249386348.jpg" alt=""></p><p>作为三大支柱的债券型基金，其收益水平表现也是相当不错：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/12/16550249206161.jpg" alt=""></p><p>近 3 年平均收益 18.73%，近 5 年平均收益 34.85%，远超同类平均水平。</p><h2 id="3、投资理念"><a href="#3、投资理念" class="headerlink" title="3、投资理念"></a>3、投资理念</h2><p>易方达官网关于投资理念的描述比较少，以下是从易方达官网摘抄关于投资理念的描述：</p><blockquote><p>公司自成立以来始终专注于资产管理业务，基于“深度研究驱动、时间沉淀价值”的投资理念，在主动权益、指数、债券、另类资产等投资领域全面布局，多年来凭借规范的管理与持续稳定的业绩，为客户创造了良好的回报。</p></blockquote><p>虽然描述性文字很少，但是易方达官网还有一个十分有特色的模块：<strong>投资观点</strong>：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/12/16550360393642.jpg" alt=""></p><p>这个板块将基金定期报告中的观点和基金经理的手记汇总展示，并支持按关键字和基金名称筛选（也可按基金经理名字筛选）。</p><p>一个公司的投资理念，最终还是体现在一线的基金经理身上。这一篇篇的手记，从某种程度上，也体现了“深度研究驱动、时间沉淀价值”的理念。</p><h2 id="4、投研团队"><a href="#4、投研团队" class="headerlink" title="4、投研团队"></a>4、投研团队</h2><p>易方达的投研是业内公认最好的。几乎无论哪个风格，哪个方向，都有知名的明星基金经理。</p><p>知乎上有个问题：金融行业的鄙视链是什么样的？</p><p>有个点赞数很高的答案是：</p><blockquote><p>顶级外资PE（黑石华平等）= 头部对冲基金（国内没有对冲基金）&gt; 外资投行（高盛摩根大通等投行部） &gt; MBB咨询（波士顿咨询麦肯锡贝恩）/ 易方达基金投研岗 = 一线VC （顶级VC只有红杉一家，其他都不行，红杉是在外资投行那一档，其他所有VC也就那样）&gt; 三中一华投行部 大公募基金投研岗  二线pevc 二线咨询 &gt; 银行总行 保险公司 &gt; 世界500强 &gt; 四大 &gt; 其他。</p></blockquote><p>这个答案上也能反映出投研实力上，易方达是独一档，而其他公募基金一档。</p><p>根据官网的介绍，易方达的主动权益团队的特色是构建了独具特色的“大平台、小团队”的管理模式。基金经理的权限没有大家想的那么高，并不能买全市场的所有股票，而是只能在投研团队给的股票池子里选。</p><p>这种模式注重过程管理，同时也保证了基金经理有足够的时间深度研究筛选出来的股票，实现超额收益。</p><h2 id="5、合规信息"><a href="#5、合规信息" class="headerlink" title="5、合规信息"></a>5、合规信息</h2><p>2007 年开始，刘芳洁自先后担任易方达基金、万家基金、上海盈象资管）基金经理。在任职期间，其利用基金交易标的股票的未公开信息，控制并操作其母亲“王某蛟”、配偶苗某萍的股票账户，非法获利共计 1184.85 万元。2020 年 9 月 24，证监会发布市场禁入决定书〔2020〕15 号，判决刘芳洁终身市场禁入[2]。</p><h2 id="6、结论"><a href="#6、结论" class="headerlink" title="6、结论"></a>6、结论</h2><p>至此，易方达的分析告一段落，结论如下：</p><ol><li>易方达整体实力（规模、投研实力、金基金牛奖）在全部基金公司中遥遥领先，十分优秀。</li><li>收益上，混合型基金和债券型基金表现优秀，但是股票型基金表现一般。</li><li>投研团队上，明星基金经理众多，特色的“大平台，小团队机制”保证了较高水准的投研水平。</li><li>合规方面，违规信息较少，表现优秀。</li></ol><p>就我个人而言，我会将易方达放到长期观察的名单中。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] 金融行业的鄙视链是什么养的？ <a href="https://www.zhihu.com/question/29668647/answer/2028391460">https://www.zhihu.com/question/29668647/answer/2028391460</a><br>[2] 中国证监会市场禁入决定书（刘芳洁）, <a href="http://www.csrc.gov.cn/csrc/c101927/c1042018/content.shtml">http://www.csrc.gov.cn/csrc/c101927/c1042018/content.shtml</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>给自己打个广告。</p><p>由于深知闭门造车的弊端，我建了个微信群，用于交流投资理财心得，欢迎感兴趣的同学入群交流（公众号回复【联系方式】）。</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><em>说明：本文仅为个人投资记录及思考，不构成任何具体的投资建议！</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基金公司</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#20——居家办公这两周</title>
    <link href="/2022/06/05/invest-pratice-20/"/>
    <url>/2022/06/05/invest-pratice-20/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a></p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更“美好”的事物上。</p><p><strong>道阻且长，行则将至，行而不辍，未来可期！</strong></p><h2 id="1、本月进展"><a href="#1、本月进展" class="headerlink" title="1、本月进展"></a>1、本月进展</h2><p>本月进展如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/05/img4102.PNG" alt="IMG_4102"></p><p>当前进展 4.95%，相比上个月增加了 0.56%。累计亏损开始减少，收益率转正近在眼前。</p><p><strong>本月操作</strong></p><p>长赢等跟投组合：5000<br>主动基金组合：5000<br>指数基金组合：10000（全指信息、恒生科技、消费、养老）</p><p>指数基金组合部分调整了每份买入的额度（500—&gt;2000），买入冲动相比上个月受到明显抑制，买入频率大幅下降。</p><p>在反反复复的犹豫中，5.31 跟着 E 大的右侧买入点加了一些。6.2 日对 5 月的操作进行了一下反思：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/06/05/16544119316911.jpg" alt=""><br>投资就是这样，道理都懂，但只有亲身经历，才能明白知行合一的难。</p><h2 id="2、居家办公这两周"><a href="#2、居家办公这两周" class="headerlink" title="2、居家办公这两周"></a>2、居家办公这两周</h2><p>由于最近北京疫情严重，这两周一直居家办公，说一下我居家办公的一些体验和收获。</p><h3 id="工作效率"><a href="#工作效率" class="headerlink" title="工作效率"></a>工作效率</h3><p>居家办公后，最明显的一个变化就是无效沟通减少了很多，相对应的能专心写代码的时间增加了很多。</p><p>尽管如此，居家的工作效率还是经历一个比较大的起伏，初期效率不错，中间颓废了一段时间，最后经过一番调整，才恢复正常，甚至更高。</p><p>工作效率恢复正常甚至更高是因为看了《软技能》中第 4 篇生产力。</p><p>这一部分内容对我认知刷新最大的是番茄工作法。我一直把番茄工作法当作一个短期提升专注力的方法。但是书中作者认为：</p><p><strong>番茄工作法只有被当作估算和评估的工具使用时，才能发挥它的真正价值！</strong></p><p>即在工作之前，应当规划好每日和每周应该完成的番茄钟数，然后将这些番茄钟分配到详细的工作计划上，并定期对完成情况进行统计。</p><p>使用这种方式，不但能让自己在某个工作上保持专注，而且让自己瞬间能评估自己每日工作的努力程度以及工作能力。</p><p>同时这种方式还解决了另外一个问题：在各种媒体的焦虑渲染下，很多人总为没有做更多的事情而感到焦虑，就好像永远不能放松一样。这个问题的根源在于无法准确的评估自己完成了多少任务，也没有为自己每天要完成多少任务设定目标（任务清单似乎永远都在增长）。但是当你在一天中为自己设置了 x 个番茄钟的工作目标并且达成的时候，你就可以知道自己一天完成了多少工作，这会极大的放松身心，缓解焦虑。</p><p>居家办公的后期，尝试了这种方法后，明显感觉到工作的热情高了很多，工作效率也有了很大的改善。可以说这是我居家办公期间最大的收获了。</p><h3 id="饮食"><a href="#饮食" class="headerlink" title="饮食"></a>饮食</h3><p>刚得知要居家后，立刻去超市囤了不少东西。因为不是长期居家，囤的食材都比较简单，比如速冻水饺、鸡蛋、番茄、茄子、猪肉等。</p><p>饭菜做的比较简单，所以在吃饭上并没有耗费太长时间。但是如果长期居家，做饭的成本势必会大幅增加，甚至可能会超过节省的通勤时间。</p><p>《软技能》中提到，<strong>你应当安排自己的食谱，甚至围绕每天吃什么来形成惯例</strong>！因为决定吃什么以及做什么饭，会浪费你大量的时间和精力。</p><p>看到这个观点的时候，我感触十分深刻。公司有食堂，不用自己做饭，但我每天仍然会花费不少时间纠结吃什么。这也是我更喜欢盒饭，不喜欢自己打菜的原因。</p><p>对于长期远程工作或者习惯在家做饭的朋友，尝试安排自己的食谱，形成惯例，或许节省的时间和精力会远远超出想象。</p><h3 id="核酸"><a href="#核酸" class="headerlink" title="核酸"></a>核酸</h3><p>核酸检测已经成为日常生活的一部分。</p><p>小区楼下就有一个常态化核酸检测点。我现在的习惯是每天中午吃完饭下去做核酸，顺带消消神儿。</p><p>核酸排队+检测大概十来分钟，还是挺快的。</p><p>如果核酸常态化能有效抑制住疫情，恢复人员流动，那每天做一次核酸，想想也不是不能接受🤔</p><h3 id="散步"><a href="#散步" class="headerlink" title="散步"></a>散步</h3><p>一整天居家太闷了，所以每到傍晚我都会散一个小时左右的步。</p><p>6 月份的北京下午 6、7 点温度刚刚好。我所处的位置在北京的西北部，这边不远处群山连绵。每天我就向着太阳一路西行，等太阳完全隐入山峰之后，再背对着夕阳回家。</p><p>平时在公司，差不多时间段也会散一会步。但是那种散步总带有一丝逃离工作的意味。而且很多时候是和同事一起散步，中间会聊工作聊八卦，很难完全放松。</p><p>可惜下周就要回公司上班了。</p><h2 id="回顾与计划"><a href="#回顾与计划" class="headerlink" title="回顾与计划"></a>回顾与计划</h2><p>之前在 <a href="https://mp.weixin.qq.com/s/XWfjJ9WJ8DpxoVpaW1tacg">财务自由实证#7——实证升级了</a> 中，我对实证计划进行了升级，除了例行的<strong>实证进展</strong>模块外，还会有<strong>本月回顾</strong>模块以及<strong>下月计划</strong>模块。</p><p>进过一段时间的执行，发现效果一般。原来的本月回顾和下月计划比较粗糙，回顾部分统计指标单一，基本没有参考价值；计划部分没有能拆分成可量化的工作量，对接下来的工作也没有指导意义。</p><p>目前正在应用《软技能》提到的一些方法对工作方式进行优化调整，下一篇会尝试一下新的展示方式。</p><p>本月这部分就不更新了。</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><em>说明：本文仅为个人投资记录及思考，不构成任何具体的投资建议！</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基金公司分析（六）——工银瑞信</title>
    <link href="/2022/05/31/fund-company-analysis-6/"/>
    <url>/2022/05/31/fund-company-analysis-6/</url>
    
    <content type="html"><![CDATA[<p>在之前的文章 👉 <a href="https://mp.weixin.qq.com/s?__biz=Mzg5NjU0MzU1Mg==&amp;mid=2247484354&amp;idx=1&amp;sn=08665af13118aef6c5971bfed58605cf&amp;chksm=c07e3dedf709b4fb7b77ab64ffa4fa5ff775db9090afc9347cf0c215d00c957a276bf108c384#rd">筛选了一份基金公司名单！</a> 中，为了降低分析成本，利用一些简单的指标，我筛选出了以下几个基金公司（名单不分先后）：</p><div class="table-container"><table><thead><tr><th>基金公司</th><th>状态</th><th>是否长期关注</th></tr></thead><tbody><tr><td>中银基金管理有限公司</td><td><em>已完成</em></td><td>否</td></tr><tr><td>交银施罗德基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>兴证全球基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>嘉实基金管理有限公司</td><td><em>已完成</em></td><td>否</td></tr><tr><td>富国基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>工银瑞信基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>易方达基金管理有限公司</td><td>待分析</td><td>-</td></tr><tr><td>银华基金管理股份有限公司</td><td>待分析</td><td>-</td></tr></tbody></table></div><p>按照顺序，今天来分析一下工银瑞信。</p><h2 id="1、公司简介"><a href="#1、公司简介" class="headerlink" title="1、公司简介"></a>1、公司简介</h2><p>工银瑞信基金管理有限公司是由中国工商银行和瑞士信贷合资设立的基金管理公司，成立于2005年6月。</p><p>下面是工银瑞信的股权结构示意图：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/31/16538017590719.jpg" alt=""></p><p>工银瑞信也是一家中外合资的基金管理公司。</p><p>忽然发现，前面分析过的 5 个基金公司都是中外合资，看来在公募基金行业中外合资是一种普遍现象。这说明公募基金行业对外开放程度还是比较高的。</p><h2 id="2、基本数据"><a href="#2、基本数据" class="headerlink" title="2、基本数据"></a>2、基本数据</h2><p>下表是工银瑞信的基本数据（2022-01-23）：</p><div class="table-container"><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">数值</th><th style="text-align:left">排名</th></tr></thead><tbody><tr><td style="text-align:left">非货币型基金规模</td><td style="text-align:left">4271.73亿</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">非货币型基金平均规模</td><td style="text-align:left">15.54亿</td><td style="text-align:left">28</td></tr><tr><td style="text-align:left">近5年股票型基金平均收益</td><td style="text-align:left">143.3%</td><td style="text-align:left">6</td></tr><tr><td style="text-align:left">近5年混合型基金平均收益</td><td style="text-align:left">128.37%</td><td style="text-align:left">13</td></tr><tr><td style="text-align:left">金牛奖获奖数</td><td style="text-align:left">3</td><td style="text-align:left"><strong>20</strong></td></tr><tr><td style="text-align:left">基金经理平均任职年限</td><td style="text-align:left">2年又210天</td><td style="text-align:left">10</td></tr></tbody></table></div><p>非货币型基金规模靠前排名第 10，平均规模排名 28，稍差一点。</p><p>比较难得的是，近 5 年股票型基金和混合型基金平均收益排名都不错，不过真实水平还要结合其规模进一步分析。</p><p>金牛奖获奖数 3，排名 20，比较一般，近 6 年颗粒无收。</p><p>基金经理平均任职年限部分，排名第 10，可见基金经理的稳定性较高。</p><h3 id="2-1-各类型基金规模占比"><a href="#2-1-各类型基金规模占比" class="headerlink" title="2.1 各类型基金规模占比"></a>2.1 各类型基金规模占比</h3><p>工银瑞信各类型积极规模占比如下图所示：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/31/16538180373444.jpg" alt=""></p><p>这个占比比较有意思，货币型基金占总规模的一半，债券型基金占剩下规模的一半，股票型基金和混合型基金又分别占剩下规模的一半！</p><p>权益类基金规模占比不到 25%，在分析过的基金公司中，这个比例<strong>仅高于重债券的中银基金</strong>！</p><p>不过合计近 2000 亿的规模绝对值表明工银瑞信在权益类基金上的实力仍不容小觑。</p><h3 id="2-2-股票型基金数据"><a href="#2-2-股票型基金数据" class="headerlink" title="2.2 股票型基金数据"></a>2.2 股票型基金数据</h3><p>工银瑞信旗下股票型基金有 25 只，总规模 905.09 亿。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/31/16538214499499.jpg" alt=""></p><p>下图是股票型基金不同阶段的收益水平：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/31/16538214684322.jpg" alt=""></p><p>无论是是近 3 年还是近 5 年平均收益水平，都显著超过同类平均。</p><p><em>注：本小节数据来源于天天基金，截止日期 2022-05-27。</em></p><h3 id="2-3-混合型基金数据"><a href="#2-3-混合型基金数据" class="headerlink" title="2.3 混合型基金数据"></a>2.3 混合型基金数据</h3><p>工银瑞信旗下混合型基金有 34 只，总规模 1061.77 亿。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/31/16538317860053.jpg" alt=""></p><p>下图是混合型基金不同阶段的收益水平：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/31/16538318118679.jpg" alt=""></p><p>近 5 年和近 3 年的平均收益也都是超过平均水平的，不过超过的不多，算是差强人意吧。</p><p><em>注：本小节数据来源于天天基金，截止日期 2022-05-27。</em></p><h3 id="2-4-债券型基金数据"><a href="#2-4-债券型基金数据" class="headerlink" title="2.4 债券型基金数据"></a>2.4 债券型基金数据</h3><p>工银瑞信债券型基金总规模 2219.07 亿，在其非货币性基金中占比超 50%，排名第 7。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/31/16538460963575.jpg" alt=""></p><p>然而它的收益水平却很一般，仅仅是和平均水平持平。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/31/16538318692315.jpg" alt=""></p><p>可以说，在债券型基金上，工银基金的实力明显配不上其规模。考虑到工银瑞信是一家银行系基金管理公司，也就能理解为何有如此的规模了。</p><p><em>注：本小节数据来源于天天基金，截止日期 2022-05-27。</em></p><h2 id="3、投资理念"><a href="#3、投资理念" class="headerlink" title="3、投资理念"></a>3、投资理念</h2><p>以下是从工银瑞信官网找到的关于投资理念的描述：</p><blockquote><p>自成立以来，公司坚持“以稳健的投资管理，为客户提供卓越的理财服务”为使命，依托强大的股东背景稳健的经营理念、科学的投研体系、严密的风控机制和资深的管理团队，立足市场化、专业化、规范化、国际化，坚持“稳健投资、价值投资、长期投资”，致力于为广大投资者提供一流的投资管理服务。</p></blockquote><p>虽然“价值投资”、“长期投资”的描述已经泛滥了，但是从它的产品上也能看到一些痕迹。</p><p>以工银瑞信的明星产品工银前沿医疗为例，自成立以来，其前十大持仓占比始终维持在 50% 以上，换手率基本维持在 150% 左右，可见操作上是比较符合价值投资和长期投资的特征的。</p><h2 id="4、投研团队"><a href="#4、投研团队" class="headerlink" title="4、投研团队"></a>4、投研团队</h2><p>关于投研团队的描述，公司官网也比较少：</p><blockquote><p>公司秉持“以人为本”的理念，全方位引入国内外优秀人才，组建了一支风格稳健、诚信敬业、创新进取、团结协作的专业团队。目前，公司(含子公司)共有员工706人，约73%的员工拥有硕士以上学历。公司投研团队由资深基金经理和研究员组成，投研人员177人,投资人员平均拥有约13年的从业经验。</p></blockquote><p>虽然描述有点短，但是近年来，工银基金涌现了一批明星基金经理，如赵蓓、袁芳、谭东寒等。</p><p>另外，据报道[2]，工银瑞信主动权益基金经理团队中，自己培养的基金经理占比超过 90%，像赵蓓、袁芳、杜洋、单文等，都是由内部培养出来的。</p><p>由此可见工银瑞信投研团队实力以及培养机制。</p><h2 id="5、合规信息"><a href="#5、合规信息" class="headerlink" title="5、合规信息"></a>5、合规信息</h2><p>2016 年 6 月，原工银瑞信基金经理王勇因“老鼠仓”被有期徒刑2年（缓刑2年），并处罚金250万元。2011年11月至2015年1月，王勇利用管理基金账户掌握的信息，通过其亲属账户违规买卖股票牟利，四年间共牟利249万余元[3]。</p><p>2018 年 3 月 26 日，胡拓夫利用担任工银瑞信基金中央交易室股票交易员、副总监，负责执行基金经理的指令下单交易股票，知悉基金交易信息的职务便利，违反规定，使用其实际控制的胡某、耿某名下证券账户，亲自或明示、暗示他人同期于指令交易买入相同股票，趋同买入成交金额共计11.1亿余元，非法获利共计4186.071662万元[4]。</p><p>2019 年 2 月，根据中国人民银行营业管理部门行政处罚信息公示（银管罚【2019】3号）显示，工银瑞信基金违反《反洗钱法》，中国人民银行营业管理部对工银瑞信基金作出行政处罚，对工银瑞信基金及及相关责任人分别罚款 190 万元、17 万元，合计罚没207 万元[5]。原因是银瑞信基金未按照规定履行客户身份识别义务、未按照规定报送可疑交易报告。</p><p>前面提到过，工银瑞信近 6 年在金牛基金管理公司奖项上颗粒无收，结合金牛基金管理公司奖项的评选规则，我怀疑可能因为违规才导致无法评选上。</p><h2 id="6、结论"><a href="#6、结论" class="headerlink" title="6、结论"></a>6、结论</h2><p>至此，工银瑞信的分析告一段落，结论如下：</p><ol><li>工银基金在股票型基金和混合型基金上表现优异，在债券型基金上大而不强。</li><li>投研团队上，工银瑞信培养出了不少明星基金经理，内部培养率高；基金经理平均任职年限较长，稳定性较高。</li><li>合规上，工银基金表现较差。近几年旗下多位基金经理因老鼠仓被处罚；19 年公司也因为未按照规定履行客户识别义务、未按照规定报送可以交易报告被处罚。</li></ol><p>就我个人而言，我会将工银瑞信放到长期观察的名单中。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]. 中国基金业金牛奖评选规则，<a href="https://www.amac.org.cn/businessservices_2025/fundevaluationbusiness/jjpjyw_jjpjiang/jjpj_zgzqb/zgzqb_pjff/202004/P020200423691517042597.pdf">https://www.amac.org.cn/businessservices_2025/fundevaluationbusiness/jjpjyw_jjpjiang/jjpj_zgzqb/zgzqb_pjff/202004/P020200423691517042597.pdf</a><br>[2]. 基金业“中生代”力量崛起丨明星基金经理“人才”梯队建设，均衡发展还是“掐尖”？, <a href="https://m.21jingji.com/article/20211118/herald/c327959ac734daac7ae594628a9286a7_zaker.html">https://m.21jingji.com/article/20211118/herald/c327959ac734daac7ae594628a9286a7_zaker.html</a><br>[3]. 工银瑞信基金经理涉老鼠仓：离职时并未察觉其存在问题, <a href="https://guba.eastmoney.com/news,001409,669161509.html">https://guba.eastmoney.com/news,001409,669161509.html</a><br>[4]. 工银瑞信原交易室副总监老鼠仓案二审：获刑7年罚9000万, <a href="https://baijiahao.baidu.com/s?id=1596102909508982437&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1596102909508982437&amp;wfr=spider&amp;for=pc</a><br>[5]. 工银瑞信基金因违反《反洗钱法》遭央行处罚190万元, <a href="https://baijiahao.baidu.com/s?id=1625531278056929696&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1625531278056929696&amp;wfr=spider&amp;for=pc</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>给自己打个广告。</p><p>由于深知闭门造车的弊端，我建了个微信群，用于交流投资理财心得，欢迎感兴趣的同学入群交流（公众号回复【联系方式】）。</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><em>说明：本文仅为个人投资记录及思考，不构成任何具体的投资建议！</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基金公司</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基金公司分析（五）——富国基金</title>
    <link href="/2022/05/21/fund-company-analysis-5/"/>
    <url>/2022/05/21/fund-company-analysis-5/</url>
    
    <content type="html"><![CDATA[<p>在之前的文章 👉 <a href="https://mp.weixin.qq.com/s?__biz=Mzg5NjU0MzU1Mg==&amp;mid=2247484354&amp;idx=1&amp;sn=08665af13118aef6c5971bfed58605cf&amp;chksm=c07e3dedf709b4fb7b77ab64ffa4fa5ff775db9090afc9347cf0c215d00c957a276bf108c384#rd">筛选了一份基金公司名单！</a> 中，为了降低分析成本，利用一些简单的指标，我筛选出了以下几个基金公司（名单不分先后）：</p><div class="table-container"><table><thead><tr><th>基金公司</th><th>状态</th><th>是否长期关注</th></tr></thead><tbody><tr><td>中银基金管理有限公司</td><td><em>已完成</em></td><td>否</td></tr><tr><td>交银施罗德基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>兴证全球基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>嘉实基金管理有限公司</td><td><em>已完成</em></td><td>否</td></tr><tr><td>富国基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>工银瑞信基金管理有限公司</td><td>待分析</td><td>-</td></tr><tr><td>易方达基金管理有限公司</td><td>待分析</td><td>-</td></tr><tr><td>银华基金管理股份有限公司</td><td>待分析</td><td>-</td></tr></tbody></table></div><p>按照顺序，今天来分析一下富国基金。</p><h2 id="1、公司简介"><a href="#1、公司简介" class="headerlink" title="1、公司简介"></a>1、公司简介</h2><p>富国基金成立于 1999 年，和嘉实基金一样，是首批成立的十家基金管理公司。公司注册资本 5.2 亿，总部位于上海。</p><p>下面是富国基金的股权示意图：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/21/16528092212106.jpg" alt=""></p><p>显然，富国基金也是一家中外合资的基金管理公司。</p><p>值得一提的是，2003 年加拿大蒙特利尔银行就完成了对富国基金的参股，因此富国基金也是首批十家基金管理公司中第一家实现外资参股的基金公司。</p><h2 id="2、基本数据"><a href="#2、基本数据" class="headerlink" title="2、基本数据"></a>2、基本数据</h2><p>下表是富国基金的基本数据（2022-01-23）：</p><div class="table-container"><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">数值</th><th style="text-align:left">排名</th></tr></thead><tbody><tr><td style="text-align:left">非货币型基金规模</td><td style="text-align:left">5936.56亿</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">非货币型基金平均规模</td><td style="text-align:left">15.54亿</td><td style="text-align:left">15</td></tr><tr><td style="text-align:left">近5年股票型基金平均收益</td><td style="text-align:left">77.04%</td><td style="text-align:left">41</td></tr><tr><td style="text-align:left">近5年混合型基金平均收益</td><td style="text-align:left">153.44%</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">金牛奖获奖数</td><td style="text-align:left">9</td><td style="text-align:left"><strong>3</strong></td></tr><tr><td style="text-align:left">基金经理平均任职年限</td><td style="text-align:left">2年又62天</td><td style="text-align:left">41</td></tr></tbody></table></div><p>非货币基金总规模排名第 5，平均规模排名第 15，一个比较不错的水平。</p><p>近 5 年平均收益上，股票型基金表现一般，而混合型基金表现十分优秀，它们的含金量如何，下面我们再分析。</p><p>金牛奖获奖数量上，一共获得 9 座，和上一篇的嘉实基金并列第三。这次我特地看了下获奖时间分布，十分均匀，可见富国基金的实力相对比较稳定。</p><p>基金经理平均任职年限上，排名 41，表现较差。</p><p>整体来看，这份基本数据还是不错的，比嘉实基金好了不止一个档次！</p><h3 id="2-1-各类型基金规模占比"><a href="#2-1-各类型基金规模占比" class="headerlink" title="2.1 各类型基金规模占比"></a>2.1 各类型基金规模占比</h3><p>富国基金各类型基金规模占比如下图所示：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/21/16530595783470.jpg" alt="各类型基金规模占比"><br>很明显，富国基金的混合型基金、债券型基金和货币型基金规模呈现三足鼎立的局面。</p><p>这个规模分布和之前分析过的 <a href="https://mp.weixin.qq.com/s/DcDpofA4YtOs4npZeqYlmw">基金公司分析（二）——交银施罗德</a> 比较类似。</p><p><em>注：本小节数据来源于天天基金，截止日期 2022-05-20。</em></p><h3 id="2-2-股票型基金数据"><a href="#2-2-股票型基金数据" class="headerlink" title="2.2 股票型基金数据"></a>2.2 股票型基金数据</h3><p>富国基金旗下共有 110 只基金，总规模 864.88 亿。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/21/16530598837270.jpg" alt=""></p><p>下图是股票型基金不同阶段的收益水平：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/21/16530599146128.jpg" alt=""></p><p>除了近 3 年收益水平显著高于平均水平外，其余阶段均低于平均水平。</p><p>虽然该类型基金规模在富国各类型基金规模中仅排第 4，但是 800 多亿的规模在同类型基金中排名 11。</p><p>可见，富国基金在股票型基金上，量和质是不匹配的。</p><p><em>注：本小节数据来源于天天基金，截止日期 2022-05-20。</em></p><h3 id="2-3-混合型基金数据"><a href="#2-3-混合型基金数据" class="headerlink" title="2.3 混合型基金数据"></a>2.3 混合型基金数据</h3><p>规模上，富国基金的混合型基金规模 2564.89 亿，同类型基金规模排名第 4，排名较高。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/21/16530604423293.jpg" alt=""></p><p>收益上，近 5 年平均收益 153.44%，排名第 3，且无论是近 5 年，还是近 3 年亦或是近 1 年和近 6 个月，平均收益均超过平均水平。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/21/16530604584523.jpg" alt=""></p><p>由此可见，富国基金在其基本盘混合型基金上，确实做到了规模和质量齐头并进，表现优异。</p><p><em>注：本小节数据来源于天天基金，截止日期 2022-05-20。</em></p><h3 id="2-4-债券型基金数据"><a href="#2-4-债券型基金数据" class="headerlink" title="2.4 债券型基金数据"></a>2.4 债券型基金数据</h3><p>规模上，富国基金的债券型基金规模 2423.57 亿，同类型规模排名第 4，和混合型基金十分类似。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/21/16530608916822.jpg" alt=""></p><p>收益上，无论是近 5 年，还是近 3 年亦或是近 1 年和近 6 个月，平均收益均超过平均水平。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/21/16530609810156.jpg" alt=""></p><p>可见，富国基金在债券型基金上无论是量还是质，都表现不错。</p><p><em>注：本小节数据来源于天天基金，截止日期 2022-05-20。</em></p><h2 id="3、投资理念"><a href="#3、投资理念" class="headerlink" title="3、投资理念"></a>3、投资理念</h2><p>富国基金官网没有专门介绍投资理念，只在重点投资方向——权益投资介绍中有部分描述：</p><blockquote><p>富国基金权益投资形成了以“自下而上”的成长型投资为主的风格。坚持“自下而上”精选个股（而不是仓位选择）的投资理念；投资的个股呈现成长股特征；注重长期投资，组合换手率低，追求长期业绩优异。</p><p>富国基金的十六字方针：“深入研究、自下而上、尊重个性、长期回报”。</p></blockquote><p>这个投资理念从我们熟知的明星基金——富国天惠能很明显的感受到。</p><p>值得一提的是，富国基金官网用一页专门介绍了它的风险管理体系。前面介绍过的基金公司中，只有 <a href="https://mp.weixin.qq.com/s/b18ogNjBMJM7V7xHVVK15g">基金公司分析（三）——兴证全球</a> 在官网着重强调了风险管理。</p><h2 id="4、投研团队"><a href="#4、投研团队" class="headerlink" title="4、投研团队"></a>4、投研团队</h2><p>富国基金并没有在官网详细介绍它的投研团队，只在一篇官方资讯中找到如下描述：</p><blockquote><p>在投研团队建设方面，富国基金坚持稳健发展理念，建立并完善平台型公司管理机制，通过打造实力强大、梯队完备的投研平台来支撑管理资管规模的发展。其中，仅富国的主动权益投研平台，就有约百人的投研团队对股票市场进行深度研究，实现重点行业全覆盖。</p></blockquote><p>虽然相关描述不多，但是富国基金的明星基金经理很多，从公募基金第一代研究员陈戈、16 年专情一只基金的朱少醒等明星基金经理能一窥富国基金投研团队的优秀。</p><p>需要注意的是，富国基金基金经理平均任职年限仅排名 40，流动性较高。</p><h2 id="5、合规信息"><a href="#5、合规信息" class="headerlink" title="5、合规信息"></a>5、合规信息</h2><p>2013 年，富国基金官网宣传认购某基金大于等于 2 万元，有 50 元返现，违反《证券投资基金销售管理办法》第八十二条第二款的规定：基金销售机构从事基金销售活动中，不得采取抽奖、回扣或者送实物、保险、基金份额等方式。</p><p>2014 年 1 月，富国基金基金经理饶刚受到中国证监会上海监管局出具的行政监管措施，原因未知。饶刚是债券型基金的元老人物，层荣国 2010 年基金特别基金经理奖（唯一固定收益获奖者），现为睿远基金基金经理。</p><p>整体来看，违规信息较少，合规表现良好。</p><h2 id="6、结论"><a href="#6、结论" class="headerlink" title="6、结论"></a>6、结论</h2><p>至此，富国基金的分析告一段落，结论如下：</p><ol><li>富国基金的基本盘混合型基金和债券型基金，无论规模还是收益，均位居前列，远远超出平均水平，<strong>既大又强</strong>，表现优异。</li><li>投研团队上，基金经理人数众多，但平均任职年限较短，呈现人数多、流动性高的特点。</li></ol><p>就我个人而言，我会长期关注富国基金<br>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]. 富国基金何以公然违规, <a href="http://news.sohu.com/20130723/n382332720.shtml">http://news.sohu.com/20130723/n382332720.shtml</a><br>[2]. 富国基金管理有限公司关于富国天盈分级债券型证券投资基金基金经理变更的公告, <a href="http://fund.eastmoney.com/gonggao/150041,AN201403260005318045.html">http://fund.eastmoney.com/gonggao/150041,AN201403260005318045.html</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>给自己打个广告。</p><p>由于深知闭门造车的弊端，我建了个微信群，用于交流投资理财心得，欢迎感兴趣的同学入群交流（公众号回复【联系方式】）。</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><em>说明：本文仅为个人投资记录及思考，不构成任何具体的投资建议！</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基金公司</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基金公司分析（四）——嘉实基金</title>
    <link href="/2022/05/15/fund-company-analysis-4/"/>
    <url>/2022/05/15/fund-company-analysis-4/</url>
    
    <content type="html"><![CDATA[<p>在之前的文章 👉 <a href="https://mp.weixin.qq.com/s?__biz=Mzg5NjU0MzU1Mg==&amp;mid=2247484354&amp;idx=1&amp;sn=08665af13118aef6c5971bfed58605cf&amp;chksm=c07e3dedf709b4fb7b77ab64ffa4fa5ff775db9090afc9347cf0c215d00c957a276bf108c384#rd">筛选了一份基金公司名单！</a> 中，为了降低分析成本，利用一些简单的指标，我筛选出了以下几个基金公司（名单不分先后）：</p><div class="table-container"><table><thead><tr><th>基金公司</th><th>状态</th><th>是否长期关注</th></tr></thead><tbody><tr><td>中银基金管理有限公司</td><td><em>已完成</em></td><td>否</td></tr><tr><td>交银施罗德基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>兴证全球基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>嘉实基金管理有限公司</td><td><em>已完成</em></td><td>否</td></tr><tr><td>富国基金管理有限公司</td><td>待分析</td><td>-</td></tr><tr><td>工银瑞信基金管理有限公司</td><td>待分析</td><td>-</td></tr><tr><td>易方达基金管理有限公司</td><td>待分析</td><td>-</td></tr><tr><td>银华基金管理股份有限公司</td><td>待分析</td><td>-</td></tr></tbody></table></div><p>按照顺序，今天来分析一下嘉实基金。</p><h2 id="1、公司简介"><a href="#1、公司简介" class="headerlink" title="1、公司简介"></a>1、公司简介</h2><p>嘉实基金管理有限公司，成立于1999年3月，国内最早成立的十家基金管理公司之一，现已发展为具有“全牌照”业务的综合性国际化资产管理集团。</p><p>下图是嘉实基金的股权结构：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/15/jia-shi-ji-jingu-quan-jie-gou.jpg" alt="嘉实基金-股权结构"></p><p>其中 DWS Investment Singapore Limited 是德意志资产管理（亚洲）有限公司下属子公司。</p><p>因此，嘉实基金也是一家中外合资的基金管理公司。</p><h2 id="2、基本数据"><a href="#2、基本数据" class="headerlink" title="2、基本数据"></a>2、基本数据</h2><p>下表是嘉实基金的基本数据（2022-01-23）：</p><div class="table-container"><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">数值</th><th style="text-align:left">排名</th></tr></thead><tbody><tr><td style="text-align:left">非货币型基金规模</td><td style="text-align:left">4291.49亿</td><td style="text-align:left">9</td></tr><tr><td style="text-align:left">非货币型基金平均规模</td><td style="text-align:left">12.23亿</td><td style="text-align:left">32</td></tr><tr><td style="text-align:left">近5年股票型基金平均收益</td><td style="text-align:left">102.62%</td><td style="text-align:left">21</td></tr><tr><td style="text-align:left">近5年混合型基金平均收益</td><td style="text-align:left">78.34%</td><td style="text-align:left">76</td></tr><tr><td style="text-align:left">金牛奖获奖数</td><td style="text-align:left">9</td><td style="text-align:left"><strong>3</strong></td></tr><tr><td style="text-align:left">基金经理平均任职年限</td><td style="text-align:left">2年又95天</td><td style="text-align:left">34</td></tr></tbody></table></div><p>基本数据中，近 5 年混合型基金平均收益表现较差，非货币基金平均规模排名一般。</p><p>表现较好的是金牛奖获奖数，排名第 3。由于金牛奖获奖数和近 5 年平均收益排名不是很匹配，所以我又仔细看了下嘉实基金获奖的时间分布，发现它的获奖时间集中在 2005～2014，这 10 年一共获奖 8 次，而近 7 年仅 2018 获奖一次。</p><p>和嘉实基金类似的还有华夏基金，14 年之前频频获奖，15 年之后颗粒无收。</p><p>由此可见，嘉实基金近些年掉队明显。</p><p><em>注：基本数据更新日期截止 2021-12-19，懒得更新了，5 个多月公司基本面不至于发生根本性变化。</em></p><h3 id="2-1-各类型基金规模占比"><a href="#2-1-各类型基金规模占比" class="headerlink" title="2.1 各类型基金规模占比"></a>2.1 各类型基金规模占比</h3><p>嘉实基金各类型基金规模占比如下图所示：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/15/16524589076838.jpg" alt="各类型基金规模占比"></p><p>不同于重债券的中银和混合型基金、债券型基金、货币型基金三足鼎立的交银，也不同于混合型基金、货币型基金并重的兴证全球，嘉实基金在货币型基金、股票型基金、混合型基金和债券型基金这四种主流型基金上齐头并进，均衡发展。</p><p><em>注：本小节数据来源于天天基金，截止日期 2022-05-14。</em></p><h3 id="2-2-股票型基金数据"><a href="#2-2-股票型基金数据" class="headerlink" title="2.2 股票型基金数据"></a>2.2 股票型基金数据</h3><p>嘉实基金旗下有 117 只股票型基金，总规模 943.83 亿。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/15/16524598816841.jpg" alt=""></p><p>下图是嘉实基金股票行基金近年来的平均收益情况：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/15/16525421323136.jpg" alt=""></p><p>除了近 5 年平均收益跑赢同类平均水平（排名 21）外，其余时间段都和平均水平持平，这个水平只能说是差强人意。</p><p>结合前面的筛选标准：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/15/jie-ping20220514-234134.png" alt="基金公司筛选标准"><br>如果平均收益水平再低一点，嘉实基金就要跌出我们的榜单了。</p><p>再看一下全市场股票型基金和嘉实的股票型基金规模增长趋势对比图：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/15/16525433113426.jpg" alt=""><br>全市场股票型基金规模上涨 214%，同期嘉实股票型基金规模上涨 73%，远远不及平均水平。</p><p>这也印证了最初的结论：<strong>嘉实基金近几年正在逐渐掉队</strong>。</p><p><em>注：本小节数据来源于天天基金，截止日期 2022-05-14。</em></p><h3 id="2-3-混合型基金数据"><a href="#2-3-混合型基金数据" class="headerlink" title="2.3 混合型基金数据"></a>2.3 混合型基金数据</h3><p>截至目前，嘉实基金旗下的混合型基金有 160 只，总规模 1663.12 亿。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/15/16525435977201.jpg" alt=""></p><p>规模不算小，然而它的平均收益却很难看：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/15/16525435690026.jpg" alt=""></p><p>近 3 年和近 5 年平均收益显著低于平均水平，根据前面的基本数据，它的混合型基金近 5 年平均收益排名才 76。</p><p>虽然前面交银、兴全的股票型基金平均收益排名也很低，但是他们的规模都很小，并不是公司的主力产品，能够理解。</p><p>混合型基金规模在嘉实基金整体规模中，占比达 21.37%，去掉货币基金后，更是高达 36.8%！</p><p>主力产品的平均收益如此之差，实在是出乎意料！</p><p><em>注：本小节数据来源于天天基金，截止日期 2022-05-14。</em></p><h3 id="2-4-债券型基金数据"><a href="#2-4-债券型基金数据" class="headerlink" title="2.4 债券型基金数据"></a>2.4 债券型基金数据</h3><p>下图是嘉实基金债券型基金的数据：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/15/16525550300418.jpg" alt=""></p><p>1391.32 亿的规模，初看还行，但是平均收益却不够看了。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/15/16525552615431.jpg" alt=""></p><p>无论是哪个时间段，嘉实基金债券型基金的平均收益都低于平均水平。</p><p><em>注：本小节数据来源于天天基金，截止日期 2022-05-14。</em></p><h2 id="3、投资理念"><a href="#3、投资理念" class="headerlink" title="3、投资理念"></a>3、投资理念</h2><p>下面是从嘉实基金官网找到的投资理念相关的描述：</p><blockquote><p>长期以来，嘉实基金就通过基本面研究去找到未来最好的行业和最好的公司，再通过投资去实现我们对于公司未来价值的创造和判断。所以，无论未来中国市场的成长潜力方向如何演变和交叉，我们为投资人创造回报的投资逻辑都不会变，就是<strong>坚持深度研究驱动的基本面投资为客户带来的价值。</strong></p><p>深度研究是嘉实持续为客户创造长期回报的核心支柱之一。自成立以来，嘉实始终坚守“<strong>研究驱动投资</strong>”的投资理念，将深入的基本面研究与数量研究相结合，通过对宏观、策略、行业和公司等全方位深入研究，发掘财富价值，为实现客户资产长期稳定增值提供有价值的决策依据。</p></blockquote><p>“研究驱动投资”的投资理念听起来怪怪的，难道还有“非研究驱动投资”？</p><p>官网这个投资理念看看就好，没什么参考价值。</p><h2 id="4、投研团队"><a href="#4、投研团队" class="headerlink" title="4、投研团队"></a>4、投研团队</h2><p>嘉实基金官网上关于投研团队的描述只有一句：</p><blockquote><p>发展至今，嘉实投研能力已覆盖精品股票、基石固收、Super ETF、海外投资、资产配置五大投资能力，拥有近300人的投研团队。</p></blockquote><p>天天基金最新数据显示，嘉实基金目前有 81 位基金经理，在 182 家基金公司中排名第一，而基金经理平均任职年限排名 37。这说明嘉实基金投研团队存在人员多、变动频繁的特点。</p><p>在网络上搜索嘉实基金投研团队的信息，也频频看到“青黄不接”、“大幅裁员”等字样，进一步佐证了上面的观点。</p><h2 id="5、合规信息"><a href="#5、合规信息" class="headerlink" title="5、合规信息"></a>5、合规信息</h2><p>网络上能搜到的嘉实基金违规的信息很少，有一条 18 年的新闻，因为前几年的内部交易，嘉实基金收到了证监会的行政处罚事先告知书[1]，但是在证监会的官网上，并没有搜到最终的行政处罚决定。</p><p>由此可见，在合规这一部分，嘉实基金做得还是不错的。</p><h2 id="6、结论"><a href="#6、结论" class="headerlink" title="6、结论"></a>6、结论</h2><p>至此，嘉实基金的分析告一段落。总结如下：</p><ol><li>嘉实基金整体规模处于全部基金公司前列，但是近几年呈现明显的掉队趋势，平均收益表现一般，掉队明显，基金规模<strong>大而不强</strong>。</li><li>投研团队上，基金经理人数众多，但是平均任职年限较短，呈现<strong>人数多、流动性高</strong>的特点。</li></ol><p>就我个人而言，目前不会考虑这家公司的任何产品。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]. 因内幕交易被罚？6家基金公司出来说话了, <a href="http://fund.eastmoney.com/a/1593,20180529879071835.html">http://fund.eastmoney.com/a/1593,20180529879071835.html</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>给自己打个广告。</p><p>由于深知闭门造车的弊端，我建了个微信群，用于交流投资理财心得，欢迎感兴趣的同学入群交流（公众号回复【联系方式】）。</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><em>说明：本文仅为个人投资记录及思考，不构成任何具体的投资建议！</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基金公司</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#19——钻石坑了，然后呢？</title>
    <link href="/2022/05/04/invest-pratice-19/"/>
    <url>/2022/05/04/invest-pratice-19/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a></p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更“美好”的事物上。</p><p><strong>道阻且长，行则将至，行而不辍，未来可期！</strong></p><h2 id="1、本月进展"><a href="#1、本月进展" class="headerlink" title="1、本月进展"></a>1、本月进展</h2><p>本月进展如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/04/png-tu-xiange2839d02bb3f1.png" alt="PNG图像-E2839D02BB3F-1"></p><p>当前进展 4.39%，相比上个月增加了 0.29%。</p><p>累计亏损进一步扩大，但是听到 E 大宣布钻石坑的消息后，这点亏损也就不值一提了。</p><p><strong>本月操作</strong></p><div class="table-container"><table><thead><tr><th>组合</th><th>操作</th><th>金额</th></tr></thead><tbody><tr><td>跟投组合</td><td>长赢跟投</td><td>5000</td></tr><tr><td>它山之石</td><td>定投1份+加投</td><td>10000</td></tr><tr><td>积水成渊</td><td>信息、传媒、养老、中概若干</td><td>11500</td></tr></tbody></table></div><p>从开始弄指数基金组合到现在，暴露了不少问题，如一份金额过低，买入频率太高等（后面有分析），节奏控制的很差，后续会做一些优化，让节奏更舒服些。</p><h2 id="2、钻石坑了，然后呢？"><a href="#2、钻石坑了，然后呢？" class="headerlink" title="2、钻石坑了，然后呢？"></a>2、钻石坑了，然后呢？</h2><p>4 月 25 日，随着 E 大的一篇<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTIzNDMwNA==&amp;mid=2653411105&amp;idx=1&amp;sn=ef32e659052a1697cc0939dcd31a680d&amp;chksm=8d2275ceba55fcd8b582b89ab980db2033ce1d4455e03da6fcafe32bdc78cecefa4e940b1671&amp;scene=132#wechat_redirect">《就是这里。三年半后的钻石坑》</a>，原本还焦虑不已的小伙伴们的投资热情，一下被点燃了。</p><p>五一期间，时间比较多，就将 E 大之前写的两篇“钻石坑”的文章翻开看了看，分别是：</p><ul><li>2018 年 10 月 14 日的 <a href="https://mp.weixin.qq.com/s?__biz=MzIwMTIzNDMwNA==&amp;mid=2653408972&amp;idx=1&amp;sn=b356550473e554fe1f839ce3d5ce408d&amp;chksm=8d226c23ba55e535395d9ad869656c95a0764d559310e2031f92e75e0aa60f76c4f38b19d5ab&amp;scene=21#wechat_redirect">《钻石底》</a></li><li>2019 年 2 月 16 日的<a href="https://mp.weixin.qq.com/s/V1fQenkCMEgSnHrAj-noyA">《钻石边缘》</a></li></ul><p>忽然发现，<strong>原来我早已经历过钻石坑。</strong></p><p>我在有知有行上记录的最早的一笔转入发生在 2019年 1 月 13 日，正好处在 18 年那次钻石坑中间。</p><p>我记得很清楚，这一笔买的是长赢计划，每份金额 100，首次买入了 99 份，一共 9900。</p><p>兜兜转转，三年半后，A 股再一次来到了钻石坑边缘。</p><p>这三年，从最开始的无脑跟投长赢，定投指数基金，到后来跟投一些大 V 组合，再到后来尝试自己做组合研究。资金加权收益率从最高的 +86%，跌到了 -17.81%，年化收益率只有 -5.5%。</p><p><strong>你看，我完整地经历了一轮钻石坑，又几乎回到了原点。</strong></p><p>如果有人告诉你，若干年后，钻石坑再一次来临时，你的年化收益率会跌成负值，你还会对这次钻石坑充满期待吗？</p><p>所以，能否经历钻石坑并不重要，重要的是能否通过这段经历完善自己的投资体系，为下一次的起飞积蓄足够的能量。</p><p>钻石坑，反思正当其时。</p><h2 id="3、反思"><a href="#3、反思" class="headerlink" title="3、反思"></a>3、反思</h2><p>表面上，这三年兜兜转转，似乎又回到了原点，但是我知道并非如此。</p><p>前两天腆着脸和大王同志申请债券组合的管理权时，大王同志掷地有声地发问：“你这三年投资，年化收益率为负，怎么好意思的？”</p><p>我苦思冥想，找到了这张图：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/04/16515802390600.jpg" alt=""></p><p>“近 3 年，收益率大幅跑输偏股型混合基金；近 1 年，收益率和偏股型基金持平；今年以来，收益率略微跑赢偏股型混合基金。由此看来，我的投资水平有了长足提升！”</p><p>大王同志拜服，遂同意了我的请求。</p><p>这三年收获最大的就是从最初的无脑跟投，到现在自己研究组合。虽然也大一直在强调躺赢，但是我觉得不把手弄脏，亲自到市场的大染缸中滚一遍，是无法心平气和、彻彻底底地躺下来的。</p><p>这三年比较遗憾的是，2021 年 2 月之后，整个一年，无论是中证全指还是沪深300，它们的各种估值指标都赤裸裸的说着两个字“高估”！然而我却无动于衷，继续买入各种组合和基金最终结结实实地承受了这 1 年多的回调。</p><p>所以，当 E 大再一次宣布钻石坑的来临时，除了对市场的兴奋，更多的还是希望借这次机会梳理、总结和提升自己的投资体系，</p><p>钻石坑总会有的。</p><h3 id="3-1-市场观察体系"><a href="#3-1-市场观察体系" class="headerlink" title="3.1 市场观察体系"></a>3.1 市场观察体系</h3><p>且慢曾经推送过一篇文章《E大的投资体系是如何不断进化的》，里面提到：</p><blockquote><p>交易策略并不是投资体系的全部。</p><p>除了交易体系，投资体系中还应该包括“观察体系”。你也可以理解为一支军队的侦察部队。包括侦察员，雷达，无人机，预警机等等。观察体系的作用，是让你知道目前战场的整体情况，知道敌人和自己都处在什么样的情况下。</p></blockquote><p>接下来就梳理一下我的观察体系。</p><h4 id="1-全市场观察指标"><a href="#1-全市场观察指标" class="headerlink" title="1) 全市场观察指标"></a>1) 全市场观察指标</h4><p>全市场观察的方式有很多，这段时间总结下来，我觉得有用的有以下几个：</p><p><strong>中证全指 PB 估值百分位</strong></p><p>当前中证全指 PB=1.56，对应分位点 7.94%，可以说是十分低估了。</p><p>为什么用 PB 而不是 PE？这个 E 大提过很多次，PB 的估值比 PE 估值更有效，因为 E 很容易变形。《投资要义》中推荐的也是 PB。</p><p><strong>股债收益比</strong></p><p>股债收益比 = 中证全指盈利收益率 / 10 年期国债收益率。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/04/16515897729662.jpg" alt=""></p><p>当股债收益比较大时，意味着股市的吸引力远高于债券，反之则债券的吸引力更高。</p><p>上图中，很明显能发现 2015 年中、2018 年底、2020 年初股债收益比最高的节点也正是极具投资价值的时间点。</p><p><strong>各指数 PE 趋势图</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/04/ge-zhi-shupe-qu-shi-tu.png" alt="各指数PE趋势图"></p><p>E 大经常会放出几张重要的估值图，其中一张就是上面这个（我用的理杏仁的数据）。</p><p>这张图揭示了一个现象：虽然平时各指数估值各异，但是在进入低估区域的过程中，绝大部分指数 PE 都呈现一种加速向下的态势。</p><p>需要说明的是，以上三个指标可以判断出全市场是否高估，是否低估，但是并不能精确的判断最高点和最低点。尤其是细分到具体的投资品种上，比如 18 年的医疗和现在消费，初期就一直居高不下。</p><h4 id="2-主动基金观察指标"><a href="#2-主动基金观察指标" class="headerlink" title="2) 主动基金观察指标"></a>2) 主动基金观察指标</h4><p>说到主动基金，一般认为有基金经理代我们操作，我们只需要有钱就往里扔就行。</p><p>我认为即使是主动基金，也有必要建立一个观察体系，控制投资节奏，原因是主动基金受限于各种约束（如最低仓位等），基金经理经常会出现不得不买或者不得不卖的情况。</p><p>因此投资主动基金时，也需要一个观察指标来判断大致的买入和卖出区域。</p><p>我的思路是观察各基金的比较基准。一般的股票型基金或者混合型基金，比较基准都是沪深 300，因此可以通过沪深 300 的估值来大致判断主动基金估值。</p><p>由于叠加了基金经理的主动操作，因此对高低估区域的判断可放宽，大致低估甚至正常估值就可以买入；较为高估时再考虑卖出。</p><h4 id="3-指数观察指标"><a href="#3-指数观察指标" class="headerlink" title="3) 指数观察指标"></a>3) 指数观察指标</h4><p>指数观察指标比前两个要复杂许多，一是观察的指数标的越来越多（10+），二是不同指数特性差别较大，很难纳入到统一的指标框架中。</p><p>不过根据 E 大平时的文章以及微博，以及自己的一些梳理，总结出以下几个方法：</p><p><strong>PE/PB 估值法</strong></p><p>这个方式大家都比较熟悉了，现在主流的几家平台如蛋卷、天天基金、且慢、支付宝等都提供类似的指标。</p><p>有知有行也有，图方便，我最近都用这个。</p><p>另外也不能忽视绝对值，在一些宽基品种上，用 PB 的绝对值来判断底部也是一个很有效的方法。</p><p><strong>70/80 法则</strong></p><p>这个是 E 大反复会提到的一个方法。E 大认为任何不死品种跌 70%～80% 就是绝对底部，可以大举买入。如果跌破 80，则不应该再投入，防止在一个品种上投入太多。</p><p>结合最近几个月的行情，发现指数跌破 70 的概率远比自己想象的要高（中概、传媒等），所以这个规则可以很好地抑制我们买入的冲动。</p><p><strong>支撑位</strong></p><p>E 大的文章中经常会提到支撑位这个概念。比如最近的文章中就提到了几个指数的支撑位：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/05/04/zhi-cheng-wei.jpg" alt="支撑位"></p><p>当指数来到对应的支撑位时，也就意味着 E 大发车了。</p><p>了解了一下，支撑位一般有几种情况：</p><ul><li>均线支撑位</li><li>高低点支撑位</li><li>跳空缺口支撑位</li></ul><p>均线和跳空缺口偏技术，这里暂时不讨论。</p><p>上图中支撑位就是低点支撑位。E 大没有提过低点支撑位的计算方式，也大对此做了一些猜想，认为 E 大在支撑位的计算上分为两个部分：科学和艺术。科学的部分是用 PB 计算出大致的范围，艺术的部分是用一些技术分析手段确定具体的点位区间。</p><p>我自己在分析的过程中，会使用一些其它方法：</p><ol><li>画趋势线（连接底部低点，做延长线）</li><li>选择最近的低点，假定年增长率。</li></ol><p>部分指数算出来大致是符合的，但是像中证 500，怎么都对不上，不知道大家有没有什么方法？</p><p>需要注意的是，支撑位虽然是一个具体的值，但并不意味着这是一个精准的边界。E 大在之前的文章也提过：</p><blockquote><p>所谓的“价值区域”，是一个边界模糊的区域，只是我自己会设定一个标准，不然真的就无法界定了。</p></blockquote><h3 id="3-2-策略体系"><a href="#3-2-策略体系" class="headerlink" title="3.2 策略体系"></a>3.2 策略体系</h3><p>我的资产配置分为三个部分：</p><ol><li>跟投组合（长赢、云长进取等）</li><li>主动基金组合</li><li>指数基金组合</li></ol><p>当前的策略，跟投组合设置好一份的金额后，无脑跟车；主动基金组合设置好一份金额后，按月定投，视情况加投；指数基金组合模仿长赢S定投。</p><h4 id="1）跟投组合"><a href="#1）跟投组合" class="headerlink" title="1）跟投组合"></a>1）跟投组合</h4><p>跟投组合部分，暂时没有可优化的部分，后续会降低跟投组合的个数，以长赢为主。</p><h4 id="2）主动基金组合"><a href="#2）主动基金组合" class="headerlink" title="2）主动基金组合"></a>2）主动基金组合</h4><p>主动基金组合部分，之前抄的也大的作业。后续优化的方向有两个：</p><ol><li>调整基金品种。目前正在写一个主动基金系列的研究，待研究完成后，挑选符合自己需求的几只基金放进去。</li><li>增加一些主动买卖的操作，保住利润。思路上面提过，根据基准指数的估值判断大致的买入卖出区间。</li></ol><h4 id="3）指数基金组合"><a href="#3）指数基金组合" class="headerlink" title="3）指数基金组合"></a>3）指数基金组合</h4><p>指数基金组合，是问题最多的一个。这段时间的操作暴露出的问题有：1）每一份金额设置的太低 2）买入点不明确 3）买入频率太高 4）每个品种没有明确的上限。</p><p>问题1），金额太低导致操作变形严重。E 大在<a href="https://mp.weixin.qq.com/s/nUMNI_UokdVEaCpXb_t-Xg">《详解ETF计划》</a> 中建议一份的额度设置为每月能拿出的钱的一半。当时我还不屑一顾，现在看来是我太嫩了。</p><p>问题2），最初的策略是选定定投日，参考估值百分位（有知有行温度计），买入估值低于低于 30 的品种，加倍买入低于 20 甚至 10 的品种。</p><p>以前对这种方式做过回测，相比于普通定投，效果还是不错的。但是执行起来却会遇到一个问题，当指数极度低估时，无法买入更多的份额。当压制不住买入的冲动时，我认为这种方式就不再适合我了。</p><p>后面优化的思路是不再拘泥于每月在固定的日子把子弹打光，而是采用 S 定投的方式，不断积累本金，当指数极度低估时，才批量买入。</p><p>问题3）由问题1）导致。因为一份金额太低，机会来临时，哪怕买入了一份，总感觉没买够，第二天又仍不住买入，进而出现上次实证中中概买入 35 份这种荒唐的局面。</p><p>问题4）是因为我还没有养成用资产配置的思维来看待每个品种。起初的时候，资金存量有限，每月定投的金额对存量的影响很大。现在随着实证账户资金总量的不断提升，再加上大王同志的支持，已经到了需要考虑各个品种上限的时候了。</p><p>后续的思路是以实证账户资金+大王同志支持的资金+未来半年的增量资金为基准，严格限制每个品种的上限，避免极端风险。</p><h2 id="4、最后"><a href="#4、最后" class="headerlink" title="4、最后"></a>4、最后</h2><p>趁着这个五一，重新盘点了可用的资金，梳理了投资体系。虽然还有许多不完善的地方，但相比于之前，总归是进步了一些。</p><p>另外，从 5 月开始，生活和工作上的一些变动逐渐确定了，接下来公众号将重回正轨，文章写起来。</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><em>说明：本文仅为个人投资记录及思考，不构成任何具体的投资建议！</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#18——3月记录与反思</title>
    <link href="/2022/04/07/invest-pratice-18/"/>
    <url>/2022/04/07/invest-pratice-18/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a></p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更“美好”的事物上。</p><p><strong>道阻且长，行则将至，行而不辍，未来可期！</strong></p><h2 id="1、本月进展"><a href="#1、本月进展" class="headerlink" title="1、本月进展"></a>1、本月进展</h2><p>本月进展如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/04/07/png-tu-xianga63e851e95aa1.png" alt="PNG图像-A63E851E95AA-1"></p><p>当前进展 3.65%，相比上个月增加了 0.21%。</p><p>自写实证以来，累计收益第一次变成负值。遥想上一次投资账户收益接近负值还是 2020 年 3 月疫情刚爆发的时候，但是之后很快反弹，下半年一路破新高。不知道这次能不能“重蹈覆辙”？</p><p><strong>本月操作</strong></p><div class="table-container"><table><thead><tr><th>组合</th><th>操作</th><th>金额</th></tr></thead><tbody><tr><td>跟投组合</td><td>长赢跟投</td><td>5500</td></tr><tr><td>跟投组合</td><td>云长进取跟投</td><td>1000</td></tr><tr><td>跟投组合</td><td>日积月累卖出*</td><td>-10000</td></tr><tr><td>它山之石</td><td>定投1份+加投</td><td>6000</td></tr><tr><td>积水成渊</td><td>35份中概，15份恒生以及传媒、养老、医药等若干</td><td>31000</td></tr></tbody></table></div><p><em>注：每月定投金额在三个组合上的分配比例为1：1：1，每份 2000，其中积水成渊又被分成4份，一份 500。未投出部分在进入现金账户沉淀。</em></p><h2 id="2、3月份心路历程"><a href="#2、3月份心路历程" class="headerlink" title="2、3月份心路历程"></a>2、3月份心路历程</h2><p>3.17，孟岩推了一篇文章《恐惧》，结尾是：</p><blockquote><p>恐惧是真实的，也是宝贵的。记住那些恐惧的时刻，让恐惧穿过自己。</p></blockquote><p>翻看 3 月份的记录，写的最多的一句话是“<strong>今天是个值得纪念的日子</strong>”，可见当时的自己，远没有现在看上去那么淡定。</p><p><em>3.7，对“指数不死”产生了怀疑。</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/04/07/16491545806784.jpg" alt=""><br>编制规则的调整，确实让中国互联网指数的安全性提升了一些，但这毕竟是非预期的外力干预，和指数本身根据编制规则优胜劣汰实现永生是不一样的。</p><p><em>3.8，加仓中概，重新思考行业指数和主题类指数的买入和卖出时机。</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/04/07/16491548071384.jpg" alt=""><br><em>3.12 日，中概又大跌，没控制住，冲动加仓。</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/04/07/16491546215035.jpg" alt=""></p><p><em>3.12，发现中证传媒竟然也到了80的极限跌幅，感慨机会遍地都是。</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/04/07/16491545289719.jpg" alt=""><br>当然，有不少人说传媒是垃圾指数，我也不确定，只是觉得 80 的极限跌幅下，还是值得买点观察一下。</p><p>另外，如果注意观察的话，会发现信息、医药都在逐渐接近低估，可以纳入观察了。</p><p><em>3.16，中概涨幅 +39.72%。又一次见证历史。</em></p><p>除了中概，恒生指数涨幅 +9.08%，恒生科技涨幅 +22.2%。如此的指数单日涨幅，我还是太年轻了。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/04/07/16491546859786.jpg" alt=""></p><p>现在回过头来看，跌宕起伏的 3 月份已经过去，周围的朋友们也恢复了原有的平静生活，仿佛一切都没有发生过。</p><p><strong>记住那些恐惧的时刻，让恐惧穿过自己。</strong></p><h2 id="3、收获和反思"><a href="#3、收获和反思" class="headerlink" title="3、收获和反思"></a>3、收获和反思</h2><p>每一次剧烈的波动都是观察市场和观察自己的绝佳时机。除了记住那些恐惧的时刻，更重要的还是反思和总结，提升自己，以期更加从容的面对下一次危机。</p><h3 id="3-1-价值投资和低估值策略"><a href="#3-1-价值投资和低估值策略" class="headerlink" title="3.1 价值投资和低估值策略"></a>3.1 价值投资和低估值策略</h3><p>最初买指数的时候，我十分排斥行业（主题）指数，并多次劝同事不要买行业指数。因为我认为对一个没有相关行业背景的普通投资者而言，很难深入了解一个行业并判断其未来的发展趋势。而且行业指数的波动较大，对普通投资者定力要求很高。</p><p>现在发现，这种想法有问题，至少它不适用于采用低估策略的指数组合。</p><p>价值投资需要深入研究行业基本面和趋势，但低估策略的本质是通过估值的切换实现一个确定性比较高的低买高卖，并不需要过度关注标的质量。哪怕一个指数成长性不高，常年波动（比如上证、传媒），仍然可以通过低估策略获取不菲的收益。</p><p>因此只要指数池子够大，机会遍地都是，而且确定性更高。所以接下来我会大幅增加纳入观察的指数标的数量，更加坚定的践行“低估、分散不深研”的思路。</p><p>看了眼 3.15 号买入的传媒，涨幅 +13%，量不多，但甚是满意。</p><h3 id="3-2-现金和加仓"><a href="#3-2-现金和加仓" class="headerlink" title="3.2 现金和加仓"></a>3.2 现金和加仓</h3><p>虽然 3 月份较为精准的加仓了几笔，但是加仓过程也暴露了不少问题。</p><p>中概原计划是在 70 和 80 的极限跌幅上分别加仓一笔。理想的状态是这两笔数额一样，且加完之后，仓位能拉到 25%。但实际上 70-80 之间我就没忍住，加了一次，等真正接近 80 的时候，却没有敢下手。</p><p>前面冲动，后面胆小，对自己有点失望。希望下次能做的更好些。</p><p>另外还发现了一个问题，我的现金部分和备用金耦合在一起，导致真正计算可投入资金的时候，一直在纠结具体的数字，等好不容易纠结完，发现过了 3 点了。。。</p><p>那么，问题来了，<strong>备用金到底能不能拿来投资？</strong> 如果能，万一急用钱，怎么办？如果不能，遇到历史性的机会，自己真的能无动于衷吗？</p><p>想了半天，没想到什么好办法，就采用了一个最笨的思路：把备用金提高一些，同时规定任何时刻最多只能有 50% 用于投资。</p><p>各打 50 大板，问题解决。</p><h2 id="4、最后"><a href="#4、最后" class="headerlink" title="4、最后"></a>4、最后</h2><p>给自己打个广告。</p><p>由于深知闭门造车的弊端，我建了个微信群，用于交流投资理财心得，欢迎感兴趣的同学入群交流（公众号回复【联系方式】）。</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><em>说明：本文仅为个人投资记录及思考，不构成任何具体的投资建议！</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#17——为了什么？</title>
    <link href="/2022/03/07/invest-pratice-17/"/>
    <url>/2022/03/07/invest-pratice-17/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a></p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气地把生命浪费在更“美好”的事物上。</p><p><strong>道阻且长，行则将至，行而不辍，未来可期！</strong></p><h2 id="1、本月进展"><a href="#1、本月进展" class="headerlink" title="1、本月进展"></a>1、本月进展</h2><p>本月进展如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/03/07/png-tu-xiang5a6e2e11ca991.png" alt="PNG图像-5A6E2E11CA99-1"></p><p>当前进展 3.65%，相比上个月增加了 0.21%。</p><p><strong>本月操作</strong></p><div class="table-container"><table><thead><tr><th>组合</th><th>操作</th><th>金额</th></tr></thead><tbody><tr><td>跟投组合</td><td>长赢跟投</td><td>1000</td></tr><tr><td>它山之石</td><td>定投1份+加投</td><td>5000</td></tr><tr><td>积水成渊</td><td>2份红利，2份500，3份中概，2份养老，1份恒生</td><td>5000</td></tr></tbody></table></div><p>虽然看上去积水成渊买了很多份，挺唬人，但是每份才 500，总额其实并没有多少。。</p><h2 id="2、中概还能买吗"><a href="#2、中概还能买吗" class="headerlink" title="2、中概还能买吗"></a>2、中概还能买吗</h2><p>最近比较忙，没怎么关注市场行情。但是通过和群里小伙伴的聊天，明显能感觉到最近的下跌已经有点让人坐不住了。</p><p>于是整理了重点关注的几个指数的数据：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/03/07/jie-ping20220306-021036.png" alt="截屏2022-03-06 02.10.36"></p><p>很多人都有一个明显的感觉，就是从去年到现在，基金账户一直在下跌。为什么会有这种感觉？看这张表我们能发现一个有意思的现象：</p><p><strong>多只指数在 2021 年2 月 和 9 月附近都创了近几年新高！</strong></p><p>新高之后买入的，等于是完完整整承受了这一波回调。相比于对跌跌不休的懊悔，更值得探讨的一个问题是：<strong>当时新高的时候为什么没有意识到？</strong></p><p>具体到单个指数上，中国互联从去年 2 月 17 日创新高以来，截至目前，累计下跌 65.36%（加上周五晚上的跌幅，接近 70%），怎一个惨字了得。</p><p>E大曾经说过一个<strong>7080法则</strong>，即对一个不死的指数品种而言，如果跌幅达 70%～80%，意味着钻石底到了。</p><p>中国互联的钻石底部到了吗？要回答这个问题，得先回答另一个核心问题：<strong>中国互联是不死的吗？</strong> </p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/03/07/jie-ping20220306-200335.png" alt="截屏2022-03-06 20.03.35"></p><p>这是中国互联网指数的前十大权重股，很难想象什么样的情况下这些公司的股价会清零。</p><p>互联网暴跌的原因很多，国内政策压制，互联网红利见顶，中美关系，俄乌战争等等，但是说到底，还是因为定价权不在国内。比如最近受战争影响、在伦敦上市的俄罗斯联邦储蓄银行，股价单日跌幅达 <strong>95%</strong>。又一次见证历史。</p><p>中国互联会不会这样？不太可能。但有没有这个风险？有。这也是为什么中国互联最新一期的指数编制方案加上了这一条：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/03/07/16465711768518.jpg" alt=""></p><p>所以在中概互联不调整编制规则的情况下，接下来都优先买中国互联，或者考虑恒生科技。</p><p>目前中国互联已经跌了70%，已经是一个比较理想的加仓点位，但是考虑到距离 80% 的跌幅极限仍然还有 <strong>33%</strong> 的下跌空间，再加上可能存在的国际形势的变化，加仓的时候还是要注意控制好幅度和节奏。</p><p>除了中国互联外，其它几个指数，500、红利、养老仍然低估，全指信息和医药调整到合理水平，300和消费由于之前的极度高估，即使回调，目前仍然高估。至于恒生，已经处于低估水平，但是考虑到港股的特殊性以及当前的国际环境，继续下跌的可能性仍然较高。</p><h2 id="3、为了什么"><a href="#3、为了什么" class="headerlink" title="3、为了什么"></a>3、为了什么</h2><p>前段时间听也大在知行小酒馆的一期播客：财务自由不会改变一个人，只会让他更像他自己，感触很深。</p><p>再加上因为工作上的一些事情，开始重新思考这个问题：<strong>追求财务自由，到底是为了什么？</strong></p><blockquote><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更“美好”的事物上。</p></blockquote><p>这是每次实证文章都会例行复制的一句话，从最开始写下之后，就很少再重新思考这句话。现在重新审视，总觉得有一些地方不太对劲。</p><p>仿佛，只有财务自由了，才能拥有自由选择生活方式的权利，才能追求一些更加“美好”的事物。</p><p>问题在于，我到底向往的是哪种生活方式？想追求的是哪些具体的“美好”的事物？而且这些，真的需要等到财务自由之后吗？</p><p>说到底还是没有想清楚。</p><p>如果不想清楚这些，慢慢的，追求的目标可能就变成了财务自由本身。付出十年、二十年，仅仅追求的是一个经济基础，如何能接受？</p><p>也大在播客中提到的一个例子：​也太因为疫情，果断居家办公，由此成为全公司唯一一个居家办公的人。</p><p>这当然可以归结为也大积累了足够的本金，因此在工作选择上也更加能遵从自己的意愿。但是严格来说，他的目标其实并未完全达成。</p><p>由此推导，即使财务自由的目标尚未达成，但是在一些事情的选择上，我们仍然具备一定的“自由选择”的能力，，能够让当下的生活方式更接近理想的目标。</p><p>所以回到最初的问题，即我们当下的学习、工作，甚至是对财务自由的追求，到底是为了什么？</p><p>我还在想这个问题，希望能想清楚。</p><h2 id="4、回顾与计划"><a href="#4、回顾与计划" class="headerlink" title="4、回顾与计划"></a>4、回顾与计划</h2><p>在 <a href="https://mp.weixin.qq.com/s/XWfjJ9WJ8DpxoVpaW1tacg">财务自由实证#7——实证升级了</a> 中，我对该实证计划进行了升级：日后该实证计划将会逐渐变成个<strong>人成长实证</strong>，除了例行的<strong>实证进展</strong>模块外，还会有<strong>本月回顾</strong>模块以及<strong>下月计划</strong>模块。</p><h3 id="本月回顾"><a href="#本月回顾" class="headerlink" title="本月回顾"></a>本月回顾</h3><p><strong>写作</strong></p><ol><li>投资理财方向，有 1 篇，完成度 <strong>25%</strong>。</li><li>专业技术方向，有 0 篇，完成度 <strong>0%</strong>。</li></ol><p><strong>阅读</strong></p><p>无</p><p><strong>个人项目</strong></p><p>无</p><p>2月份比较忙，工作上各种写材料，写的精疲力尽，最近又在着手做一些比较大的调整，没什么时间写文章和阅读，连群都很少水了，哎。</p><p>预计未来2个月内会调整完成，希望能顺利达成预期目标，进入一个全新的状态。</p><h3 id="下月计划"><a href="#下月计划" class="headerlink" title="下月计划"></a>下月计划</h3><p>暂时不设置目标，希望一切顺利～</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>给自己打个广告。</p><p>由于深知闭门造车的弊端，我建了个微信群，用于交流投资理财心得，欢迎感兴趣的同学入群交流（公众号回复【联系方式】）。</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><em>说明：本文仅为个人投资记录及思考，不构成任何具体的投资建议！</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#16——假期回顾</title>
    <link href="/2022/02/07/invest-pratice-16/"/>
    <url>/2022/02/07/invest-pratice-16/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a></p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更“美好”的事物上。</p><p><strong>道阻且长，行则将至，行而不辍，未来可期！</strong></p><h2 id="春节假期"><a href="#春节假期" class="headerlink" title="春节假期"></a>春节假期</h2><p>今天是春节假期的最后一天，不知道大家假期期间玩的怎么样？</p><p>年前因为北京、天津疫情，我已经做好不回老家的打算，没想到最后几天管控松了一些，就赶在 30 号，踏上了回家的路。晚上在服务区刷新闻，看到天津下雪，高速封路，不由得感慨运气爆棚（当时已经出了天津）。</p><p>因为今年回家比较晚，到家没两天，就进入了春节走亲戚的模式。我们这的习俗是春节期间亲戚们相互请吃饭。我们家是初二去亲戚 A 家，初三去亲戚 B 家，初四去亲戚 C 家，晚上自己家，还有初五、初六、初七，没有一天是完全空闲的。</p><p>我们家亲戚还算是比较少的，如果一家人亲戚比较多，常常会出现同一时间需要去好几家吃饭的情况。</p><p>假期天天就这么吃吃喝喝，挺累的。</p><p>小时候虽然也这样串亲戚，但那个时候，每一家都是在自己家忙饭菜，大家聚在一起，大人们打麻将、聊天，小孩们看电视、玩扑克、打闹、嗑瓜子吃零食，年味十分浓厚。现在大家图省事，都是直接去饭店，吃完饭就走，晚上赶下一家，效率高是高了，只是这年味，越来越淡了。</p><h2 id="本月进展"><a href="#本月进展" class="headerlink" title="本月进展"></a>本月进展</h2><p>本月进展如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/02/07/img3521.PNG" alt="IMG_3521"></p><p>当前进展 3.44%，相比上个月增加了 0.06%。</p><p>由于最后两周的大跌，累计收益大幅下降，之所以还能维持账户资产不减少，还有小幅增长，仅仅是因为没忍住加仓了一小笔。。</p><p><strong>本月操作</strong></p><div class="table-container"><table><thead><tr><th>组合</th><th>操作</th></tr></thead><tbody><tr><td>跟投组合</td><td>长赢跟投</td></tr><tr><td>它山之石</td><td>定投1份+加投2份</td></tr><tr><td>积水成渊</td><td>2份中证红利，2份中证500，4份中概互联，2份广发养老</td></tr></tbody></table></div><p>由于 1 月份的大跌，它山之石组合加投 2 份，积水成渊组合也买入多份红利、500、中概和广发养老。</p><p><em>注：每月定投金额在三个组合上的分配比例为1：1：1，其中积水成渊又被分成4份。未投出部分在进入现金账户沉淀。</em></p><h2 id="要抄底吗？"><a href="#要抄底吗？" class="headerlink" title="要抄底吗？"></a>要抄底吗？</h2><p>大跌的时候，一般会出现两种声音：</p><ul><li>要割肉吗？</li><li>要抄底吗？</li></ul><p>小群里面，这两种声音都出现了。仔细思考，发现其实<strong>这两种声音代表着两种截然相反的观点</strong>。</p><p>“割肉”意味着当前处于高位，未来市场可能继续下跌；“抄底”意味着当前处于低位，未来市场可能反弹。</p><p>无论是哪种声音，都包含了对<strong>当下形势的判断+对未来的预期</strong>。按理来说，无论是哪种声音，对未来的预期可能不一样，但是对当下形势的判断应该是一样的。</p><p>但是现在大家对当下形势的判断都出现了分歧，说明“<strong>恐惧已经让我们乱了分寸</strong>”。</p><p>韭圈儿上的恐贪指数已经变成极度恐惧了：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/02/07/kjtl.PNG" alt="kjtl"></p><p>无论是买也好，卖也好，所有的操作都应该来自于预先的设定，而不应该是情绪的驱使。</p><p>不过话说回来，知道是一回事，做又是另一回事了。拿我自己举例，1 月 27 那天收盘后，马上就火急火燎的找媳妇申请资金，喊着要冲进去抄底。</p><p>晚上回去后，冷静了许多，开始逐个分析【它山之石】组合中的基金，比如富国天惠：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/02/07/16441627528313.jpg" alt=""></p><p>20 年初的疫情，21 年初的下跌，最大回撤都是 16%，而最近这一波才7%。</p><p>再看下富国天惠 20 年初到现在的净值表现：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/02/07/16441628303197.jpg" alt=""></p><p>也就是说，现在的价格刚刚跌回 21 年年初下跌之后的水平。这么一看也没什么大不了。</p><p>差不多捋了一遍后，彻底冷静了下来。所以第二天只是略微加了一些，让实证账户总额看上去没有下降😂。</p><p>附上公众号【<strong>老钱说钱</strong>】的一张图：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/02/07/16441569684758.jpg" alt=""></p><p>提前预祝各位明天满血复活！</p><h2 id="本月回顾"><a href="#本月回顾" class="headerlink" title="本月回顾"></a>本月回顾</h2><p>在 <a href="https://mp.weixin.qq.com/s/XWfjJ9WJ8DpxoVpaW1tacg">财务自由实证#7——实证升级了</a> 中，我对该实证计划进行了升级：日后该实证计划将会逐渐变成个<strong>人成长实证</strong>，除了例行的<strong>实证进展</strong>模块外，还会有<strong>本月回顾</strong>模块以及<strong>下月计划</strong>模块。</p><p>12月份的回顾忘了写了，这次一并算上：</p><p><strong>写作</strong></p><ol><li>投资理财方向，有 7 篇，完成度 <strong>87.5%</strong>。</li><li>专业技术方向，有 1 篇，完成度 <strong>50%</strong>。</li></ol><p><strong>阅读</strong></p><p>看完了《卡片笔记写作法》，有一些收获，卡片笔记法还在实践中，等有一些心得后再重新看一遍。</p><p><strong>个人项目</strong></p><p>无</p><h2 id="下月计划"><a href="#下月计划" class="headerlink" title="下月计划"></a>下月计划</h2><p><strong>写作</strong></p><ol><li>投资理财方向，争取每周输出一篇。</li><li>坚持 flomo 每日记录。</li></ol><p><strong>阅读</strong></p><ol><li>阅读《逃不开的经济周期Ⅰ》章节1-6。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>给自己打个广告。</p><p>由于深知闭门造车的弊端，我建了个微信群，用于交流投资理财心得，欢迎感兴趣的同学入群交流（公众号回复【联系方式】）。</p><p><em>说明：本文仅为个人投资记录及思考，不构成任何具体的投资建议！</em></p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基金公司分析（三）——兴证全球</title>
    <link href="/2022/01/23/fund-company-analysis-3/"/>
    <url>/2022/01/23/fund-company-analysis-3/</url>
    
    <content type="html"><![CDATA[<p>在之前的文章 👉 <a href="https://mp.weixin.qq.com/s?__biz=Mzg5NjU0MzU1Mg==&amp;mid=2247484354&amp;idx=1&amp;sn=08665af13118aef6c5971bfed58605cf&amp;chksm=c07e3dedf709b4fb7b77ab64ffa4fa5ff775db9090afc9347cf0c215d00c957a276bf108c384#rd">筛选了一份基金公司名单！</a> 中，为了降低分析成本，利用一些简单的指标，我筛选出了以下几个基金公司（名单不分先后）：</p><div class="table-container"><table><thead><tr><th>基金公司</th><th>状态</th><th>是否长期关注</th></tr></thead><tbody><tr><td>中银基金管理有限公司</td><td><em>已完成</em></td><td>否</td></tr><tr><td>交银施罗德基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>兴证全球基金管理有限公司</td><td><em>已完成</em></td><td>是</td></tr><tr><td>嘉实基金管理有限公司</td><td>待分析</td><td></td></tr><tr><td>富国基金管理有限公司</td><td>待分析</td><td></td></tr><tr><td>工银瑞信基金管理有限公司</td><td>待分析</td><td></td></tr><tr><td>易方达基金管理有限公司</td><td>待分析</td><td></td></tr><tr><td>银华基金管理股份有限公司</td><td>待分析</td></tr></tbody></table></div><p>按照计划，这一篇来分析一下兴证全球基金。</p><p>其实在之前的文章 <a href="http://mp.weixin.qq.com/s?__biz=Mzg5NjU0MzU1Mg==&amp;mid=2247484278&amp;idx=1&amp;sn=eda1ac03a024f9c0f4fe469262c31ff5&amp;chksm=c07e3d59f709b44fd148106ba099621de513fca476df004e9c77fcfc99f70c17f7224824e3cc#rd">《聊一聊基金公司——兴证全球（兴全）》</a> 中已经对兴证全球分析过一回，但是考虑一是有新的读者，二是之前的分析个人倾向比较严重，所以这次重新分析一下。</p><h2 id="1-公司简介"><a href="#1-公司简介" class="headerlink" title="1. 公司简介"></a>1. 公司简介</h2><p>兴证全球基金管理公司由兴业证券（占股51%）和荷兰全球人寿保险国际公司（占股49%）共同出资成立，是一家<strong>中外合资的基金管理公司</strong>。</p><p>下面是兴证全球的公司名称变更历史：</p><div class="table-container"><table><thead><tr><th>时间</th><th>公司名称</th></tr></thead><tbody><tr><td>2003年9月</td><td>兴业基金管理有限公司</td></tr><tr><td>2008年7月</td><td>兴业全球基金管理有限公司</td></tr><tr><td>2016年12月</td><td>兴全基金管理有限公司</td></tr><tr><td>2020年3月</td><td>兴证全球基金管理有限公司</td></tr></tbody></table></div><p><em>注：上面这些名称中的“兴”均表示兴业证券。“全球”指全球人寿保险国际公司。</em></p><p>一般基民更熟悉的名称是“兴业全球”或者“兴全基金”。</p><p>刚接触基金投资的朋友可能会把兴证全球和另一家基金公司“兴业基金”弄混，需要注意！当前的兴业基金管理有限公司，成立于2013年4月，是兴业银行和中海集团共同出资设立。</p><p>大家千万不要搞混了！！</p><h2 id="2-基本数据"><a href="#2-基本数据" class="headerlink" title="2. 基本数据"></a>2. 基本数据</h2><p>下面是兴证全球的基本数据：</p><div class="table-container"><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">数值</th><th style="text-align:left">排名</th></tr></thead><tbody><tr><td style="text-align:left">非货币型基金规模</td><td style="text-align:left">3103.79亿</td><td style="text-align:left">16</td></tr><tr><td style="text-align:left">非货币型基金平均规模</td><td style="text-align:left">50.06亿</td><td style="text-align:left"><strong>2</strong></td></tr><tr><td style="text-align:left">近5年股票型基金平均收益</td><td style="text-align:left">87.38%</td><td style="text-align:left">28</td></tr><tr><td style="text-align:left">近5年混合型基金平均收益</td><td style="text-align:left">139.84%</td><td style="text-align:left">8</td></tr><tr><td style="text-align:left">金牛奖获奖数</td><td style="text-align:left">10</td><td style="text-align:left"><strong>1</strong></td></tr><tr><td style="text-align:left">基金经理平均任职年限</td><td style="text-align:left">2年又163天</td><td style="text-align:left">18</td></tr></tbody></table></div><p>基本数据中，表现稍差的是“近5年股票型基金平均收益”，但是结合其规模，这个数据完全可以忽略。</p><p>而它的非货币型基金平均规模以及金牛奖获奖数表现则十分优异，排名第二和第一。</p><p>剩余几项表现也不错。</p><p>接下来再深入一些，看看这些数据，“质量”怎么样。</p><h3 id="2-1-各类型基金规模占比"><a href="#2-1-各类型基金规模占比" class="headerlink" title="2.1 各类型基金规模占比"></a>2.1 各类型基金规模占比</h3><p>兴证全球各类型基金规模占比如下图所示：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/23/16428648941153.jpg" alt=""></p><p>从图中可以看出，兴证全球中占绝对大头的两类基金是混合型基金和货币型基金，其次是债券型基金，至于剩下的基本可以忽略。</p><p>相比前面“重债轻股”的中银基金和权益、债券、货币三足鼎力的交银，兴证全球两大支柱是权益、货币。</p><h3 id="2-2-股票型基金数据"><a href="#2-2-股票型基金数据" class="headerlink" title="2.2 股票型基金数据"></a>2.2 股票型基金数据</h3><p>兴证全球旗下的股票型基金有 5 只，总规模为 93.17 亿。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/23/16428649711610.jpg" alt=""></p><p>下面是这个 5 只基金的详细情况：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/23/16428650087204.jpg" alt=""></p><p>除了兴全全球视野外，其它四只均为指数基金。如果A、C类基金视为同一类，则更少了。</p><p><strong>可见，兴证全球股票型基金的平均收益等数据完全没有参考价值。</strong></p><h3 id="2-3-混合型基金数据"><a href="#2-3-混合型基金数据" class="headerlink" title="2.3 混合型基金数据"></a>2.3 混合型基金数据</h3><p>根据前面的各类型基金规模占比数据，我们知道混合型基金是兴证全球的基本盘：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/23/16428650847030.jpg" alt=""></p><p>这个数据表面看仅仅是不错，如果计算下单只基金平均规模，就能发现兴证全球混合型基金平均基金规模在总规模排名前十的基金公司中遥遥领先。</p><p>前面的基本数据显示兴证全球的非货币型基金平均规模，50.06 亿，在所有基金公司中排名第二！</p><p>平均基金规模越高，表明基金公司走的精品路线，是靠收益吸引投资者做大规模，而不是不停的新发基金，是基金公司“良心”的一种表现。</p><p><strong>离钱最近的地方，“善良”比“聪明“更重要。</strong></p><p>再看兴证全球混合型基金的平均收益，无论是近3年还是近5年，都高于平均水平</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/23/16428651507833.jpg" alt=""></p><p>由此可见，在混合型基金上，兴证全球无论是规模还是质量，都十分优秀。</p><h3 id="2-4-债券型基金数据"><a href="#2-4-债券型基金数据" class="headerlink" title="2.4 债券型基金数据"></a>2.4 债券型基金数据</h3><p>虽然兴证全球债券型基金的占比较低，但是总规模也有600亿：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/23/16428654021718.jpg" alt=""></p><p>它的平均收益水平表现如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/23/16428653665512.jpg" alt=""></p><p>无论是近3年还是近5年，均跑赢同类平均水平，也还不错。</p><h2 id="3-投资理念"><a href="#3-投资理念" class="headerlink" title="3. 投资理念"></a>3. 投资理念</h2><p>根据官网，兴证全球的投资理念摘录如下：</p><blockquote><p>兴全基金坚持“风险控制、长期投资和价值投资”为核心的投资理念，强调研究创造价值，坚持价值投资和长期投资，坚持在长跑中胜出，注重风险控制，强调企业估值，追求风险调整后的超额收益，投资风格稳健。</p></blockquote><p><strong>关于风险控制</strong></p><blockquote><p>公司永远坚持，良好的风险控制是公司盈利的最终保证。</p></blockquote><p><strong>关于长期投资</strong></p><blockquote><p>投资是一项长期的事业，我们坚持在长跑中胜出。</p></blockquote><p><strong>关于价值投资</strong></p><blockquote><p>我们注重投资的过程，强调企业估值的合理性，寻找良好的安全边际，为持有人创造最稳定的安全边际。</p></blockquote><p>几乎每一家基金公司的投资理念都写着“长期投资”、“价值投资”，但是兴证全球是我看到的管理规模较大的基金公司中唯一一家把“风险控制”排在首位的公司。就冲这一点，好感倍增。</p><h2 id="4-投研团队"><a href="#4-投研团队" class="headerlink" title="4. 投研团队"></a>4. 投研团队</h2><p>公募基金行业，一个优秀的投研团队对基金的业绩有着举足轻重的影响。</p><p>在兴证全球管理，列举了当前投研团队的主要成员——以谢治宇为首的 29 名基金经理。其中 9 名均一毕业就加入兴证全球，内部培养率 31%。</p><p>根据网上搜集的资料，兴证全球内部，每一个基金经理都是从研究员做起，大名鼎鼎的谢治宇也是，董承非也是。先做好研究员，再做基金经理助理，再做双基金经理，确定没问题了才会做一个老产品的基金经理。所以在基金经理的继承上，兴全也做到了后继有人。</p><p>除了投研团队本身，兴证全球投研团队的管理和激励机制独具特色。比如为了解决短期和长期收益冲突的问题，公司对基金经理的考核涵盖了1年、2 年、3 年、5 年、8 年、10 年等多个维度，不提倡旗下产品去争年度排名，也不鼓励基金经理在某一年做出很极致的业绩，基金经理年度排名只要达到前1/2就算合格。</p><p>能否培养出自己的明星基金经理，也是公司投研团队实力的重要体现。兴证全球的明星基金经理十分之多，大家耳熟能详的有著名的“兴全五绝”——杨东、王晓明、杜昌勇、付鹏博、董承非，还有从内部成长起来的一人独揽 7 座金牛奖的谢治宇。</p><p>虽然随着董承非的卸任（1 月 21 已经正式确认），兴全五绝彻底成为历史，明星基金经理只剩谢治宇一人。但是如果兴全内部的培养机制真如上面所写的那样，形成了完善的培养机制，似乎也不用太担心。</p><h2 id="5-合规信息"><a href="#5-合规信息" class="headerlink" title="5. 合规信息"></a>5. 合规信息</h2><p>2015 年 2 月，兴全基金及其子公司的两款资管计划在 2014 年 8 月同时买入某上市公司股票，且该上市公司于 10 月停牌，复牌后股价出现异常波动。由于兴全未及时将相关异常交易报告给监管部门，上述两款资管计划被暂停备案一个月至三个月。</p><p>2016 年 2 月，证监会对兴业全球基金总经理杨东出具警示函。因为兴业全球基金的专户投资经理兼专户投资部副总监吕琪通过微信朋友圈发布与投资基金运作有关的不当言论（言论内容：“郑重提示：建议有其他投资渠道的客户赎回，今年本人管理的产品大概率不能赚钱。”），经媒体转载后广泛传播，产生一定负面影响。</p><p>2018 年 8 月 27 日，兴全旗下三期资管计划合计持有金龙机电股份 5.66%，超过 5%，没有按规定履行报告和公告义务，收到创业板公司管理部的监管函。不过根据一些新闻报道，违规原因是部分产品将金龙机电的可转债转成股票导致累计持仓超过 5%，此举可能旨在快速止损。</p><p>上面是网络上能搜到的兴全违规信息。除了第一条外，后两条违规信息都有点保护投资者权益的意味，只能说兴全就是违规，也违规的“与众不同”。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>至此，兴证全球的分析就告一段落。做个总结：</p><p>兴证全球的整体实力在全部基金公司中处于前列，在基金平均规模和金牛奖获奖数这两个指标上遥遥领先。</p><p>在混合型基金上，无论是基金平均规模还是平均收益，都远超平均水平。</p><p>投研团队上，内部团队趋于稳定，形成了比较完善的人才梯队。只是随着明星基金经理董承非的彻底离职，兴证全球接下来的表现还需要时间来证明。</p><p>合规方面，兴证全球历史上存在一些不合规现象，说明公司在风控、异常交易审查、员工言论管控上存在一定的漏洞，整体表现还行。</p><p>就我个人而言，我认为兴证全球是一家十分优秀的基金公司，会长期关注。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]. 兴证全球基金董理：机制决定文化 “长期主义”贯穿公司投研, <a href="http://fund.eastmoney.com/a/202110182143687843.html">http://fund.eastmoney.com/a/202110182143687843.html</a><br>[2]. 董承非正式从兴全离任, <a href="https://www.xqfunds.com/info.do?contentid=125618&amp;searchstring=%B6%AD%B3%D0%B7%C7">https://www.xqfunds.com/info.do?contentid=125618&amp;searchstring=%B6%AD%B3%D0%B7%C7</a><br>[3]. 证监会对兴业全球基金总经理杨东出具警示函, <a href="http://fund.sohu.com/20160226/n438619752.shtml">http://fund.sohu.com/20160226/n438619752.shtml</a><br>[4]. 纪律处分决定书（兴业全球基金管理有限公司、上海兴全睿众资产管理有限公司）, <a href="https://www.amac.org.cn//selfdisciplinemeasures/cyry/hyjg/201502/t20150215_2499.html">https://www.amac.org.cn//selfdisciplinemeasures/cyry/hyjg/201502/t20150215_2499.html</a><br>[5]. 关于对金龙机电股份有限公司股东兴全基金管理有限公司的监管函, <a href="https://pdf.dfcfw.com/pdf/H2_AN201808271183400782_1.pdf">https://pdf.dfcfw.com/pdf/H2_AN201808271183400782_1.pdf</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>给自己打个广告。</p><p>由于深知闭门造车的弊端，我建了个微信群，用于交流投资理财心得，欢迎感兴趣的同学入群交流（公众号回复【联系方式】）。</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><em>说明：本文仅为个人投资记录及思考，不构成任何具体的投资建议！</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基金公司</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基金公司分析（二）——交银施罗德</title>
    <link href="/2022/01/16/fund-company-analysis-2/"/>
    <url>/2022/01/16/fund-company-analysis-2/</url>
    
    <content type="html"><![CDATA[<p>在之前的文章 👉 <a href="https://mp.weixin.qq.com/s?__biz=Mzg5NjU0MzU1Mg==&amp;mid=2247484354&amp;idx=1&amp;sn=08665af13118aef6c5971bfed58605cf&amp;chksm=c07e3dedf709b4fb7b77ab64ffa4fa5ff775db9090afc9347cf0c215d00c957a276bf108c384#rd">筛选了一份基金公司名单！</a> 中，为了降低分析成本，利用一些简单的指标，我筛选出了以下几个基金公司（名单不分先后）：</p><div class="table-container"><table><thead><tr><th>基金公司</th><th>状态</th></tr></thead><tbody><tr><td>中银基金管理有限公司</td><td><em>已完成</em></td></tr><tr><td>交银施罗德基金管理有限公司</td><td><em>已完成</em></td></tr><tr><td>兴证全球基金管理有限公司</td><td>待分析</td></tr><tr><td>嘉实基金管理有限公司</td><td>待分析</td></tr><tr><td>富国基金管理有限公司</td><td>待分析</td></tr><tr><td>工银瑞信基金管理有限公司</td><td>待分析</td></tr><tr><td>易方达基金管理有限公司</td><td>待分析</td></tr><tr><td>银华基金管理股份有限公司</td><td>待分析</td></tr></tbody></table></div><p>和中银基金一样，交银施罗德也是一家“银行系”基金。它会不会也像中银基金一样“重债轻股”呢？</p><p>今天我们就一起来看下交银施罗德管理有限公司，实力到底怎么样。</p><h2 id="1-公司简介"><a href="#1-公司简介" class="headerlink" title="1.公司简介"></a>1.公司简介</h2><p>交银施罗德成立于 2005 年，是中国第一批银行背景的基金公司之一，也是一家<strong>中外合资基金管理公司</strong>，股东分别是交通银行、施罗德投资管理有限公司、中国国际集装箱海运(集团)股份有限公司。</p><h2 id="2-基本数据"><a href="#2-基本数据" class="headerlink" title="2. 基本数据"></a>2. 基本数据</h2><div class="table-container"><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">数值</th><th style="text-align:left">排名</th></tr></thead><tbody><tr><td style="text-align:left">非货币型基金规模</td><td style="text-align:left">3488.95亿</td><td style="text-align:left">13</td></tr><tr><td style="text-align:left">非货币型基金平均规模</td><td style="text-align:left">22.37亿</td><td style="text-align:left">11</td></tr><tr><td style="text-align:left">近5年股票型基金平均收益</td><td style="text-align:left">71.48%</td><td style="text-align:left">55</td></tr><tr><td style="text-align:left">近5年混合型基金平均收益</td><td style="text-align:left">134.94%</td><td style="text-align:left">11</td></tr><tr><td style="text-align:left">金牛奖获奖数</td><td style="text-align:left">5</td><td style="text-align:left">15</td></tr><tr><td style="text-align:left">基金经理平均任职年限</td><td style="text-align:left">2年又154天</td><td style="text-align:left">21</td></tr></tbody></table></div><p>基本数据中，表现较差的是近5年股票型基金平均收益，其它几个指标都表现不错，没有什么短板。</p><p>但是有了上次中银基金的经验，平均收益高并不能完全反应基金公司的水平，还需要结合对应的规模具体分析。</p><h3 id="2-1-各类型基金规模占比"><a href="#2-1-各类型基金规模占比" class="headerlink" title="2.1 各类型基金规模占比"></a>2.1 各类型基金规模占比</h3><p>交银施罗德基金公司各类型基金规模占比如下图：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/16/16422607815488.jpg" alt=""><br>相比上一期的中银基金，交银施罗德的权益类基金、债权类基金、货币类基金呈现三足鼎力的局面，没有明显的短板。</p><h3 id="2-2-股票型基金数据"><a href="#2-2-股票型基金数据" class="headerlink" title="2.2 股票型基金数据"></a>2.2 股票型基金数据</h3><p>交银施罗德的股票型基金规模 80 多亿，一共 13 只基金（其实是 11），3 个基金经理。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/16/16422617667241.jpg" alt=""></p><p>论规模，也就比中银强那么一点。</p><p>而且这 11 只基金中，8 只指数基金，真正的主动型股票基金只有 3 只，规模一共才 40 多亿，也就是个打酱油的水平。</p><p>所以，虽然交银施罗德近5年股票型基金平均收益比较差，才 71.48%，排名 55，但是<strong>考虑其规模，这个数据完全可以忽略，没必要关注</strong>。</p><h3 id="2-3-混合型基金数据"><a href="#2-3-混合型基金数据" class="headerlink" title="2.3 混合型基金数据"></a>2.3 混合型基金数据</h3><p>交银施罗德基金在混合型基金上，实力还是比较强的：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/16/16422626044982.jpg" alt=""></p><p>2205 亿的混合型基金规模，在全部基金公司中排名第 8，也是<strong>排名前 10 的公司中唯一的一家银行系基金公司</strong>，交银施罗德的进取之心由此可见。</p><p>除此之外，交银施罗德的混合型基金平均规模近 25 亿，在<strong>规模前 10 的公司中，更是仅次于兴全的存在</strong>。这是说明公司并没有为了规模乱发新基金，这一点值得表扬！！</p><p>近5年交银施罗德混合型基金平均收益 134.94%，排名 11，也是一个十分不错的数字。</p><p>其实除了近 5 年，近 6 个月，近一年，近 3 年，交银施罗德混合型基金的平均收益都是超过同类平均水平的：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/16/16422629348174.jpg" alt=""></p><p>由此可见，交银施罗德在混合型基金上，无论是量还是质，都是比较优秀的。</p><h3 id="2-4-债券型基金数据"><a href="#2-4-债券型基金数据" class="headerlink" title="2.4 债券型基金数据"></a>2.4 债券型基金数据</h3><p>交银施罗德债券型基金规模 1000 多亿，排名 20，一个还行的水平：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/16/16422643068313.jpg" alt=""></p><p>看近几年的收益表现，一直跑输同类平均水平：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/16/16422643605341.jpg" alt=""></p><p>没有体现出一个“银行系”基金公司的水平。</p><p>不过看了下，债券型基金近5年平均收益前 20 的基金公司名单，属于“银行系”的只有中银和农银，这倒是有点出乎意料。看来银行背景在债券型基金上并没有太多加成。</p><h2 id="3-投资理念"><a href="#3-投资理念" class="headerlink" title="3. 投资理念"></a>3. 投资理念</h2><p>下面是交银施罗德官网上关于投资理念的描述：</p><blockquote><p>我们的投资理念是通过专业化研究分析，积极挖掘非完全有效市场中的投资机会，坚持并不断深化价值投资。</p><p>借鉴外方股东施罗德集团的全球投资研究网络和分析方法，深入分析高速发展的中国经济与资本市场的无限商机，充分发挥专业研究与管理能力，适度配置资产，精选证券，在防御型股票、增长型股票和固定收益证券上作适度的配置。利用全球领先的投资组合风险（PRISM）管理技术，在有效控制下行风险的前提下，最大程度力求实现基金资产的长期稳定增长。</p></blockquote><p>说实话，投资理念这一块，没太看明白。“精选证券，在防御型股票、增长型股票和固定收益证券上作适度的配置”，这压根不是单只基金的投资思路，这是投资组合的思路啊。</p><p>最后一句：<em>利用全球领先的投资组合风险（PRISM）管理技术，在有效控制下行风险的前提下，最大程度力求实现基金资产的长期稳定增长</em>。</p><p>查了下所谓“全球领先的投资组合风险（PRISM）管理技术”，其实是施罗德资管管理公司开发的一套投资组合风控暨投资策略管理系统，用来评估投资组合内资产和当前行业、市场等是否匹配。</p><p>有种交银施罗德直接把把施罗德的投资理念复制过来的感觉🤔</p><h2 id="4-投研团队"><a href="#4-投研团队" class="headerlink" title="4. 投研团队"></a>4. 投研团队</h2><p>投研团队是基金公司硬实力的体现，但是也是比较难调查的一部分。</p><p>根据公司官网投研团队的介绍，交银施罗德汇聚了来自海内外、具有创业精神、年轻有为的投研精英，形成了一支具有国际水准的投资专业理论素养同时又朝气蓬勃的优秀专业投研团队。通过现有权益部、固定收益部、专户投资部、量化投资部、跨境投资部、研究部等多个投研职能部门，针对各大资产类别和投资策略为基金持有人提供专业资产管理服务。</p><p>团队主要成员主要来源于包括施罗德集团在内的海内外著名金融机构，且核心成员均具有10年以上的证券投资管理经理。</p><p>值得一提的是，32 主要位成员中，8 位是一毕业即加入交银，一路至今，完全由交银内部培养而成长起来。</p><p>能否培养出自己的明星基金经理，也是投研团队实力一种体现。业内熟知的“交银三剑客”——王崇、杨浩、何帅，以及中生代的郭斐等，都是从交银内部成长起来的明星基金经理。</p><p>虽然没有更多关于交银投研团队的资料，但是从内部培养率以及明星基金经理方面，也可以看出公司投研团队实力还是比较突出的。</p><h2 id="5-合规信息"><a href="#5-合规信息" class="headerlink" title="5. 合规信息"></a>5. 合规信息</h2><p>不搜不知道，交银施罗德违规的信息有点多。</p><p>原交银施罗德专户投资经理吴永春于 2010 年 5 月 17 日，根据内幕消息进行交易，累计亏损 3,159,609.77，因为没有违法所得，只是被证监会处以 30 万罚款！内幕交易还亏损了，也是不容易。。</p><p>原交银施罗德基金经理（投资总监兼投资决策委员会主席）李旭利于 2009 年 4 月，利用非公开信息进行交易，非法获利 1071.6 万！后李旭利被依法判处有期徒刑 4 年，处罚金 1800 万，追缴违法所得，并被证监会取消基金从业资格！</p><p>原交银施罗德基金经理郑拓 2009 年 3 月至 7 月间，利用非公开信息进行交易，非法获利 1242 万！后郑拓被依法判处有期徒刑 3 年，处罚金 600 万，追缴违法所得，并被证监会取消基金从业资格！</p><p>另外 2018 年，证监会铁腕查处了一起公募基金公司内幕交易“窝案”，交银施罗德就卷入其中。涉事的多家基金公司涉嫌参与广联达的内幕交易（上市公司董秘经过券商研究员传导给基金公司的基金经理，再由基金经理利用该信息实施内幕交易并获利），并收到了证监会的行政处罚事先告知书。不过并没有在证监会官网找到最终的行政处罚书。</p><p>2020 年，有新闻爆出交银施罗德旗下多只基金疑似“蒙面举牌”（同一基金经理旗下多只基金持有单只股票股份合计超过 5% 且未举牌）。</p><p>相比于中银基金，交易施罗德的违规行为要多的多，虽然大部分都是基金经理的个人行为，但是也显示了交银施罗德在风控方面意识薄弱、机制缺失的问题。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>至此，交银施罗德基金的分析就告一段落了。做个总结：</p><p>交银施罗德基金整体实力在全部基金公司中处于前列，且公司没有明显的短板，在权益、债券、固收上都有布局。</p><p>在权益基金混合型基金上，明星经理众多，且无论是规模还是平均收益，都远超平均水平。</p><p>投研团队上，方向覆盖全面，没有明显的短板，且多位团队成员、明星经理都由内部培养，脱颖而出。</p><p>合规方面，公司历史上有多位基金经理出现违规，说明公司在风控、内部审查方面做的一般，需要注意。</p><p>就我个人而言，我认为交银施罗德是一家较为优秀的基金公司，会长期关注。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]. 中国证监会行政处罚决定书(包维春、冯振民、吴春永), <a href="http://www.csrc.gov.cn/csrc/c101928/c1043143/content.shtml">http://www.csrc.gov.cn/csrc/c101928/c1043143/content.shtml</a><br>[2]. 中国证监会行政处罚决定书（李旭利）, <a href="http://www.csrc.gov.cn/csrc/c101928/c1043001/content.shtml">http://www.csrc.gov.cn/csrc/c101928/c1043001/content.shtml</a><br>[3]. 中国证监会行政处罚决定书（郑拓）, <a href="http://www.csrc.gov.cn/csrc/c101928/c1043000/content.shtml">http://www.csrc.gov.cn/csrc/c101928/c1043000/content.shtml</a><br>[4]. 公募基金涉内幕交易窝案被罚 风控漏洞引业界关注, <a href="http://fund.eastmoney.com/a/1590,20180604882370294.html">http://fund.eastmoney.com/a/1590,20180604882370294.html</a><br>[5]. 交银施罗德回应旗下多只基金疑似“蒙面举牌”问题：不存在应披露而未披露的重大信息, <a href="http://fund.jrj.com.cn/2020/04/17092729310701.shtml">http://fund.jrj.com.cn/2020/04/17092729310701.shtml</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>给自己打个广告。</p><p>由于深知闭门造车的弊端，我建了个微信群，用于交流投资理财心得，欢迎感兴趣的同学入群交流（公众号回复【联系方式】）。</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><em>说明：本文仅为个人投资记录及思考，不构成任何具体的投资建议！</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基金公司</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基金公司分析（一）——中银基金管理有限公司</title>
    <link href="/2022/01/11/fund-company-analysis-1/"/>
    <url>/2022/01/11/fund-company-analysis-1/</url>
    
    <content type="html"><![CDATA[<p>在之前的文章 👉 <a href="https://mp.weixin.qq.com/s?__biz=Mzg5NjU0MzU1Mg==&amp;mid=2247484354&amp;idx=1&amp;sn=08665af13118aef6c5971bfed58605cf&amp;chksm=c07e3dedf709b4fb7b77ab64ffa4fa5ff775db9090afc9347cf0c215d00c957a276bf108c384#rd">筛选了一份基金公司名单！</a> 中，为了降低分析成本，利用一些简单的指标，我筛选出了以下几个基金公司（名单不分先后）：</p><div class="table-container"><table><thead><tr><th>基金公司</th><th>状态</th></tr></thead><tbody><tr><td>中银基金管理有限公司</td><td><em>已完成</em></td></tr><tr><td>交银施罗德基金管理有限公司</td><td>待分析</td></tr><tr><td>兴证全球基金管理有限公司</td><td>待分析</td></tr><tr><td>嘉实基金管理有限公司</td><td>待分析</td></tr><tr><td>富国基金管理有限公司</td><td>待分析</td></tr><tr><td>工银瑞信基金管理有限公司</td><td>待分析</td></tr><tr><td>易方达基金管理有限公司</td><td>待分析</td></tr><tr><td>银华基金管理股份有限公司</td><td>待分析</td></tr></tbody></table></div><p>中银基金素来低调，平时谈论中鲜有提及。今天我们就一起来看下中银基金管理有限公司，实力到底怎么样。</p><h2 id="1-公司简介"><a href="#1-公司简介" class="headerlink" title="1.公司简介"></a>1.公司简介</h2><p>中银基金由中国银行和贝莱德投资管理有限公司联合组建，是一家<strong>中外合资基金管理公司</strong>。</p><p>中银基金的前身是中银国际基金，于2004年7月29日正式开业，两大股东是中银国际和美林投资（2006年美林投资和贝莱德合并为贝莱德）。2008年1月16日正式更名为中银基金管理有限公司。</p><h2 id="2-基本数据"><a href="#2-基本数据" class="headerlink" title="2. 基本数据"></a>2. 基本数据</h2><p>先来看一下中银基金的基本数据:</p><div class="table-container"><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">数值</th><th style="text-align:left">排名</th></tr></thead><tbody><tr><td style="text-align:left">非货币型基金规模</td><td style="text-align:left">2827.13亿</td><td style="text-align:left">36</td></tr><tr><td style="text-align:left">非货币型基金平均规模</td><td style="text-align:left">14亿</td><td style="text-align:left">23</td></tr><tr><td style="text-align:left">近5年股票型基金平均收益</td><td style="text-align:left">116.42%</td><td style="text-align:left">12</td></tr><tr><td style="text-align:left">近5年混合型基金平均收益</td><td style="text-align:left">72.38%</td><td style="text-align:left">85</td></tr><tr><td style="text-align:left">金牛奖获奖数</td><td style="text-align:left">5</td><td style="text-align:left">15</td></tr><tr><td style="text-align:left">基金经理平均任职年限</td><td style="text-align:left">2年又295天</td><td style="text-align:left"><strong>4</strong></td></tr></tbody></table></div><p>基本数据中，基金经理平均任职年限比较亮眼，排名第4；近5年混合基金平均收益比较糟糕，排名85。其它数据看着都还行，不是特别好，但也不差。</p><p>接下来我们稍微深入一下，看看这些数据，“质量”到底怎么样。</p><h3 id="2-1-各类型基金规模占比"><a href="#2-1-各类型基金规模占比" class="headerlink" title="2.1 各类型基金规模占比"></a>2.1 各类型基金规模占比</h3><p>下图是中银基金各类型基金规模占比：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/11/16417433954902.jpg" alt=""></p><p>债券型基金和货币型基金在整体规模中占比超过80%，不考虑货币型基金的情况下，债券型基金占比75.9%！</p><p>显然，中银基金是一家<strong>重债券，轻权益</strong>的基金公司。</p><h3 id="2-2-股票型基金数据"><a href="#2-2-股票型基金数据" class="headerlink" title="2.2 股票型基金数据"></a>2.2 股票型基金数据</h3><p>中银基金股票型基金近5年平均收益116.42%，排名 12，表现还是不错的，但是一想到它的股票基金规模，这份数据的说服力似乎就没有那么强了。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/11/16417482852101.jpg" alt=""></p><p>股票型基金整体规模58亿，一共22只基金，平均每只基金2.6亿，远远低于行业8.5亿的平均水平！</p><p>且这22只基金中，2只是新发基金，7只基金规模低于5000万（清盘线），只有2只规模超过10亿，成立时间超过5年更是仅有5只！</p><p>尽管中银股票型基金近5年收益水平优异，但这并不能掩盖中银基金在股票型基金规模小、实力差的事实。</p><h3 id="2-3-混合型基金数据"><a href="#2-3-混合型基金数据" class="headerlink" title="2.3 混合型基金数据"></a>2.3 混合型基金数据</h3><p>前面基础数据中显示，中银混合型基金近5年平均收益72.38%，排名85，过于拉胯，已经没有分析的必要了。</p><h3 id="2-4-债券型基金数据"><a href="#2-4-债券型基金数据" class="headerlink" title="2.4 债券型基金数据"></a>2.4 债券型基金数据</h3><p>债券型基金是中银基金的基本盘，在第16届金牛奖评比中，正是由于其在18年优异的表现，获得了“金牛管理公司”的称号。</p><p>截至目前，中银基金债券型基金管理规模2326.30，排名第四，并且债券基金数在排名前10的公司中也是最低的一个，这说明它的平均规模也是遥遥领先。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/11/16418303470357.jpg" alt=""></p><p>之前讨论过，基金公司通常有两种方式做大规模，一是发行新基金，二是做大单只基金规模。平均规模越大，说明基金公司选择的是第二种方式，这也是投资者最喜欢的一种方式。</p><p>收益上，公司近5年债券型基金平均收益30.53%，跑赢平均水平25.79%。在债券型基金规模前十的公司中，该收益水平仅次于易方达和鹏华基金。</p><p>这说明中银基金的债券型基金，无论是量还是质，表现都很出色。</p><h3 id="2-5-规模增长趋势"><a href="#2-5-规模增长趋势" class="headerlink" title="2.5 规模增长趋势"></a>2.5 规模增长趋势</h3><p>分析各项数据的时候发现，中银基金规模增长趋势很不乐观。</p><p>近些年，随着基金概念的普及，民众对基金的接受度越来越高，基金的规模成显著增长趋势，然而中银基金却在这种增长潮流中并未跟上，甚至原地踏步，即使是中银基金的基本盘债券基金，表现也不容乐观。</p><p>这是市场全部基金和债券型基金的规模增长趋势：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/11/16417510190436.jpg" alt=""></p><p>这是中银基金整体规模和债券型基金规模的增长趋势：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/11/16417511588072.jpg" alt=""></p><p>近5年，市场全部基金规模从9万亿增长到25万亿，增长幅度178%，债券基金规模从2万亿增长到6万亿，增长幅度300%；中银基金整体规模从2500亿增长到近4000亿，增长幅度60%，债券基金规模从1300亿增长到2300亿，增长幅度76.9%。</p><p>两项指标均大幅跑输市场。中银基金掉队比较严重。</p><h2 id="3-投资理念"><a href="#3-投资理念" class="headerlink" title="3. 投资理念"></a>3. 投资理念</h2><p>让人惊讶的是，<strong>中银基金公司官网并没有任何关于投资理念的介绍</strong>。虽然说写在纸面上的投资理念并不代表实际投资的理念，但是像中银基金这样连写都没有的，实在是不多见。</p><h2 id="4-投研团队"><a href="#4-投研团队" class="headerlink" title="4. 投研团队"></a>4. 投研团队</h2><p>投研团队是基金公司硬实力的体现，但是也是比较难调查的一部分。</p><p>中银基金一直很低调，官网关于投研团队的描述十分简单：</p><blockquote><p>中银基金拥有一支高度稳定、经验丰富、广受业内认可的投研团队，投研人数超过70人，基金经理队伍明星荟萃，为投资者创造了持续优异的业绩回报！</p></blockquote><p>网络上也鲜有相关报道，到是有一篇投研文化的采访，着重突出了<strong>“快乐投资”</strong>，想来这也是中银基金基金经理平均任职年限比较长的原因吧🤔。</p><p>能否培养出自己的明星基金经理，也是投研团队实力强弱的一种体现。从这个角度看，中银基金投研团队的实力似乎一般。</p><h2 id="5-合规信息"><a href="#5-合规信息" class="headerlink" title="5. 合规信息"></a>5. 合规信息</h2><p>2020年，中银新发基金“中银顺兴回报”的宣发资料，引起了不小的非议。该基金的宣传材料中，按照基金经理的任职最大回撤率以及任职年化回报两个指标列示了一张象限图，“2015年任职至今平衡混合型基金及其基金经理”，进行同业对比。</p><p>引发市场争议的则是，该图表“拉踩”多家同业，“衬托”中银顺兴回报的拟任基金经理。</p><p>根据《证券投资基金销售管理办法》，基金宣传推介材料不得诋毁其他基金管理人、基金托管人或者基金销售机构，或者其他基金管理人募集或者管理的基金。</p><p>除此之外，并未能检索到和中银基金相关的负面信息。可以说，在合规上，中银基金的表现还是十分不错的。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>至此，中银基金的分析就告一段落了。做个总结：</p><p>中银基金是一家典型的“银行系”基金管理公司，并把银行在固收产品领域的优势发挥到了极致，是一家<strong>“重债轻股”</strong>的特征鲜明基金管理公司。</p><p>中银基金在债券基金上，无论是是规模还是平均收益，都远超平均水平；但是在权益类基金上，管理规模较小，实力较差。</p><p>在基金行业火热发展的近5年，中银基金却没有跟上，逐渐呈现掉队趋势。</p><p>就我个人而言，短期内是不会考虑这家公司的任何产品。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>给自己打个广告。</p><p>由于深知闭门造车的弊端，我建了个微信群，用于交流投资理财心得，欢迎感兴趣的同学入群交流（公众号回复【联系方式】）。</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><em>说明：本文仅为个人投资记录及思考，不构成任何具体的投资建议！</em></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基金公司</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#15——2021年投资回顾</title>
    <link href="/2022/01/03/invest-pratice-15/"/>
    <url>/2022/01/03/invest-pratice-15/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a></p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更“美好”的事物上。</p><p><strong>道阻且长，行则将至，行而不辍，未来可期！</strong></p><h2 id="本月进展"><a href="#本月进展" class="headerlink" title="本月进展"></a>本月进展</h2><p>本月进展如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/03/16410297155532.jpg" alt=""></p><p>当前进展 3.38%，相比上个月增加了 0.17%。</p><p>对比了下2020年12月27日的资产情况，本金投入增加88.4%。储蓄和增值，今年完美实现了储蓄的目标😂。</p><p><strong>本月操作</strong></p><div class="table-container"><table><thead><tr><th>组合</th><th>操作</th></tr></thead><tbody><tr><td>跟投组合</td><td>长赢跟投</td></tr><tr><td>它山之石</td><td>定投</td></tr><tr><td>积水成渊</td><td>一份恒生互联，一份中国互联，一份恒生高股息</td></tr></tbody></table></div><p><em>注：每月定投金额在三个组合上的分配比例为1：1：1，其中积水成渊又被分成4份。未投出部分在进入现金账户沉淀。</em></p><h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2><p>虽然一毕业就开始接触投资理财，但是真正开始沉下心来研究也就近一年的事。2021年已经结束，这次就来复盘一下今年的投资情况。</p><h3 id="2021年收益情况"><a href="#2021年收益情况" class="headerlink" title="2021年收益情况"></a>2021年收益情况</h3><p>先来看一下整体的收益情况。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/03/16411922676063.jpg" alt=""></p><p>有知有行的账本做的越来越好，除了能分账户统计收益情况，还能按年对比收益率。</p><p>记账以来，资金加权收益率 40.49%，年化收益率 12.97%，2021年资金加权收益率 4.76%。</p><p>单纯看收益率，并不能看出水平，4.76% 的收益率，放到2018年，秒杀90%，但是放到19年或者20年，只能说比亏损好一些。所以我们横向对比一下，看下这个收益率真实水平如何？</p><p>下面是韭圈儿统计的金融资产历年收益图：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/03/16411974408733.jpg" alt=""></p><p>先看2021年，4.76% 的收益率介于股票基金和债券基金之间，还算差强人意。最高的股票，全年整体收益率是 9.17%，最低的是货币基金 2.27%，差距并不大，说明今年市场赚钱效应一般。</p><p>不管怎么说，今年的收益水平还是跑赢了银行理财，保住了一丝尊严😅。</p><p>另外，这张图中有个亮点，<strong>2019年和2020年股票基金的收益率在所有金融资产中排名第一</strong>！</p><p>近两年，基金作为热点话题的次数远超以往，虽然基金作为普通投资者主要投资方式是未来的趋势，但是我们不能忽视19年、20年是基金大年的背景，因此对未来几年基金的收益仍然要保持谨慎乐观。</p><h3 id="它山之石"><a href="#它山之石" class="headerlink" title="它山之石"></a>它山之石</h3><p>它山之石是我自己建的一个主动基金组合，具体细节可以看文章 👉 <a href="mweblib://16361887676151">财务自由实证#13——介绍下新开的两个组合</a>。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/03/16411921700246.jpg" alt=""></p><p>它山之石近3个月收益率 5.58%，跑赢沪深300 超4个点，虽然创建时间比较短，收益数据参考意义不大，但是毕竟还是跑赢了，也挺满意。</p><p>有必要把组合中的兴全趋势说一下。兴全趋势刚加入到组合中没多久，董承非就离职了，真可谓出师未捷身先死，长使英雄泪满襟！</p><p>这种情况该如何应对？我想了挺长时间，如果遵循常规的<strong>选基金就是选基金经理</strong>的思路，那这个时候我应该立即卖出兴全趋势，买入董承非新管理的基金。</p><p>有这种想法的人不少，下面是百度的候选推荐，第一个就是问新管理的基金是什么。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/03/16412063116387.jpg" alt=""></p><p>然而直到现在也没人知道他最终去哪（也可能是我不知道😅），如果董承非去私募了，或者不干了，怎么办？再选一个基金经理？那要是新经理再离职呢？</p><p>经过一段时间的思考，我逐步确立了<strong>基金公司-&gt;基金经理—&gt;基金产品</strong>的基金筛选思路。</p><p>目前初步筛选出了一批基金公司名单（见👉<a href="mweblib://16398096456316">筛选了一份基金公司名单！</a>），接下来会挨个分析这些基金公司，再进一步找出合适的基金产品，放到组合中。</p><p>所以除非后续有更优的选择或其它考虑，当前组合内的兴全趋势我会一直持有下去。</p><h3 id="积水成渊"><a href="#积水成渊" class="headerlink" title="积水成渊"></a>积水成渊</h3><p>积水成渊是我自己建的一个指数基金组合，具体细节可以看文章 👉 <a href="mweblib://16361887676151">财务自由实证#13——介绍下新开的两个组合</a>。</p><p>下面是该组合建立以来的收益情况：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/03/16412210932793.jpg" alt=""></p><p><em>注：默认比较基准是 80%\</em>中证800 + 20%*中债综合指数。*</p><p>前一个月还好，后两个月大幅跑输基准收益，跑输的主要原因是中概互联近期大幅下跌。</p><p>之前在交流群里写过一段关于低估策略的理解，我认为低估策略是一种很好理解，但是持有体验稍微糟糕的策略。</p><p>当某个指数处于低估时买入，未来大概率会继续低估；当某个指数高估时卖出，未来大概率会继续高估。这要求投资者在其它品种高歌猛进的时候，将资产转换到低估且持续下跌的品种上。是有点反人性的。</p><p>低估的收益来源是低跌幅，所以使用低估策略需要通过加仓节奏严格控制持有成本，只有跌幅足够小，才能在上涨的时候有足够的收获。</p><p>积水成渊的加仓节奏整体比较满意（图中红点），每月的子弹也没有全打出去。</p><p>新的一年的重点是细化各类指标，形成完备的操作手册，彻底隔绝情绪的干扰。</p><p>由于最近一年才开始稍微深入的思考投资策略，前期想法不稳定，实证账户中部分资产变动较为频繁。</p><p>这几次变动，不谈收益，手续费都扣了不少。由此可见，如果没有一个适合自己的稳定的投资体系，</p><h2 id="新年展望"><a href="#新年展望" class="headerlink" title="新年展望"></a>新年展望</h2><p>新的一年，无论过去收益多少，都翻篇了。</p><p>新的一年，希望能完善主动基金组合和指数组合的分析框架以及操作细节，进一步完善自己的投资体系。</p><p>新的一年，也祝各位同行者在投资道路上，无论理论与实践，都能有所收获！</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>给自己打个广告。</p><p>由于深知闭门造车的弊端，我建了个微信群，用于交流投资理财心得，欢迎感兴趣的同学入群交流（公众号回复【联系方式】）。</p><p><em>说明：本文仅为个人投资记录及思考，不构成任何具体的投资建议！</em></p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的2021年终总结</title>
    <link href="/2022/01/01/2021-summary/"/>
    <url>/2022/01/01/2021-summary/</url>
    
    <content type="html"><![CDATA[<p>几天前就在写这篇总结，一眨眼，几天过去了，一眨眼，这一年也过去了。</p><p>翻了下朋友圈，2021年元旦那天，写过这样一段话：</p><blockquote><p>从毕业到现在，一直在思考，如何才能做到“回首往事的时候，不会因为虚度年华而悔恨，也不会因为碌碌无为而羞耻”。</p><p>20年上半年，因为对未来的焦虑而无法入睡；下半年，不断审视自己，不断尝试，隐隐感觉到有一些变化正在发生；年底，终于明白我想要的未来以及为此该如何奋斗。</p><p>如果能穿越时光，和30年后的自己对话，希望能平静的说一声：“如你所愿，如我所愿”。</p></blockquote><p>一年后的今天，回过头来看这段文字，再回顾这一年，感慨万千。</p><h2 id="1-年初目标"><a href="#1-年初目标" class="headerlink" title="1. 年初目标"></a>1. 年初目标</h2><p>相比往年，21年年初的目标简单了很多，主要有以下5个：</p><ol><li>每周一篇 Go 的技术文章</li><li>每周两篇投资理财相关文章</li><li>知乎创作者等级达到LV6</li><li>公众号关注人数突破1000+</li><li>通过公众号挣1块钱</li></ol><h3 id="1-1-每周一篇-Go-的技术文章"><a href="#1-1-每周一篇-Go-的技术文章" class="headerlink" title="1.1 每周一篇 Go 的技术文章"></a>1.1 每周一篇 Go 的技术文章</h3><p>2021年，一共完成 Go 技术文章 16 篇，完成率 30.7%。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/01/16408865323240.jpg" alt=""></p><p>上图是每月输出 Go 相关文章的统计。从图中可以看出，Go 相关文章的输出集中在1-5月份，后面7个月基本处于停滞状态。这是因为上半年的输出主要是《Go 并发编程实战课》的学习心得，课程结束后，就暂时放下了。</p><p>没想到这一放，就放了半年。新的一年，这个目标还是要继续坚持下去。</p><h3 id="1-2-每周两篇投资理财相关文章"><a href="#1-2-每周两篇投资理财相关文章" class="headerlink" title="1.2 每周两篇投资理财相关文章"></a>1.2 每周两篇投资理财相关文章</h3><p>2021年，一共完成投资理财相关文章 36 篇，完成率 34.6%。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/01/16408865220730.jpg" alt=""></p><p>这张图是每月输出投资理财相关文章的统计。从图中可以看出，投资理财方向的文章虽然输出的频率达不到每周两篇的水平，且波动稍大，但是更新的持续性还是比较不错的。</p><p>另外，感慨一下，1月份真是高产，无论是目标1还是目标2。</p><h3 id="1-3-知乎创作者等级达到LV6"><a href="#1-3-知乎创作者等级达到LV6" class="headerlink" title="1.3 知乎创作者等级达到LV6"></a>1.3 知乎创作者等级达到LV6</h3><p>目前知乎创作者等级是LV4，差一点是LV5，距离LV6还很遥远。</p><p>最开始回答过一些题目，后面主要是同步公众号的文章，有点水。</p><p>现在公众号也改了推送机制，渐渐向推荐靠拢，整体的阅读率不再稳定，新的一年，像知乎这样的自媒体平台，还是要重视起来。</p><p>另外有个意外收获，有一篇文章正好赶上知乎某个活动，分了25块钱，这应该算是写文章以来最大的稿费收入了😂。</p><h3 id="1-4-公众号关注人数突破1000"><a href="#1-4-公众号关注人数突破1000" class="headerlink" title="1.4 公众号关注人数突破1000+"></a>1.4 公众号关注人数突破1000+</h3><p>稍有遗憾，公众号的关注人数并没有能突破1000。</p><p>去年底的时候开始写这个公众号，到现在满打满算，一年零一个月。</p><p>开始写技术类文章的时候，还会将文章发到1到2个技术交流群，稍微推广一下，后面投资理财类的除了偶尔发发朋友圈，基本没有推广。所以关注的增长基本来源于微信推荐、自然增长。</p><p>虽然目前的关注量相比很多大v不值一提，但是也清楚，当前自己的水平还有较多欠缺，输出频率也很不稳定，等能力提升到某个程度后，再去研究怎么推广自己。</p><p>酒香也怕巷子深，何况还是一瓶清酒呢。</p><h3 id="1-5-通过公众号挣1块钱"><a href="#1-5-通过公众号挣1块钱" class="headerlink" title="1.5 通过公众号挣1块钱"></a>1.5 通过公众号挣1块钱</h3><p>该目标完成于2021年8月28日，文章 👉 <a href="http://mp.weixin.qq.com/s?__biz=Mzg5NjU0MzU1Mg==&amp;mid=2247484196&amp;idx=1&amp;sn=403c25db72ac36e88a317faf829f6780&amp;chksm=c07e3d0bf709b41d2496607259ac802da2b4438f1e97d3a3b69d74b6c58456ec9a7d81c8383c#rd">财务自由实证#10——Are You OK?</a> 发布之后，收到了读者 <em>@奇思妙想</em> 的赞赏。</p><p>网络的一端，我写了一篇文章；另一端，有一个陌生的读者看了，还用付费赞赏表达了对文章和作者的肯定。我们之前从未谋面，也许之后永远也不会谋面，但是欣赏与肯定又真真实实的发生在我们之间。很奇妙的一种感觉。</p><p>有点能理解很多大V并不缺钱，但仍然很看重赞赏的原因了。</p><p>新的一年，争取获得更多读者的认可。</p><h2 id="2-除此之外，这一年"><a href="#2-除此之外，这一年" class="headerlink" title="2. 除此之外，这一年"></a>2. 除此之外，这一年</h2><p>除此之外，这一年，工作之余也干了一些事情，读了一些书，虽然不出彩，但也值得记录一下。</p><h3 id="2-1-写了一个小程序：投资工具箱。"><a href="#2-1-写了一个小程序：投资工具箱。" class="headerlink" title="2.1 写了一个小程序：投资工具箱。"></a>2.1 写了一个小程序：投资工具箱。</h3><p>最初的一个想法是将投资过程中经常用到的一些功能、指标等集成到这个小程序中，方便自己使用。</p><p>目前完成度比较高的功能是定投计算器，支持 <strong>期末资产、年化收益率、定投金额、初始金额、投资年限</strong> 这5个变量之间的相互计算。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/01/16409692886982.jpg" alt=""></p><p>其它功能虽然有一些规划，但是想的并不是很清楚，完成度也比较低，等后续想法成熟了再放出来。</p><h3 id="2-2-阅读了两本书"><a href="#2-2-阅读了两本书" class="headerlink" title="2.2 阅读了两本书"></a>2.2 阅读了两本书</h3><p>读了一些本书，其中《基金》和《投资要义》有必要记录一下。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/01/16409611675274.jpg" alt=""></p><p>《基金》是我关注的一个公众号 <strong>EncounterAlpha</strong> 推荐的。</p><p>本书介绍了基金业规范发展的20年，涵盖了法制建设、行业治理、市场创新、对外开放等诸多方面，全景式展现了中国基金业的发展历程。</p><p>这二十年，基金行业从开始的野蛮生长，逐步发展成为制度体系最为完善、信托关系落实最为充分、投资者权益保护最为有效的行业，成为资产管理行业的标杆。</p><p>本书没有讲述任何基金投资方法，但是读完本书，会让你对基金行业有一个全新的认识，对这个行业未来的发展也更有信心。</p><p>《投资要义》是读者朋友 <em>@Hades</em> 强烈推荐的一本书，说是改变他一生的奇书。</p><p>本书前半部分讲投资体系，后半部分讲投资工具，可谓是理论结合实践的典范。</p><p>这本书中，作者认为，<strong>“风险和收益是不对称的”</strong>，很多情况时候，风险很低，但是收益却不低。</p><p>作者的投资体系可以划分为三个层级，重要性从高到低分别是：</p><ol><li>系统性机会与系统性风险的识别</li><li>资产配置与动态再平衡</li><li>投资工具的使用</li></ol><p>本书围绕这个投资体系，在第一部分详细阐述了如何利用市盈率、市净率等指标判断市场是否有系统性机会或者系统性风险；第二部分，讲述了“低估分散不深研”的核心思想，以及如何利用这种思想指导资产配置与动态再平衡；第三部分，则深入到具体的投资工具（股票、债券、可转债、期权等），详细介绍了他们的特点、应用场景和使用方式。</p><p>即便是证券市场周刊的特约作者，作者仍然选择了“低估分散不深研”的思路，我想这对普通投资者研究如何使用投资工具会有很大的借鉴意义。</p><h2 id="3-2021年的值得记录的两件事"><a href="#3-2021年的值得记录的两件事" class="headerlink" title="3. 2021年的值得记录的两件事"></a>3. 2021年的值得记录的两件事</h2><h3 id="3-1-媳妇顺利毕业"><a href="#3-1-媳妇顺利毕业" class="headerlink" title="3.1 媳妇顺利毕业"></a>3.1 媳妇顺利毕业</h3><p>今年是媳妇读博的最后一年，原计划是6月份毕业，但是第一次校盲有一份评审没过，无奈只能延期半年。</p><p>盲审结果出来那会，我正在上班的路上。一路上都和媳妇打着电话，媳妇断断续续的说了很多，说第三份评审意见有多不合理，说被老师批评送审的评阅书研究方向写的不对等等。</p><p>恰好这一天是摇号公布的日子，中午忽然收到短信：中签了。于是又赶紧给媳妇打电话，两人在电话里又哭又笑，不知道该如何表达此刻的心情。这也应了那句老话：祸兮福之所倚，福兮祸之所伏。</p><p>下半年，在压力极大的情况下，媳妇一遍又一遍，反反复复的修改论文。这期间，家庭方面，双方父母都没有任何责备，而是不断的鼓励和支持，再加上我尽心尽力的后勤保障工作，最终媳妇顺利完成了博士答辩。</p><p>虽然寥寥数语，但是其中艰辛只有媳妇自己知道。</p><p>20多年读书生涯完美收官，恭喜媳妇进入人生下一个阶段！</p><h3 id="3-2-放弃户口"><a href="#3-2-放弃户口" class="headerlink" title="3.2 放弃户口"></a>3.2 放弃户口</h3><p>下半年，北京市出了单列计划，近三年的应届生，如果符合要求，都能获得户口。而我无论是毕业时间，学校还是专业，都刚好满足要求。</p><p>获得户口最容易的一次机会就是校招，但是工资和户口很难两全。有户口的工作，工资很低；而工资较高的互联网行业，很难拿到户口。</p><p>现在忽然有一个机会，能兼顾工资和户口，自然是兴奋的不行。那段时间，天天晚上回到家都不停的和家里讨论未来如何如何。</p><p>可是，随着讨论进一步的深入，很多之前没有考虑过的现实问题逐渐浮现在眼前。</p><p>网上查了很多资料，也咨询了很多人，最终发现，对我而言，户口不仅不能带来更多，反而是一种负担。</p><p>户口附带的资源都和房子挂钩，尤其是教育，挂钩的还是学区房，需要投入巨额成本。而房地产的黄金时期已经过去，“房住不炒”是未来很多年的主旋律，再加上教师轮岗，未来的不确定性太高。</p><p>经常看这个公众号的朋友都知道，财务自由是我一直以来追求的目标，甚至是远期规划中优先级最高的目标。如果我选择拿这张入场券，可以预见，基本就和自由无缘了。</p><p>所以慎重考虑之后，还是放弃了这个户口。放弃之后，反而一身轻松，因为在核心目标之前，我经受住了考验！</p><p><em>注：由于篇幅所限，以及一些不太方便明说的原因，不建议大家直接参考我这种做法，还是要结合自己实际情况再做选择。</em></p><h2 id="4-结尾"><a href="#4-结尾" class="headerlink" title="4. 结尾"></a>4. 结尾</h2><p>2021年已经过去，谈不上十分满意，但也没什么可后悔的。</p><p>虽然不少事情完成度不高，但是方向十分清晰，相比往年，焦虑少了很多。</p><p>有方向，就不怕。</p><p>所以，2022年，继续干就是了！</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 闭包问题</title>
    <link href="/2021/12/14/go-closure/"/>
    <url>/2021/12/14/go-closure/</url>
    
    <content type="html"><![CDATA[<p>前几天在机械的堆砌业务代码时，不小心掉进了 Go 循环中使用闭包的一个坑，因此借这个机会总结一下 Go 闭包问题相关的知识。</p><h2 id="1-什么是闭包？"><a href="#1-什么是闭包？" class="headerlink" title="1. 什么是闭包？"></a>1. 什么是闭包？</h2><blockquote><p>一个函数和对其周围状态（词法环境）的引用捆绑在一起，这样的组合就是闭包。</p></blockquote><p>直接看定义，很难理解闭包到底什么。所以我画了下面这张图：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/12/13/bi-bao.jpg" alt="闭包"></p><p>这张图中，自由变量 i 和函数 f 构成了闭包。</p><p>由此，可以总结闭包的几个关键点：</p><ol><li>自由变量 i 和函数 f 同属于一个局部环境</li><li>函数 f 内部直接使用了自由变量 i</li></ol><p>在外部环境无法直接访问自由变量，通过执行函数 f 能实现对 i 的操作。</p><p>需要注意的是，自由变量<strong>不一定是在局部环境中定义</strong>的，也有可能是以参数的形式传进局部环境；另外在 Go 中，<strong>函数也可以作为参数传递</strong>，因此函数也可能是自由变量。</p><h2 id="2-闭包的应用场景"><a href="#2-闭包的应用场景" class="headerlink" title="2. 闭包的应用场景"></a>2. 闭包的应用场景</h2><h3 id="2-1-数据隔离"><a href="#2-1-数据隔离" class="headerlink" title="2.1 数据隔离"></a>2.1 数据隔离</h3><p><strong>需求:</strong></p><blockquote><p>统计一个函数的执行次数，并打印出来（其实就是计数器）</p></blockquote><p>不考虑闭包，短平快的一种实现方式是声明一个全局变量，函数每执行一次，变量值加一，并打印。</p><p>这种方法的一个缺点是全局变量容易被修改，安全性较差。闭包可以解决这个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newCounter</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span> &#123;<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        i++<br>        fmt.Println(i)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    counter := newCounter()<br>    counter()<br>    counter()<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 <code>i</code> 是 newCounter 内部变量，无法从外部修改，因此在实现计数器的同时，也实现了数据隔离的效果。</p><h3 id="2-2-中间件"><a href="#2-2-中间件" class="headerlink" title="2.2 中间件"></a>2.2 中间件</h3><p>Go 中的中间件和 Python 中的装饰器十分类似。</p><p>在 Go 中，函数是 <strong>一等公民</strong>，即函数可以像普通类型一样，被赋值给变量，作为参数传递，作为返回值。</p><p>因此在闭包中，除了动态创建函数，还可以通过参数传递的方式，将函数穿进去，实现闭包。</p><p>典型的应用场景是中间件。</p><p><strong>需求:</strong></p><blockquote><p>计算任意函数（函数签名一致）的执行耗时。</p></blockquote><p>具体实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> funcSign <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">timer</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>(<span class="hljs-keyword">int</span>)</span>) <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span></span> &#123;<br>start := time.Now()<br>f(n)<br>end := time.Now()<br>fmt.Println(<span class="hljs-string">&quot;This operation take &quot;</span>, end.Sub(start))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printN</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;printN is running, n is &quot;</span>, n)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>printNWithTimer := timer(printN)<br>printNWithTimer(<span class="hljs-number">1</span>)<br>printNWithTimer(<span class="hljs-number">10</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，函数 printN 是自由变量。</p><p>printN 原本是普通的函数，但是通过 timer 的包裹，返回的 printNWithTimer 不仅具备 printN 的全部功能（且不需要了解实现），还能计算 printN 的执行耗时。</p><h3 id="2-3-访问原本访问不到的数据"><a href="#2-3-访问原本访问不到的数据" class="headerlink" title="2.3 访问原本访问不到的数据"></a>2.3 访问原本访问不到的数据</h3><p>在一些场景下，只能传递参数类型固定的函数，这个时候如果要访问额外的数据，就可以使用闭包。</p><p>比如 Go 内置的 <code>net/http</code> 包，启动一个 webserver 时候，每个路由都需要注册一个 handlerFunc 类型的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Database <span class="hljs-keyword">struct</span> &#123;<br>  Url <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewDatabase</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">Database</span></span> &#123;<br>  <span class="hljs-keyword">return</span> Database&#123;url&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  db := NewDatabase(<span class="hljs-string">&quot;localhost:5432&quot;</span>)<br><br>  http.HandleFunc(<span class="hljs-string">&quot;/hello&quot;</span>, hello(db))<br>  http.ListenAndServe(<span class="hljs-string">&quot;:3000&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(db Database)</span> <span class="hljs-title">func</span><span class="hljs-params">(http.ResponseWriter, *http.Request)</span></span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    fmt.Fprintln(w, db.Url)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>http.HandleFunc 的第二个参数只接受函数签名如下的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> handlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span><br></code></pre></td></tr></table></figure><p>在不使用全局变量的情况下，我们可以通过闭包实现对 db 的访问。</p><p>当然，这种情况我们通常采取的是另一种解决方式：对结构体 Database 增加一个相同函数签名的成员函数。</p><h3 id="2-4-二分查找"><a href="#2-4-二分查找" class="headerlink" title="2.4 二分查找"></a>2.4 二分查找</h3><p>Go 的基础库 <code>sort</code> 中使用闭包的场景随处可见。</p><p><strong>需求:</strong></p><blockquote><p>对任意一个有序列表，查找大于指定值的索引。注意，有序列表的元素是自定义类型。</p></blockquote><p>由于是自定义类型，常见的做法是每个自定义类型都实现自己的查找方法，但是如果使用的闭包的话，就简单很多。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  numbers := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">12</span>&#125;<br>  sort.Ints(numbers)<br>  fmt.Println(<span class="hljs-string">&quot;Sorted:&quot;</span>, numbers)<br><br>  index := sort.Search(<span class="hljs-built_in">len</span>(numbers), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">return</span> numbers[i] &gt;= <span class="hljs-number">7</span><br>  &#125;)<br>  fmt.Println(<span class="hljs-string">&quot;The first number &gt;= 7 is at index:&quot;</span>, index)<br>  fmt.Println(<span class="hljs-string">&quot;The first number &gt;= 7 is:&quot;</span>, numbers[index])<br>&#125;<br></code></pre></td></tr></table></figure><p><code>sort.Search</code> 内部实现了二分查找。二分查找的关键是列表有序、能比较大小。在类型未知的情况下，比较大小可以通过闭包实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">return</span> numbers[i] &gt;= <span class="hljs-number">7</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个作为参数传递的闭包，绑定了自由变量 numbers 和指定比较的对象 7，匿名函数实现了比较大小的功能。</p><p>下面是 <code>sort.Search</code> 的源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Search</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span>) <span class="hljs-title">int</span></span> &#123;<br>i, j := <span class="hljs-number">0</span>, n<br><span class="hljs-keyword">for</span> i &lt; j &#123;<br>h := <span class="hljs-keyword">int</span>(<span class="hljs-keyword">uint</span>(i+j) &gt;&gt; <span class="hljs-number">1</span>) <span class="hljs-comment">// avoid overflow when computing h</span><br><span class="hljs-comment">// i ≤ h &lt; j</span><br><span class="hljs-keyword">if</span> !f(h) &#123;<br>i = h + <span class="hljs-number">1</span> <span class="hljs-comment">// preserves f(i-1) == false</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>j = h <span class="hljs-comment">// preserves f(j) == true</span><br>&#125;<br>&#125;<br><span class="hljs-comment">// i == j, f(i-1) == false, and f(j) (= f(i)) == true  =&gt;  answer is i.</span><br><span class="hljs-keyword">return</span> i<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-defer"><a href="#2-5-defer" class="headerlink" title="2.5 defer"></a>2.5 defer</h3><p>Go 中 defer 常常和闭包结合在一起用，常见的一种用法就是在函数返回后关闭文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleFile</span><span class="hljs-params">()</span></span> &#123;<br>    fPtr, err := os.Open(<span class="hljs-string">&quot;you file!&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;open file failed, &quot;</span>, err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> fPtr.Close()<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>defer 的机制是将后面的函数注册到 defer 的函数栈中，当前函数 handleFile 执行完成之后，defer 将函数栈的中函数取出来，一个一个的执行。</p><p>在这里，fPtr.Close() 其实是一个闭包（携带自由变量 fPtr），因此，即使 handleFile 执行结束，Close 函数仍然能对 fPtr 进行关闭操作。</p><h2 id="3-闭包的几个注意点"><a href="#3-闭包的几个注意点" class="headerlink" title="3. 闭包的几个注意点"></a>3. 闭包的几个注意点</h2><h3 id="3-1-值还是引用"><a href="#3-1-值还是引用" class="headerlink" title="3.1 值还是引用?"></a>3.1 值还是引用?</h3><p>闭包对自由变量的修改是引用的方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newFunc</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">func</span><span class="hljs-params">()</span>)</span> &#123;<br>i := <span class="hljs-number">0</span><br>f1 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i++<br>fmt.Println(i)<br><span class="hljs-keyword">return</span><br>&#125;<br>f2 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i++<br>fmt.Println(i)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">return</span> f1, f2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f1, f2 := newFunc()<br>f1()<br>f2()<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">1<br>2<br></code></pre></td></tr></table></figure><p>因为是引用，f1() 修改了 i 的值后，f2() 中 i 的初始值变成了1。</p><h3 id="3-2-自由变量的生命周期"><a href="#3-2-自由变量的生命周期" class="headerlink" title="3.2 自由变量的生命周期"></a>3.2 自由变量的生命周期</h3><p>闭包中，自由变量的生命周期等同于闭包函数的生命周期，和局部环境的周期无关。</p><p>借用参考文章[3]中的一张图：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/12/13/16393217690693.jpg" alt=""></p><p>闭包函数第一次调用之后，自由变量即进入堆内存上，后续闭包函数的每一次调用，都是对自由变量的引用。</p><h2 id="Go-循环中使用闭包的一个坑"><a href="#Go-循环中使用闭包的一个坑" class="headerlink" title="Go 循环中使用闭包的一个坑"></a>Go 循环中使用闭包的一个坑</h2><p>前一段时间，在业务代码中写出了如下的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(i)<br>&#125;()<br>&#125;<br>time.Sleep(<span class="hljs-number">1</span>*time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码能编译通过，也能运行，但是如果执行检查 <code>go vet main.go</code> 其实是会报错的。</p><p>这段代码的输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">3<br>6<br>6<br>6<br>6<br>6<br></code></pre></td></tr></table></figure><p>每次输出都不一定一样，但是都不符合预期。</p><p>这是因为 for 循环中开启的协程其实是闭包，6个并发协程读的都是同一个变量。</p><p>修改方式也很简单，不直接引用变量 i，而是通过传参的方式读取 i 的副本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(i)<br>&#125;()<br>&#125;<br>time.Sleep(<span class="hljs-number">1</span>*time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.calhoun.io/5-useful-ways-to-use-closures-in-go/">5 Useful Ways to Use Closures in Go</a></li><li><a href="https://chai2010.cn/advanced-go-programming-book/ch5-web/ch5-03-middleware.html">Go语言高级编程</a></li><li><a href="https://segmentfault.com/a/1190000021560558">Go语言闭包问题</a></li></ol><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#14——抢先E大一步发车！</title>
    <link href="/2021/12/04/invest-pratice-14/"/>
    <url>/2021/12/04/invest-pratice-14/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a></p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更“美好”的事物上。</p><p><strong>道阻且长，行则将至，行而不辍，未来可期！</strong></p><h2 id="本月进展"><a href="#本月进展" class="headerlink" title="本月进展"></a>本月进展</h2><p>本月进展如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/12/06/16386303604010.jpg" alt=""></p><p>当前进展 3.21%，相比上个月增加了 0.16%。</p><p><strong>本月操作</strong></p><div class="table-container"><table><thead><tr><th>组合</th><th>操作</th></tr></thead><tbody><tr><td>跟投组合</td><td>日积月累跟车一次</td></tr><tr><td>它山之石</td><td>定投</td></tr><tr><td>积水成渊</td><td>1份中证红利，1份中概互联，2份中证500</td></tr></tbody></table></div><p><em>注：每月定投金额在三个组合上的分配比例为1：1：1，其中积水成渊又被分成4份。未投出部分在进入现金账户沉淀。</em></p><p>11月发生了挺多事情，和这个实证计划最相关的就是投顾新规（投顾新规及其影响见👉<a href="https://mp.weixin.qq.com/s/F4pmkLyKuKO8gemw8qKpGQ">再谈基金组合</a>）。受此影响，实证计划中的云长进取更换了主理人，不会再跟投；日积月累直接无法跟投。</p><p>上一篇 👉 <a href="https://mp.weixin.qq.com/s/r0eUdg-3GWJK1DBw38NCrw">财务自由实证#13——介绍下新开的两个组合</a> 介绍了自建的两个实践组合，还没投热乎，部分跟投组合就不能投了，果然，一切的准备都不会白费。</p><p>虽然有种赶鸭子上架的感觉【旺柴】。</p><h2 id="抢先E大一步发车！"><a href="#抢先E大一步发车！" class="headerlink" title="抢先E大一步发车！"></a>抢先E大一步发车！</h2><p>啰哩啰嗦半天，终于进入正题了！</p><p>12月3号，12:13分，积水成渊组合买入一份恒生指数。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/12/06/img329eb19e5d7f1.jpeg" alt="IMG_329EB19E5D7F-1"></p><p>12月3号，13:27分，长赢计划发车，买入一份恒生指数（见👉<a href="https://mp.weixin.qq.com/s/XRpglzj8QZpQy_Up2zGEYQ">2021年12月ETF计划（二）：150买入一份；S买入一份</a>）！</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/12/06/16386346526535.jpg" alt="-w783"></p><p><strong>同样买入恒生指数，我抢在了E大前面！哈哈，哈哈哈，哈哈哈哈~~</strong></p><p>得瑟完了，接下来复盘一下。</p><h3 id="买入的原因"><a href="#买入的原因" class="headerlink" title="买入的原因"></a>买入的原因</h3><p>买入原因主要有两个。</p><p>一是市净率。当时看到这样一张图：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/12/06/16387251699064.jpg" alt=""></p><p>恒生指数的市净率已经跌到1附近，而观察恒生指数市净率的走势发现，一旦市净率跌到1以下，继续下跌的空间十分有限，所以此时买入比较合适。</p><p>二是暂时没啥可买的了。整个池子中低估也就500、中证红利和科技（中概互联）了。但是E大说过，<strong>左侧买入，空间、时间，至少取其一</strong>，买入太频繁对摊成本没什么作用。所以在看到恒生指数低估的情况下，就忍不住买入了一份。</p><p><em>注：在文章 👉<a href="https://mp.weixin.qq.com/s/r0eUdg-3GWJK1DBw38NCrw">财务自由实证#13——介绍下新开的两个组合</a> 中介绍过指数基金组合——积水成渊以及相应的指数候选池。</em></p><p>虽然目前积水成渊组合的观察指标、买入策略还在完善中，但无论如何，既然池子中没有这只指数，就不应该买入。要买也应该是先扩充指数池子，然后拟定策略，最后再执行。</p><p>所以总结下来，这次的买入完全就是一时冲动，无论这一份最终收益如何，都掩盖不了这一次操作没有遵守纪律的本质。</p><p>不过，积水成渊本就是用来实践和完善指数投资策略的组合，只要能发现问题，完善自己，组合就有意义。</p><h3 id="E大买入逻辑"><a href="#E大买入逻辑" class="headerlink" title="E大买入逻辑"></a>E大买入逻辑</h3><p>再来看一下E大买入的逻辑。</p><p>这次发车，有这样一句话：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/12/06/16387269685304.jpg" alt="-w676"></p><p>12月2号恒生指数收盘点位是23788，再下跌30%是16652，而近10年（多一个月）最低点是16250，其次是16822。</p><p>结合评论：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/12/06/16387283328038.jpg" alt="-w706"></p><p>34000接近10年最高点位（2018年1月26号，33154）。</p><p>可见E大除了用pe、pb、历史百分位等数据判断估值水平，还会用近10年的极限点位判断最大上涨或下跌空间。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/12/06/16387292233339.jpg" alt="-w656"></p><p>16年初，恒生指数最低18319，距离当时最近10年的最低点位11921，<strong>最大跌幅空间是35%</strong>，差不多也是今天的30%。</p><p>16年的密集买入，和18年的卖出，完美的实现了熊市到牛市的低买高卖。</p><p>除此之外，网格策略也取得了不错的收益。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/12/06/16387301180814.jpg" alt="-w710"></p><p>纵观恒生指数最近20年走势，虽然整体是在向上，但是中长期内还是以波动为主。</p><p>从这能看出，在E大眼里，恒生指数是一个波动大于成长的指数。</p><p>因此，E大买入恒生指数的逻辑可以总结如下：</p><ol><li>恒生指数是一个波动大于涨幅的指数</li><li>做好极限预估，分批买入。</li><li>除了大级别的高抛低吸等牛市，网格策略更优。</li></ol><h2 id="本月回顾"><a href="#本月回顾" class="headerlink" title="本月回顾"></a>本月回顾</h2><p>在 <a href="https://mp.weixin.qq.com/s/XWfjJ9WJ8DpxoVpaW1tacg">财务自由实证#7——实证升级了</a> 中，我对该实证计划进行了升级：日后该实证计划将会逐渐变成个<strong>人成长实证</strong>，除了例行的<strong>实证进展</strong>模块外，还会有<strong>本月回顾</strong>模块以及<strong>下月计划</strong>模块。</p><p>以下是11月回顾。</p><p><strong>写作</strong></p><ol><li>投资理财方向，只有4篇，完成度 <strong>100%</strong>。</li><li>专业技术方向，还是 0 篇，完成度 <strong>0%</strong>。</li></ol><p><strong>个人项目</strong></p><p>投入时间较少，仅有些许肉眼不可见的进展。。。</p><h2 id="下月计划"><a href="#下月计划" class="headerlink" title="下月计划"></a>下月计划</h2><p><strong>写作</strong></p><ol><li>投资理财方向，争取每周输出一篇。</li><li>素材积累上，坚持 flomo 每日记录。</li></ol><p><strong>投资工具箱小程序</strong></p><ol><li>继续完善指数组合模块，能根据常见市场指标，给出粗糙的买入卖出建议。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>给自己打个广告吧。</p><p>由于深知闭门造车的弊端，我建了个微信群，用于交流投资理财心得，欢迎感兴趣的同学入群交流（公众号回复【联系方式】）。</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#13——介绍下新开的两个组合</title>
    <link href="/2021/11/06/invest-pratice-13/"/>
    <url>/2021/11/06/invest-pratice-13/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a></p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更“美好”的事物上。</p><h2 id="本月进展"><a href="#本月进展" class="headerlink" title="本月进展"></a>本月进展</h2><p>按照惯例，本月进展如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2022/01/08/16410293626119.jpg" alt=""></p><p>当前进展 3.05%，相比上个月增加了 0.18%。进展的第一位数字终于破了2，可喜可贺！</p><p><strong>本月操作</strong></p><p>对老账户进行清理合并，下面是清理之后的持仓分布：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/11/07/16361915271155.jpg" alt="-w528"></p><p>主动基金组合不需要择时，所以它山之石承接了绝大部分清理出来的资金。</p><h2 id="介绍下自建的两个组合"><a href="#介绍下自建的两个组合" class="headerlink" title="介绍下自建的两个组合"></a>介绍下自建的两个组合</h2><p>之前在文章 👉<a href="https://mp.weixin.qq.com/s/mDYld4Buy6lUn9lggxtxDg">下一步：构建自己的投资组合</a> 中介绍过为什么要建立自己的组合以及怎么建立。没有看过的小伙伴可以​看一下。</p><p>10月份，对自己的账户进行了一番梳理，长期组合部分，初步形成了“三足鼎立”的局面：</p><ul><li>跟投组合</li><li>主动基金组合——它山之石</li><li>指数基金组合——积水成渊</li></ul><p>跟投组合没啥好介绍的，下面主要介绍下自建的两个组合。</p><h3 id="主动基金组合——它山之石"><a href="#主动基金组合——它山之石" class="headerlink" title="主动基金组合——它山之石"></a>主动基金组合——它山之石</h3><blockquote><p>它山之石，取自《诗·小雅·鹤鸣》：“它山之石，可以攻玉”，寓意借主动基金完善自己的投资认知。</p></blockquote><p>它山之石中一共有三只基金：富国天惠、兴全趋势、兴全合宜，仓位各占三分之一。这三只大家都比较熟悉，就不做过多介绍了。</p><p>下面是该组合成立39天以来的表现：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/11/07/img9486e4c04cb11.jpeg" alt="IMG_9486E4C04CB1-1-w414"></p><p>虽然一个月时间说明不了啥，但还是跑赢沪深300指数2个点，十分满意。由于成立时间较短，波动率和夏普比率暂时还没有，等时间长了再看看。</p><p>这里说一说我的主动基金选择思路：<strong>找下限</strong>！</p><p>之前在 <a href="https://mp.weixin.qq.com/s/BcCEm0Z265lsjTPQIm1M0g">聊一聊基金公司——兴证全球（兴全）</a> 提过，基金公司就是一只基金的下限。</p><p>在证券品种越来越丰富、交易策略越来越复杂、信息化手段越来越丰富的今天，一只优秀基金的背后，一定站着一个优秀的基金经理+一个优秀的投研团队。不否认优秀的基金经理的作用，但我们也不能忽视投研团队的能力。</p><p>比如，翻阅兴证全球旗下基金的季度报的时候，在投资策略部分，都会提到这两个关键词 “<strong>兴证全球多维趋势分析系统</strong>”和“<strong>兴证全球固定收益证券组合优化模型</strong>”：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/11/07/16362031934867.jpg" alt="-w784"></p><p>这个分析系统和优化模型就体现了基金公司投研团队的实力，只要公司投研实力强，基金的业绩就不用太担心。</p><p>另外前两天看了EA君的文章：<a href="https://mp.weixin.qq.com/s/b_t4e2K5QnJdJO7HL7zF4A">我的基金投资困惑之一：发掘基金经理的业绩依赖症</a>，深有感触。</p><p>寻找主动基金的时候，如果执着于寻找最优秀的基金经理，会面临下面这三个问题：</p><p><em>1. 什么样的基金经理是最优秀的？</em><br><em>2. 怎么早早找到最优秀的基金经理？</em><br><em>3. 怎么确定优秀的基金经理未来的业绩是可持续的？</em></p><p>问题1 和问题2 是一个<strong>先有鸡还是先有蛋</strong>的问题。判断一个基金经理优秀与否，只能依赖对其长期业绩的观察。而长期观察必然导致我们无法<strong>早早</strong>发掘，也就会错过基金经理体现其优秀的这段时期。</p><p>接下来，基金经理能否继续保持优秀的业绩也是一个问题。有太多的优秀的基金经理走下神坛。另外，基金经理平均任职期限只有3年多一点，虽然朱少醒16年专情一只基金，可全市场也只有这一个朱少醒，侧面也说明了基金经理变动率高的事实。</p><p>公募基金压力大，限制多，出名难，私募基金更自由，发挥空间更大，奖励更丰富，如果你是明星基金经理，你会怎么做？</p><p>因此，把对基金未来的预期完全寄托在基金经理上，仍然有很大的不确定性。</p><p>这也是为什么我会选择<strong>找下限</strong>作为挑选基金原则的原因。当然，除了基金公司，我还在找其它能代表基金下限的因素，等想法成熟了再和大家分享。</p><p>细节上，由于追求长期收益，不会选择债券基金和货币基金（<em>各位不要误解，不是说我不买债基，只是在这个实证中我不会买</em>）。偏股型基金股票占比的要求更高（招募说明书中会有），相对的，基金经理发挥的空间就会小一些（熊市的时候仍然需要持有相当比例的股票），所以我会更倾向于混合型基金。</p><p>还有就是各类主题基金如白酒、光伏、新能源等，由于没有相关行业背景，我也不会买。你买我推荐，我买我不买，毕竟我真的得掏钱​[旺柴]</p><h3 id="指数基金组合——积水成渊"><a href="#指数基金组合——积水成渊" class="headerlink" title="指数基金组合——积水成渊"></a>指数基金组合——积水成渊</h3><blockquote><p>积水成渊，取自《荀子·劝学》的“积水成渊，蛟龙生焉”，寓意定投的积小成多。</p></blockquote><p>积水成渊中都是指数基金，目前已经购买的有中证500、中证红利、中概互联（中证海外互联）以及中证养老，都是当前处于低估中的指数。</p><p>由于且慢不支持购买组合中的单只基金，只能在天天基金上建立了这个组合，目前用下来体验甚好，比较推荐。</p><p>下面是该组合近一个月的表现：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/11/07/16362222774190.jpg" alt=""></p><p>参考标的那需要说明一下，默认对比的是 <strong>中证800 <em> 80% + 中债综合 </em> 20%</strong>。近一个月实际跑输沪深300，不过没啥感觉，不着急。</p><p>积水成渊思路比较简单。之前做过指数定投的回测，相比于简单的定投或者是单只指数的“低买高卖”，对指数组合的低买高卖，资金利用率更高，收益也更高。</p><p>利用指数估值买指数是比较容易的，更关键的问题是<strong>买哪些指数？</strong></p><p>都说买指数是买国运，这话只说对了一半。拿教育指数举例，教育ETF6月8号成立至今，单位净值0.473，下降幅度52.7%。你能说教育指数代表了国运吗？显然不能。</p><p>哪些指数代表国运呢？E大15年写过《我的六位指数知己》的文字片段，用红颜知己和好友来形容以下6只指数：医药指数、消费指数、信息指数、上证50、中证500、创业板。</p><blockquote><p>知己，能共度一生。虽是知己，但我深知，他们富贵之时，我愿静静离开，在远处深深为他们祝福。有朝一日他们落魄街头，我愿分陋室一间、米粥一碗，助他们度过黑暗，共赴下一次辉煌。</p></blockquote><p>E大的这段文字认为这六个指数值得长期持有，但是不同阶段（估值高低），对待方式是不一样的。</p><p>今年5月，E大对其偏好的指数进行了更新，分别是300、500、创业、科创、科技、消费、医疗。</p><p>除此之外，我观察到知有行的黑板报“核心”+“卫星”策略，其关注的指数相比E大，多了中证红利、中证养老和上证50。</p><p>参考之后，结合我自己的偏好，我把 <strong>300、500、创业、科创、科技、消费、医疗、中证红利和中证养老</strong> 通通纳入了我的池子中。</p><p>剩下的就是“砸钱”和“等待”了【旺柴】</p><p><em>注：由于中证的几只科技指数年限较短，会用全指信息、中概互联等指数代替。</em></p><h2 id="本月回顾"><a href="#本月回顾" class="headerlink" title="本月回顾"></a>本月回顾</h2><p>在 <a href="https://mp.weixin.qq.com/s/XWfjJ9WJ8DpxoVpaW1tacg">财务自由实证#7——实证升级了</a> 中，我对该实证计划进行了升级：日后该实证计划将会逐渐变成个<strong>人成长实证</strong>，除了例行的<strong>实证进展</strong>模块外，还会有<strong>本月回顾</strong>模块以及<strong>下月计划</strong>模块。</p><p>以下是10月回顾。</p><p>10月份多请了几天假，回了趟老家。再加上最近比较忙，更新慢了许多，不过不用担心，本号还活着，会一直活着🥲。</p><p><strong>写作</strong></p><ol><li>投资理财方向，只有1篇，完成度 <strong>25%</strong>。</li><li>专业技术方向，还是 0 篇，完成度 <strong>0%</strong>。</li></ol><p><strong>个人项目</strong><br>暂时停滞。。</p><p>另外，《基金》快读完了，争取11月写几篇读书笔记。</p><h2 id="下月计划"><a href="#下月计划" class="headerlink" title="下月计划"></a>下月计划</h2><p><strong>写作</strong></p><ol><li>投资理财方向，争取每周输出一篇。</li><li>素材积累上，坚持 flomo 每日记录。</li></ol><p><strong>投资工具箱小程序</strong></p><ol><li>完善指数组合模块，能根据常见市场指标，给出粗糙的买入卖出建议。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>给自己打个广告吧。</p><p>由于深知闭门造车的弊端，我建了个微信群，用于交流投资理财心得，欢迎感兴趣的同学入群交流（公众号回复【联系方式】）。</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#12——一年了</title>
    <link href="/2021/09/30/invest-pratice-12/"/>
    <url>/2021/09/30/invest-pratice-12/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a></p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更“美好”的事物上。</p><h2 id="这一年"><a href="#这一年" class="headerlink" title="这一年"></a>这一年</h2><p>也大的实证计划，是我写这个实证的起因。我关注也大比较早，那个时候也大刚公开实证，进展 40% 左右，总收益还是负的。但是从也大的文字中，能清晰的感受到也大对于这条路的坚定，受此鼓舞，冲动之下，我也开始写实证了。</p><p>这一年，在疫情的影响下，口罩、健康码变成了生活常态；这一年，野蛮生长的互联网行业，陆续收到反垄断罚单，行业监管逐渐完善；这一年，“双减”政策出台，K12 教育培训行业团灭，教育 ETF 刚上市即腰斩。。。</p><p>这一年，也大的实证账户进展接近 100%，完美的验证了这条路的可行性。</p><p>这一年，我的实证账户的资产也从第一期的8.4万增长到14万，目标进度 2.87%。</p><p>刚开始写实证的时候，对投资的认识还比较浅薄，没有什么清晰的策略，每月月底除了贴一张当月的实证进展，常常绞尽脑汁想着能写点啥。</p><p>然而即使是这样，不知不觉，这个实证计划也写了一年了。</p><p>现在回过头来看当初写的 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">《财务自由实证#0——自由能实现吗？》</a> (👈点击查看)，论证虽然粗糙，可行性的结论仍然正确。</p><p>如果用最新一期的数据重新计算，需要的目标年化收益率才 6.93%。这个水平，相信任何一个对投资理财有了解的人，都不会觉得太难。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/09/30/16330105054775.jpg" alt=""></p><p>（自己写的小工具，等稍微完善之后会放出来，嘿嘿）</p><p>写实证的这一年中，一些投资想法不断在完善（点击查看👉 <a href="https://mp.weixin.qq.com/s/mDYld4Buy6lUn9lggxtxDg">下一步：构建自己的投资组合</a> ），于是为了实践自己的想法，我也建立了两个组合：</p><p>1、<strong>积水成渊</strong>（指数基金组合）<br>2、<strong>它山之石</strong>（主动基金组合）</p><p>积水成渊，取自《荀子·劝学》的“积水成渊，蛟龙生焉”，寓意定投的积小成多。</p><p>它山之石，取自《诗·小雅·鹤鸣》：“它山之石，可以攻玉”，寓意借主动基金完善自己的投资认知。</p><p>名字是不是还不错😀</p><p>（由于成立时间较短，平台限制，暂时无法公开。等限制期过了我会及时公开，供大家参考）</p><p>实证这一年，说长不长，说短不短，但无论如何都已经过去。</p><p>期待实证的下个一年~</p><h2 id="本月进展"><a href="#本月进展" class="headerlink" title="本月进展"></a>本月进展</h2><p>9月进展如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/09/30/16330099486055.jpg" alt=""></p><p>当前进展 2.87%，相比上个月增加了 0.09%。</p><p>本月操作：新建了两个组合，并对老账户进行了清理合并，将清理出来的部分资金转到新组合中。假期附近，很多操作受限，预计10月份能清理完毕。</p><h2 id="本月回顾"><a href="#本月回顾" class="headerlink" title="本月回顾"></a>本月回顾</h2><p>在 <a href="https://mp.weixin.qq.com/s/XWfjJ9WJ8DpxoVpaW1tacg">财务自由实证#7——实证升级了</a> 中，我对该实证计划进行了升级：日后该实证计划将会逐渐变成个<strong>人成长实证</strong>，除了例行的<strong>实证进展</strong>模块外，还会有<strong>本月回顾</strong>模块以及<strong>下月计划</strong>模块。</p><p>以下是9月回顾。</p><p><strong>写作</strong></p><ol><li>投资理财方向，加上这一篇，一共是3篇，完成度 <strong>75%</strong>。</li><li>专业技术方向，还是 0 篇，完成度 <strong>0%</strong>。</li></ol><p><strong>个人项目</strong></p><ol><li>小程序【投资工具箱】迭代了三个版本，明细如下：<br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/09/30/16330109328661.jpg" alt="-w459"></li></ol><h2 id="下月计划"><a href="#下月计划" class="headerlink" title="下月计划"></a>下月计划</h2><p><strong>写作</strong></p><ol><li>投资理财方向，至少输出4篇文章</li><li>专业技术方向，目标1篇（且看到底什么时候能完成。。）</li><li>素材积累上，坚持 flomo 每日记录。</li></ol><p><strong>投资工具箱小程序</strong></p><ol><li>完善指数组合模块，能根据常见市场指标，给出粗糙的买入卖出建议。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这会大家应该在回家或者出去玩的路上，疫情尚未结束，大家还是要多多注意。</p><p>祝大家国庆快乐，玩的开心~</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>下一步：构建自己的投资组合</title>
    <link href="/2021/09/20/create-self-investment-group/"/>
    <url>/2021/09/20/create-self-investment-group/</url>
    
    <content type="html"><![CDATA[<p>进入正文之前，提前先祝大家中秋节快乐！</p><p>19号，我趁着中秋节假期，又来了趟草原。9月的草原，冷了许多，也清净了许多。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/09/21/img2697.jpg" alt="IMG_2697"></p><p>晚上 19:57，在一个所谓的草原观景房（其实就是个三层带窗客房）中，辛勤的码字（现烤羊排需要等一个小时🤤）</p><p>晚上 21:40 回来更新一下，羊排没吃着，最后一个羊排上错了，没了【裂开】 最后和老板沟通，第二天中午送半价羊排，期待！</p><p>20号中午，终于吃上羊排了😭，就是有点肥。。<br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/09/21/wechatimg4599.jpeg" alt="WechatIMG4599"></p><hr><p>接下来进入正文。</p><p>看了<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg5NjU0MzU1Mg==&amp;action=getalbum&amp;album_id=1660571680026492929#wechat_redirect">财务自由实证系列</a> 的读者们都知道，我当前的操作都是跟投各种组合。2月份之前还有过自己的组合（根据指数估值拍脑袋），后来也废弃了，全面转向跟投。</p><p>但是随着研究的深入，很多问题渐渐变得清晰起来，构建自己的投资组合的冲动越来越明显。</p><h2 id="为什么要构建自己的投资组合？"><a href="#为什么要构建自己的投资组合？" class="headerlink" title="为什么要构建自己的投资组合？"></a>为什么要构建自己的投资组合？</h2><p>虽然有了构建自己的投资组合的冲动，但是投资并不能靠一时的冲动，所以行动之前先问一下自己：</p><p><strong>为什么要构建自己的投资组合？</strong></p><p>有两个原因。</p><p>一是跟投始终不是长久之计。</p><p>这里的<strong>不是长久之计</strong>有两层含义，一层是像<strong>长赢计划</strong>这样优秀的组合并不会一直存在，目前已知的是这一轮长赢结束之后，不会再有第四轮了，没有了之后怎么办？另一层是基金组合的市场越来越鱼龙混杂，目前也没有什么监管，筛选优秀组合的成本越来越高。</p><p>二是自我进化的需要。</p><p>投资是一门知行合一的学问，任你各种投资理论讲的天花乱坠，各种模型回测收益率逆天，只要不能落到实操上，都是空中楼阁。亲手构建自己的组合就是这样一个理论结合实践，并最终指导实践的过程。在这个过程中，沉淀下来的知识，就是我们可以依赖的、真实不虚的武器。</p><p>基于以上两个原因，我决定开始构建自己的组合。</p><h2 id="如何开始？"><a href="#如何开始？" class="headerlink" title="如何开始？"></a>如何开始？</h2><p>构建自己的投资组合，意味着背后需要一套完整的投资体系支撑，这个体系可以不完善，可以很粗糙，但不能不完整。</p><p>马克·泰尔（Mark Tier）在他著名的畅销书《巴菲特和索罗斯的投资习惯》中，曾经描述过一个典型的投资系统的样子，它应该包含以下几个部分：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/09/20/16320547444585.jpg" alt=""></p><p>一个典型的投资系统，需要包含以下三大部分：</p><ul><li>个人认知和投资哲学</li><li>能力圈和投资标准</li><li>投资策略</li></ul><p>只有把上面这三个问题都想清楚，才能开始构建自己的投资组合。</p><h2 id="说一说后续的思路"><a href="#说一说后续的思路" class="headerlink" title="说一说后续的思路"></a>说一说后续的思路</h2><p>细节以后再说，这里先大致说说以后的思路。</p><p>以后实证中的长期组合会分成以下三个部分：</p><ol><li>指数基金组合</li><li>被动基金组合</li><li>跟投组合</li></ol><p>每个月定投到长期组合的金额会平均分配到这三个部分中（跟投组合中的长赢不做限制），下面具体说一说这三个部分。</p><h3 id="1-指数基金组合"><a href="#1-指数基金组合" class="headerlink" title="1. 指数基金组合"></a>1. 指数基金组合</h3><p>这两天在知乎看到 <em>@诸葛不亮</em> 对长赢计划的一个分析，核心观点是：</p><p><strong>长赢是可以复制的成功！</strong></p><blockquote><p>很多大佬能在各种复杂的市场环境中获取各种超额收益，但是他们的理论体系很难复制。原因在于这些大佬的操作要么是个人风格过于明显，要么是量化门槛极高。</p><p>而E大的体系，属于那种公开透明，可以抄作业，也可以自己写作业，并且上到百亿下到千元都能适用的框架，所以对于散户可以稳定复制和跟随。</p></blockquote><p>一个比较明显的公开应用长赢计划思路的例子就是有知有行的<strong>黑板报栏目</strong>。</p><p>我之前写过一系列 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg5NjU0MzU1Mg==&amp;action=getalbum&amp;album_id=1995374708367654912#wechat_redirect">关于定投</a> 的文章。这个系列写完之后，就明白了以后研究的方向：</p><p><strong>利用组合提高资金利用率，利用估值实现“低买高卖”。</strong></p><p>是不是和长赢计划有点类似？这也算间接证明了长赢计划是可以复制的观点。</p><h3 id="2-主动基金组合"><a href="#2-主动基金组合" class="headerlink" title="2. 主动基金组合"></a>2. 主动基金组合</h3><p>忘了是在哪儿看到的一句话：<strong>主动基金被动买，被动基金主动买</strong>。和我最近的思考不谋而合。</p><p>我认为，买基金就两条路：一种是自己变成“专业人士”，买指数基金，通过主动操作获得收益，就像E大那样；另外一种就是买主动基金，专业的事情交给专业的人做，然后坚持投入。</p><p>这两条路各有优劣：路径一对自己能力要求高，走通了，前途一片光明；走不通，竹篮打水一场空。路径二对基金经理要求高，要求选对人，同时也要求自己能拿住，</p><p>无论哪一条路径，只要能走通，都能到达成功彼岸。</p><p>相比于构建指数组合，主动基金组合一旦构建完成，剩下的就只有坚持投入，十分省心。</p><p>所以出于分散和备份的考虑，接下来我也会找几只主动基金，构建一个简单的组合。</p><h3 id="3-跟投组合"><a href="#3-跟投组合" class="headerlink" title="3. 跟投组合"></a>3. 跟投组合</h3><p>到目前为止，跟投的收益还算不错，所以这个部分仍然保留，并且没有意外的情况下，会一直保留。</p><p>有这些组合在，我就会刻意的关注这些组合对应的主理人，这些组合的主理人都是目前我认为比较倾向的几个，关注他们我能学到很多。</p><p>其次，我可以用这些组合和我自己构建的组合做对比，当有一天无论是收益率还是波动率都能和这些组合持平，我也就到了能毕业的程度。</p><h2 id="说两句题外话"><a href="#说两句题外话" class="headerlink" title="说两句题外话"></a>说两句题外话</h2><p>如果你对这个组合感兴趣，公众号回复【联系方式】，欢迎进群一起交流！</p><p>希望我们一同见证，一个投资组合从诞生到不错的成长过程！</p><hr><p><strong>都看到这里了，不如点个 赞/在看，加个关注呗~~</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资组合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛熊市指标：市场成交额？</title>
    <link href="/2021/09/11/%E7%89%9B%E7%86%8A%E5%B8%82%E6%8C%87%E6%A0%87-%E6%88%90%E4%BA%A4%E9%A2%9D/"/>
    <url>/2021/09/11/%E7%89%9B%E7%86%8A%E5%B8%82%E6%8C%87%E6%A0%87-%E6%88%90%E4%BA%A4%E9%A2%9D/</url>
    
    <content type="html"><![CDATA[<p><em>最近略忙，文章写的慢，写着写着，数据就过时了。。</em></p><hr><p>截止9.2日，A股成交额已经连续32天突破万亿，在历史上仅次于2015年5月8日至7月8日（43个交易日）。</p><p>下图红色方框是2015年5月8日至7月8日中证全指和沪深300的走势：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/09/11/16310285029361.jpg" alt="-w1279"></p><p>这可是15年大牛市中最掐尖的一段时期！</p><p>所以，当下的状况很难不让人联想：接下来牛市会直接开启吗？</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/09/11/niushi.jpeg" alt="niushi"></p><h2 id="牛市要来了吗？"><a href="#牛市要来了吗？" class="headerlink" title="牛市要来了吗？"></a>牛市要来了吗？</h2><p>最直接的，成交额反应了市场的人气水平。市场人气越旺盛，成交额就会越高；反之人气越低迷，成交额就会越低。</p><p>下面是且慢文章 <a href="https://mp.weixin.qq.com/s/CwOSng5FU6Qpw4aP30U_OQ">《成交额连破万亿，是福是祸？》</a> 中的一张图：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/09/11/16307732068783.jpg" alt="-w1069"></p><p>这张图中，蓝色区域表示成交额，对应左边的纵坐标，单位是亿元。可以看到，2015年的大牛市中，单日成交额甚至突破到了2万亿！</p><p>橙色曲线是万得全A指数，万得全A指数成分股是所有在上海、深圳证券交易所上市的A股股票，因此<strong>万得全A指数能反应A股市场的整体情况</strong>。</p><p>从这张图中可以看到，指数的走势和成交额呈现一定正相关性。成交额上涨的时候，指数也会上涨；成交额下降的时候，指数也会下跌。</p><p>这个相关性比较好理解。成交额反应了市场的流动性。市场行情转好，赚钱效应强，投资者才愿意带着真金白银冲进来，成交额才会上升；市场行情转差，亏欠效应强，投资者或是割肉离场，或是持币观望，成交额就会随之降低。</p><p><strong>然而，成交额并不能解释一切。</strong></p><p>近期沪深两市成交额的绝对值持续维持在一个较高的水平，但是市场并没有出现明显的牛市氛围（严格来说是没有形成“全面牛”的氛围，结构化行情之下，部分行业确实可以称得上“牛市了”），周围谈论基金股票的同事相比年初少了很多。</p><p>无论是集思录的温度计，还是知有行的温度计，都清清楚楚表明当前市场仍然处于合理的状态（这两天高了一些）。</p><p>因为成交额不仅和市场情绪有关，也和背后A股整体市值有关。A股整体市值提升，自然而然会带动成交额的上涨。</p><h2 id="成交额占比指标"><a href="#成交额占比指标" class="headerlink" title="成交额占比指标"></a>成交额占比指标</h2><p>既然单纯看成交额这个指标不是很合理，那有没有一个更好的指标来反应市场的流动性（市场人气）呢？</p><p>有的，那就是<strong>成交额占总市值的比例</strong>。</p><p>我们来看一下近10年，A股总市值、成交金额以及成交金额/总市值这三个指标：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/09/11/quan-shi-chang-cheng-jiao-jin-edata.png" alt="全市场成交金额-data"></p><p>很明显能看出来，A股总市值除了2015年大牛市下暴涨外，整体上呈现稳定上升的趋势。当前A股总市值相比2016年，几乎翻了一番。所以，虽然当前的成交额达到了一个较高的水平，但是成交额占比并没有很夸张。</p><p>相似的成交额下，2015年是牛市，当前只是让人怀疑是牛市前奏。</p><p>由于没有万德全A指数的数据，这里用中证全指来代指A股整体的指数水平。下面是中证全指和成交额占比的趋势对比图。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/09/11/16308451934625.jpg" alt="-w1194"></p><p>在这张图中，成交额占比的走势和中证全指的走势也基本成正相关关系。</p><p>相比于前面的“A股成交额 VS 万得全A指数”，尤其是20年下半年到现在的这段时间，成交额占比的走势更能反应市场的情绪，高了一些，但也没有很高。</p><h2 id="如何使用这个指标？"><a href="#如何使用这个指标？" class="headerlink" title="如何使用这个指标？"></a>如何使用这个指标？</h2><p>上面啰啰嗦嗦说了一堆，还是要回到最核心的问题上：这个指标有什么意义？该如何使用它？</p><p>成交额占比反应的是流动性水平，因此如何理解成交额占比，本质还是如何理解流动性。</p><p>对于任何一项证券资产，其价格水平不仅仅反应了该资产的内在价值，还包含了流动性溢价。</p><blockquote><p>流动性溢价是指将一项投资性资产转化成现金所需要的时间和成本。在较短的时间以接近市价的价格将资产转换成现金则称该资产有较高的流动性。与之相对应，在较短时间内要将某一项资产转化成现金而必须以远低(高)于其市价的价格出售(购买)，则称该资产流动性差。</p></blockquote><p>一个合理的价格，必然对应一个合理的流动性水平。当价格不再合理的时候，机会也就来了。</p><p>根据前面的中证全指和成交额占比的趋势对比图，我们发现成交额占比在 1%~2% 这个区间，是一个比较合理的水平。低于这个水平，说明市场存在折价，是买入的机会；高于这个水平，则存在过热现象，需要警惕。</p><p>当然，在国家鼓励居民将财富转移到资本市场的背景下，可以预见，成交额占比也会呈现逐步上升的趋势。这一点仍然需要注意。</p><p><em>注：1%~2% 这个区间是一个拍脑袋的值，理解意思即可。</em></p><hr><p><strong>都看到这里了，不如点个 赞/在看，加个关注呗~~</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指标体系</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#11——一点小感慨</title>
    <link href="/2021/08/28/invest-pratice-11/"/>
    <url>/2021/08/28/invest-pratice-11/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a></p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更“美好”的事物上。</p><h2 id="本月进展"><a href="#本月进展" class="headerlink" title="本月进展"></a>本月进展</h2><p>8月进展如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/08/28/16300818817408.jpg" alt=""></p><p>当前进展 2.78%，相比上个月增加了 0.15%。</p><p>翻了下历史记录，当前累计收益和今年2月底几乎一样，也就是说这六个月的净增长基本等于净投入🤣。</p><p>本月操作：定投，跟投组合，无其他特殊操作。</p><h2 id="调整一下收入分配优先级"><a href="#调整一下收入分配优先级" class="headerlink" title="调整一下收入分配优先级"></a>调整一下收入分配优先级</h2><p>最近读到也大的文章 <a href="https://mp.weixin.qq.com/s/wQSJrQrPE2eaxa2RtoZYpA">《家里怎么管钱》</a> ，里面提到了一个很有意思的观点：</p><blockquote><p>习惯会潜移默化影响我们对生活的态度。</p></blockquote><p>我自己目前的方式是这样的：梳理出每个月的固定开支，如生活费、房贷、保险等，在工资卡设置自动转账，月底工资到账之后，自动扣款，剩余的钱用作储蓄投资及额外支出。</p><p>乍看之下，没有什么问题，因为平时讨论的比较多的也都是拿余钱进行投资。其实但这种分配方式隐含了一种优先级顺序：日常消费、固定开支 &gt; 投资储蓄。</p><p>意识到这个问题后，立即在家庭内部进行了一场<strong>友好而又深入</strong>的讨论，最终一致决定财务自由的优先级最高，所以收入分配的优先级顺序调整如下：</p><ol><li>储蓄/投资，先储蓄投资，再消费</li><li>活着，房租水电，基本生活</li><li>其它杂七杂八</li></ol><p>虽然实际分配额度变化不大，但是就像也大说的，新的分配方式会逐渐影响我们对生活态度，对追求自由的态度。</p><p>变化不就是这么一点一滴积累起来的吗？</p><h2 id="因上努力，果上随缘"><a href="#因上努力，果上随缘" class="headerlink" title="因上努力，果上随缘"></a>因上努力，果上随缘</h2><p>这两天经常看到这句话，感悟颇多。</p><p>在我看来，这8个字包含了两个过程：<strong>由果到因</strong>和<strong>由因到果</strong>。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/08/28/yin-guo.jpg" alt="因果"></p><p><strong>由果到因</strong>，在开始努力前需要先确定方向，也就是因。因怎么确定？从目标而来，也就是果。只有先完成了这个过程，才能因上努力。</p><p><strong>由因到果</strong>，因确定了之后，剩下的就是持续努力和改进，至于果能不能达成，什么时候达成，达成什么样的果，其实没那么重要。</p><p>年初的时候，定了许多目标，其中一条是：<strong>通过公众号挣1块钱</strong>，这是果。</p><p>要实现这个果，需要持续不断的在公众号进行输出，这是<strong>因上努力</strong>。</p><p>前7个月，除了持续的输出，关注在缓慢的增加外，没有任何变化。而在即将过去的8月份，目标突然达成，并超额完成。截止目前，超额221%。</p><p>目标的达成来自于读者<strong>@奇思妙想</strong>的赞赏，这也是除亲朋好友之外的首笔赞赏！</p><p>在此对读者朋友<strong>@奇思妙想</strong>表示一下感谢，<strong>我会始终记得这笔赞赏，并以此为鞭策，激励自己，不忘初心！</strong>。</p><p>除了公众号收入目标超额完成之外，还有一个意外的惊喜：文章 <a href="https://mp.weixin.qq.com/s/NjwxzAj9vDGof_btEwOiug">如何提高定投收益率（下）—— 没什么用的绝对估值</a> 忽然被微信推荐，阅读量截止目前已经 2500+，远超之前的记录。</p><p>虽然上面两个成就相比许多大佬，微不足道，但于我个人而言，却是从0到1的突破。</p><p>最后借孟岩对这句话的思考，与大家共勉：</p><blockquote><ul><li>做正确的事情，结果只是副产品</li><li>结果不由我们控制</li><li>放下执着和纠结</li><li>心无旁骛，全情交付</li></ul></blockquote><h2 id="本月回顾"><a href="#本月回顾" class="headerlink" title="本月回顾"></a>本月回顾</h2><p>在 <a href="https://mp.weixin.qq.com/s/XWfjJ9WJ8DpxoVpaW1tacg">财务自由实证#7——实证升级了</a> 中，我对该实证计划进行了升级：日后该实证计划将会逐渐变成个<strong>人成长实证</strong>，除了例行的<strong>实证进展</strong>模块外，还会有<strong>本月回顾</strong>模块以及<strong>下月计划</strong>模块。</p><p>以下是8月回顾。</p><p><strong>写作</strong></p><ol><li>投资理财方向，加上这一篇，一共是4篇，完成度 <strong>100%</strong>。</li><li>专业技术方向，还是 0 篇，完成度 <strong>0%</strong>。</li></ol><p><strong>个人项目</strong></p><ol><li>投资工具箱（姑且这么叫吧），完成了市场行情（温度计、指数估值）展示和定投计算器的 Demo 的开发。</li></ol><p>另外，8月份新增加了不少读者，更新的斗志又高昂了许多，有预感下个月产出会多 n 篇😂</p><h2 id="下月计划"><a href="#下月计划" class="headerlink" title="下月计划"></a>下月计划</h2><p><strong>写作</strong></p><ol><li>投资理财方向，至少输出4篇文章</li><li>专业技术方向，输出一篇（先把目标降下来）</li><li>素材积累上，坚持 flomo 每日记录。</li></ol><p><strong>个人项目</strong></p><ol><li>投资工具箱:<ol><li>完善定投计算器，支持计算目标收益率、投资年限等指标</li><li>完成小程序 v0.0.1 版本的发布</li><li>梳理后续的规划</li></ol></li></ol><p>【本月回顾】和【下月计划】这两个模块实践了这几个月之后，发现问题还是不少，计划和实际工作内容之间经常存在重大偏差。</p><p>原因在于执行计划的时候，总是先做当下最感兴趣的事情，而不是去做最应该做的事情。长此以往下去，偏差必然会越来越大，需要警惕。</p><p>希望下个月能有一些改善~~</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最近大火的“雪球”是什么</title>
    <link href="/2021/08/19/snowball-1/"/>
    <url>/2021/08/19/snowball-1/</url>
    
    <content type="html"><![CDATA[<h1 id="最近大火的“雪球”是什么"><a href="#最近大火的“雪球”是什么" class="headerlink" title="最近大火的“雪球”是什么"></a>最近大火的“雪球”是什么</h1><p>最近看到多篇关于“雪球”的新闻：</p><p>8月6号，中国基金报发表了一篇文章：《一分钟售罄！“雪球”产品太火爆，监管部门重磅出手了！》<br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/08/19/16291118183718.jpg" alt="-w828"></p><p>8月11日，监管层要求券商自查“雪球型自动敲入敲出式券商收益凭证”。</p><p>12日再获消息，证监会已向多家券商发文，要求强化对“雪球”的风险管控。发文主要强调提示风险与合规，虽未要求券商“彻底停掉”，但部分券商已经主动减少甚或暂停新产品发行。</p><p>出师未捷身先死，长使英雄泪满襟！</p><p>等等，这个雪球到底是个什么东西？监管部门不让玩雪了吗？</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/08/19/16291229536432.jpg" alt=""></p><h2 id="此雪球非彼雪球"><a href="#此雪球非彼雪球" class="headerlink" title="此雪球非彼雪球"></a>此雪球非彼雪球</h2><p>首先，这个“雪球”不是自然界的雪球。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/08/19/xueqiu.gif" alt="xueqiu"></p><p>其次，这个“雪球”也和雪球（投资者社区）、雪球APP无关。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/08/19/16291233815285.jpg" alt="-w691"></p><p>那这个“雪球”是什么东西呢？</p><h2 id="“雪球”产品简介"><a href="#“雪球”产品简介" class="headerlink" title="“雪球”产品简介"></a>“雪球”产品简介</h2><p>“雪球”产品本质上是一种<strong>结构化产品</strong>，其对应的雪球型结构属于<strong>收益增强型结构</strong>，是一种<strong>收益凭证</strong>。</p><p>这种产品可以应对一定幅度的市场下跌，同时具有类固收产品的特点，只要挂钩标的资产价格不发生大跌，持有期限越长，绝对收益就越高。而这个过程就像滚雪球一样，只要路面不出现大的坑洼，雪球就会越滚越大，由此而得名“雪球”。</p><p>概念有点多，慢慢解释。</p><h3 id="什么结构化产品"><a href="#什么结构化产品" class="headerlink" title="什么结构化产品"></a>什么结构化产品</h3><p>结构化产品是指<strong>表现与基础资产、产品或指数挂钩的金融工具</strong>。许多研究或描述中大多简单定义结构化产品为<strong>“资产”和“期权”</strong>的结合。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/08/19/16291345865266.jpg" alt="-w749"></p><p>这是结构化产品的示意图。</p><p>虽然结构化投资产品可以以票据、结构化存款等形式存在，但应当以衍生品的特征来看待，而非固定收益类资产。结构化产品挂钩的资产往往是风险资产，结构化产品也同样会承担市场变化带来的收益风险。尽管结构化产品的风险结构与资产的线性风险会有所差别。</p><p>由于结构化产品多种多样，所以这里不做介绍，接下来主要介绍“雪球”结构。</p><h3 id="雪球型结构关键要素"><a href="#雪球型结构关键要素" class="headerlink" title="雪球型结构关键要素"></a>雪球型结构关键要素</h3><p>理解雪球型结构产品之前，有必要先了解几个专有名词。</p><p>找一家发行过雪球产品的券商，搜索雪球，点击任意一个产品，查看合约，都会有如下要素：</p><p><strong>1、挂钩标的</strong></p><p>前面讲过，结构化产品都是<strong>表现与基础资产、产品或指数挂钩的金融工具</strong>，雪球产品挂钩的是指数。</p><p>国内绝大部分的雪球产品挂钩的都是中证500指数。</p><p><strong>2、存续期限</strong></p><p>购买雪球产品的时候，认购协议会约定该产品的到期时间。投资者持有该产品期间，如果没有发生协议所规定的几种提前终止情况，则投资者需一直持有，直至到期。</p><p><strong>3、敲入、敲出界限和观察频率</strong></p><p>先解释下什么是敲入和敲出。</p><p>假设起初指数加个为1，协议约定波动区间为 75% ~ 103%，那么 75% 就是敲入界限，103% 就是敲出界限。持有该产品期间，如果指数价格相比于期初下跌25%，则发生敲入现象；如果指数价格相比于期初上涨3%，则发生敲出现象。</p><p>所谓的观察频率是指只在特定的日期观察是否发生敲入敲出现象。其它日期即使指数价格波动到约定的区间之外，也不作数。</p><p>通常敲入的观察频率是每个交易日；敲出的观察日是每月的某一天（非交易日顺延）。比如我看到的一款产品，它的敲出观察日就是：</p><p>2021年10月11日<br>2021年11月09日<br>2021年12月09日<br>2022年01月10日<br>……<br>2023年07月10日</p><p><em>虽然敲出水平很容易达到，但是不在观察日，并不算数，这大大提高了观察到敲出的难度。</em></p><p><strong>4、敲出票息（票面利率）</strong></p><p>购买雪球类产品，有一个票面利率。购买协议会约定在哪几种场景下（下文会讲）投资者会获得利息。</p><p><em>如果想更具体的了解这些词汇，可以找一个雪球产品，打开它的认购协议，阅读一遍即可彻底了解。</em></p><h3 id="雪球型结构示意图及收益计算方式"><a href="#雪球型结构示意图及收益计算方式" class="headerlink" title="雪球型结构示意图及收益计算方式"></a>雪球型结构示意图及收益计算方式</h3><p>购买雪球产品后，投资者会遇到如下的几种场景：</p><p><strong>第一种：观察期间发生敲出现象</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/08/19/xue-qiuqiao-chu.jpg" alt="雪球-敲出"></p><p>这种情况下，只要观察到敲出现象，产品提前终止，投资者获得利息（按22%利率折算到具体的持有期限上）。</p><p><strong>第二种：观察期间未发生敲入，也未发生敲出现象</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/08/19/xue-qiuwu-qiao-ru-wu-qiao-chu.jpg" alt="雪球-无敲入无敲出"></p><p>如果在持有雪球产品期间，未观察到敲入现象，也未观察到敲出现象，投资者仍能获得利息（按22%利率折算到具体的持有期限上）。</p><p><strong>第三种：观察期间，发生敲入，未发生敲出，期末指数略高于期初</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/08/19/xue-qiuqiao-ru-wu-qiao-chu-qi-mo-hui-fu.png" alt="雪球-敲入无敲出期末恢复"></p><p>如果在持有雪球产品期间，观察到敲入现象，但是未观察到敲出现象，投资者仅能获得本金，无利息。</p><p><strong>第四种：观察期间发生敲入，未发生敲出现象，且期末指数水平低于期初</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/08/19/xue-qiuqiao-ru-wu-qiao-chu-qi-mo-mei-you-hui-fu.png" alt="雪球-敲入无敲出期末没有恢复"></p><p>如果在持有雪球产品期间，观察到敲入现象，但是未观察到敲出现象，且直到期末，挂钩指数也没有恢复到期初水平，则投资者承担实际亏损，亏损比例为指数实际下降幅度。</p><h3 id="什么情况下适合购买雪球产品"><a href="#什么情况下适合购买雪球产品" class="headerlink" title="什么情况下适合购买雪球产品"></a>什么情况下适合购买雪球产品</h3><p>对比上面讨论的几种情况，我们发现，只要不发生敲入现象，投资者的本金就一定能保证。所以可以把雪球产品当成一种有一定下跌安全边际的产品，如果判断未来一段时间内挂钩指数的最大下跌空间有限，就可以买入雪球产品，提前锁定收益。</p><p>但是如果投资者判断未来一段时间内，挂钩指数不仅下跌空间有限，而且极有可能迅速上涨，这种情况下购买雪球产品虽然能锁定一部分收益，但是相比市场，错过的收益会更多（等到敲出观察日的时候，指数可能已经上涨了很多了）。</p><p>总而言之，是否购买雪球产品，都需要投资者能对指数未来一段时间内的走势有一个初步的预估，否则最终收益和预期会偏差很大。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>以上是看到“雪球”产品后出于好奇查阅相关资料汇总整理而得。啰啰嗦嗦了一大堆，到这里，相信大家对雪球产品的收益模式有了一个基本的认识。</p><p>从投资者角度，了解了雪球产品的收益模式之后，就可以根据自身风险偏好以及当下市场行情决定是否购买。</p><p>但是从券商的角度，你知道它们是如何盈利从而保证利息支付的吗？</p><p>我也不知道，希望下一篇能给出答案[旺柴]</p><h2 id="说点其它的"><a href="#说点其它的" class="headerlink" title="说点其它的"></a>说点其它的</h2><p>最近在开发和验证一些简单但有效的投资策略，以期构建属于自己的投资组合，在实践中加快自己投资体系的建立。</p><p>由于深知“闭门造车”的弊端，所以借这篇文章推广一下：</p><p>如果你对投资理财感兴趣，想找一些志同道合的人，公众号回复【搞事情】or 【联系方式】，欢迎进群一起交流！</p><hr><p><strong>都看到这里了，不如点个 赞/在看，加个关注呗~~</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>雪球结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何提高定投收益率（下）—— 没什么用的绝对估值</title>
    <link href="/2021/08/10/fix-investment-3/"/>
    <url>/2021/08/10/fix-investment-3/</url>
    
    <content type="html"><![CDATA[<p>犹豫了半天，一直纠结要不要把这篇文章发出来。</p><p>因为写到最后发现，本篇分析出来的结论对<strong>提高定投收益率</strong>并没有什么帮助，这个系列完全可以在 <a href="https://mp.weixin.qq.com/s/tx3pPqYA7RMhn8wFAaCaTg">如何提高定投收益率（中）—— 指数组合的威力</a> 的最后直接收尾。</p><p>不过想到，即使是无用的结论，也可以让其他人少走一些弯路，所以最终还是决定把这篇文章发了出来。</p><hr><p>在前面的文章 <a href="https://mp.weixin.qq.com/s/9_YBNH_8V5DTbgfMQuXitA">如何提高定投收益率（上）</a> 中，讨论了如何利用指数估值进行“低买高卖”提高定投的收益。</p><p>这种做法的缺点是，当指数估值不上不下的时候，持有现金过多，拉低了整体的收益率，增强效果并不显著。</p><p>因此为了提高现金利用率，在文章 <a href="https://mp.weixin.qq.com/s/tx3pPqYA7RMhn8wFAaCaTg">如何提高定投收益率（中）—— 指数组合的威力</a> 中讨论了对指数组合利用指数估值进行“低买高卖”的效果。回测发现，资金利用率提高之后，整体收益有了明显的提升。</p><p>以上两篇文章表明，利用指数估值，对定投效果确实是有一定的增益效果的。</p><h2 id="相对估值的问题"><a href="#相对估值的问题" class="headerlink" title="相对估值的问题"></a>相对估值的问题</h2><p>但是，前面使用的估值方式——<strong>PE百分位</strong> 并不完美。</p><p>PE百分位这种估值方法其实是<strong>相对估值法</strong>。相对估值法的意思是说拿现在数据和历史数据对比，通过当前数据在历史中的水平来评估低估还是高估。</p><p>但是并不能反应当前指数真实的、确切的水平。原因如下：</p><p><strong>1、相对估值需要大量的历史数据</strong></p><p>现在很多新编的指数历史还很短，一两次异常波动就会让估值失真。</p><p><strong>2、指数的成份一直在动态变化</strong></p><p>例如，沪深300的历史数据比较长，PE的百分位确实很有意义，但是必须认识到，五年前的沪深300的成份股和权重，和现在的沪深300的成份股和权重已经发生了非常大的变化。最主要的变化就是金融行业权重的持续下降，消费和医药行业的权重持续提升。</p><p>医药行业的PE远高于金融行业，所以沪深300的平均PE水平也在逐步提升。如果仅仅机械的通过当前PE在历史PE数据中的分位值来判断估值高低，就会陷入一直高估一直涨，迟迟无法买入的问题。</p><h2 id="绝对估值法"><a href="#绝对估值法" class="headerlink" title="绝对估值法"></a>绝对估值法</h2><p>既然有相对估值法，肯定就有<strong>绝对估值法</strong>。</p><p>绝对估值法的意思是只看指标绝对值的大小。比如之前的调侃“上证指数十年未涨”看的就是指数的绝对值，当然你也可以看PE的绝对值等。</p><p>本篇尝试用<strong>目标收益率法</strong>来进行绝对估值。这个思路来源于<strong>均值回归理论</strong>，意思是说一类资产的价格短期情绪如何变化，长期总会趋于合理。</p><p>毕竟投资最终追求的还是绝对的收益率！</p><p>如果我们能对某一类资产估计出一个合理的收益率区间，那么很容易就能推断出当前是高估还是低估。</p><p>根据博格公式，长期投资的年化收益率由以下三个因素决定：</p><ul><li>初始股息率</li><li>盈利增长率</li><li>市盈率变化率</li></ul><p>这里面，初始股息率已知，盈利增长率可以通过指数值/PE估算出盈利从而进一步计算得出，市盈率的变化率也能很容易的计算出来。</p><p>假设我们认定，沪深300的年收益率有15%，如果当前年收益率低于15%，就可以认为指数当前是低估的；如果当前年收益率高于15%，可以认为指数高估。</p><h3 id="基于目标收益率的估值定投"><a href="#基于目标收益率的估值定投" class="headerlink" title="基于目标收益率的估值定投"></a>基于目标收益率的估值定投</h3><h4 id="如何估计沪深300的预期收益率？"><a href="#如何估计沪深300的预期收益率？" class="headerlink" title="如何估计沪深300的预期收益率？"></a>如何估计沪深300的预期收益率？</h4><p>有知有行《投资第一课》中有一篇文章《股票的预期收益率应该是多少？》（地址：<a href="https://youzhiyouxing.cn/n/materials/185）进行过一个自上而下的推导，大意如下：">https://youzhiyouxing.cn/n/materials/185）进行过一个自上而下的推导，大意如下：</a></p><p><strong>GDP增速 &lt; 全体上市公司增速 &lt; 优质上市公司增速</strong></p><p>再叠加<strong>溢价再融资</strong>等渠道，优质上市公司能实现的年收益率大致12%~15%左右。</p><p>沪深300就是优质上市公司的一个集合，故可以预期其长期平均增长率12%~15%。</p><h4 id="回测比较"><a href="#回测比较" class="headerlink" title="回测比较"></a>回测比较</h4><p>类似<strong>估值定投V1版</strong>，回测之前设定如下策略：</p><ul><li>估值指标选用理论年化收益率区间 12% ~ 17%</li><li>按月定投，投入到现金账户</li><li>如果博格公式计算出来的平均年化收益率低于 12%，认为低估，投入现金账户全部金额；如果计算出来的平均年化收益率高于 17%，认为高估，全部卖出至现金账户</li></ul><p>基于沪深300 2005年4月8日至今的数据，对比普通定投、相对估值定投、绝对估值定投结果如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/08/10/16284411620691.jpg" alt=""></p><p>回测结果显示，定投时间较短的时候，反而是普通定投的收益率更高；定投时间足较长时，利用估值定投的收益率才会高于普通定投，其中绝对估值下的收益率又更高些。</p><p>是不是就能说利用绝对估值定投，效果就最好呢？到这里，相信一些读者心中一直疑问：</p><p><em>为什么前面对沪深300的预期收益率是 12%~15%，而在策略中目标收益率的区间却是 12%~17% 呢？</em></p><p>12%~17% 其实是一个多次尝试得出的最优收益率区间，其它区间下，定投的收益并没有那么显著。</p><p>如果把区间上限设置成 15%，年化收益率变成 10.46%，如果设置成 18%，更是掉到了 8.12%。</p><p>所以绝对估值虽然能创造更高的收益，但是它对参数更敏感，考虑到我们对沪深300的收益率区间的估计比较粗糙，因此该方法的参考价值并不大。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>至此，《如何提高定投收益率？》系列就告一段落了。</p><p>其实该系列文章中的所有结论在其它地方都有人分析过，但是自己亲手算一遍，感受还是会更加深刻一些。</p><p>总结一下这个系列的结论：</p><ol><li>周定投和月定投几乎没有区别</li><li>目标收益率定投（绝对估值）确实能带来更高的收益，但是它对参数十分敏感，实际作用有限</li><li><strong>指数组合+估值定投能更显著的提高收益率</strong></li></ol><p>这里再着重说下第三点。</p><p>估值定投的目的是为了实现“低买高卖”。一个相对低估的位置买入，相对高估的位置卖出，赚钱的概率一定大于随机买入永不卖出。因此，不考虑资金闲置问题（<a href="https://mp.weixin.qq.com/s/9_YBNH_8V5DTbgfMQuXitA">如何提高定投收益率（上）</a> 有过讨论），估值定投一定是优于普通定投的。</p><p>估值定投告诉了我们低估的时候干什么，高估的时候干什么，却没有告诉我们“不高不低”的时候该干什么。</p><p>所以还需要利用组合，尽可能的提高资金利用率，避免踏空，才能实现真正意义上的“低买高卖”。</p><h2 id="说点其它的"><a href="#说点其它的" class="headerlink" title="说点其它的"></a>说点其它的</h2><p>最近在开发和验证一些简单但有效的投资策略，以期构建属于自己的投资组合，在实践中加快自己投资体系的建立。</p><p>由于深知“闭门造车”的弊端，所以借这篇文章推广一下：</p><p>如果你对投资理财感兴趣，想找一些志同道合的人，公众号回复【搞事情】or 【联系方式】，欢迎进群一起交流！</p><hr><p><strong>都看到这里了，不如点个 赞/在看，加个关注呗~~</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>定投</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#10——Are You OK?</title>
    <link href="/2021/08/01/invest-pratice-10/"/>
    <url>/2021/08/01/invest-pratice-10/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a></p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更“美好”的事物上。</p><h2 id="本月进展"><a href="#本月进展" class="headerlink" title="本月进展"></a>本月进展</h2><p>7月进展如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/08/01/16277165233985.jpg" alt=""></p><p>当前进展 2.63%，相比上个月增加了 0.0%。认真来说，还是增加了200的🥲。年化收益率创记账以来的新低！</p><p>忽然想到了上一篇文章中举的例子：</p><blockquote><p>“有一个小伙伴，一直在往账户中打钱，账户的净值也一直在稳步增长。所以这个小伙伴平时都在讲发现了什么策略，如何赚钱。</p><p>之后点了一下账户分析，发现账户的累计收益率是-60%，瞬间不淡定了。。。”</p></blockquote><p>惨淡的行情下，全靠始终如一的投入，才勉强维持着账户净值不坠[狗头]</p><p>本月特殊操作：无。</p><h2 id="Are-You-OK"><a href="#Are-You-OK" class="headerlink" title="Are You OK?"></a>Are You OK?</h2><p>7月结束后，很想问大家一句：</p><p><strong>Are You OK?</strong></p><p>这个七月，东京奥运会女子双人3米板比赛，<strong>施廷懋/王涵</strong> 以326.4分的总成绩轻松摘取金牌。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/08/01/16277181419880.jpg" alt=""></p><p>如针入水，惊艳全场！</p><p>这个七月，A股港股，也上演了类似的一幕：沪深300最大下跌9.6%，恒生指数最大下跌14.2%。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/08/01/16277258739296.jpg" alt=""></p><p>飞流直下，一泻千里！</p><p>一边是为奥运健儿获得金牌的激动之情，一边是日亏XX的下跌之苦。</p><p>这个七月，五味杂陈！</p><h2 id="要不要抄底？"><a href="#要不要抄底？" class="headerlink" title="要不要抄底？"></a>要不要抄底？</h2><p>跌这么狠，抄底的想法就不由自主的冒了出来。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/08/01/16277879338436.jpg" alt=""></p><p>很多同事都在讨论要不要抄底，行动快的已经抄底好几波。我也参与过讨论，观点是可以适当小额补仓，但是还没有到动用备用金进行抄底的时候。</p><p>E大的微博精准的表达了类似的意思：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/08/01/16277308600765.jpg" alt=""></p><p>在讨论这个过程中，我发现之前并没有关注过<strong>如何加仓</strong>的问题。</p><p>当前阶段，计划中的大部分是跟投比较信任的一些组合。市场发生变化的时候，这些组合都会发出加仓或者调仓的信号，我都是无脑跟投。</p><p>剩下的少部分是定投指数。这部分很少会主动加仓，即使主动，也是那种拍脑袋式的调整。</p><p>比如20年疫情3-5月份行情低迷的时候，隔一天两天，就会手动加一笔，几个月下来，总量很是可观，最终效果也很不错；但是下半年行情上升的过程中，被持续上涨的行情撩拨，也加了几笔大的。</p><p>如果把这两拨行为连起来，后面再加一个卖出的操作，就是标准的<strong>韭菜</strong>行为：</p><blockquote><p>小额抄底，上涨过程中加大投入，下跌的时候卖出。</p></blockquote><p>所以趁这次机会，正好进行一次反思，从而完善自己的投资体系。</p><h3 id="如何加仓？"><a href="#如何加仓？" class="headerlink" title="如何加仓？"></a>如何加仓？</h3><p>显然，在加仓之前，需要解决三个核心问题：</p><ol><li><strong>要不要加仓？</strong></li><li><strong>加仓哪个品种？</strong></li><li><strong>加多少？</strong></li></ol><p>问题1属于 <em>原则问题</em> ，问题2和问题3属于 <em>实操问题</em> 。</p><p>如何解决这三个问题，且慢昨天昨天公众号的文章：<a href="https://mp.weixin.qq.com/s/Br3b7o-FbZIglZzsDVApMQ">投资实盘#37 大跌后，怎么加仓？</a> 提供了一些思路。</p><p><strong>原则层面</strong>，这篇文章建议：从 <em>资产配置</em> 的视角来看待加仓。</p><p>比如你计划权益类资产在总资产中的占比为40%~60%。当市场小幅波动，权益资产占比50%附近的时候，不考虑加仓；当市场下跌，权益类资产的占比下降到45%甚至40%以下的时候，就可以考虑加仓了。</p><p><strong>操作层面</strong>，加哪个品种，加多少，这篇文章建议是： <em>预估最大跌幅，考虑时间和空间</em> 。</p><p>如果判断当前品种可能最大跌幅（相比近 n 年的最低点）不到30%（亦可根据个人偏好调整），可以考虑加仓。</p><p>这个时候建议将能加仓的现金n等分，每跌一定的比例，就加仓一份。</p><p>毕竟家里没矿，所以一定要控制加仓频率，切忌一把梭哈。</p><p>需要说明的是，这里最大跌幅的预估不能仅仅用点位来计算，因为随着盈利的增长，市盈率保持不变的情况下，点位也水涨船高。就指数而言，可以用市盈率（部分行业用市净率）来计算。</p><p>对与权益类资产仓位并不高的小伙伴而言，上面思路的参考意义比较大。</p><p>但是对于仓位比较高的小伙伴，除非那种特别有吸引力的价格，普通的下跌是没必要加仓的。</p><p>比如你的权益类资产占比80%，现金类资产占比20%，即使拿出一半的现金加仓权益类资产，对整体收益的影响其实不大，但是在面对未来的机会的时候，你的选择权却会减少50%。</p><h2 id="6月、7月回顾"><a href="#6月、7月回顾" class="headerlink" title="6月、7月回顾"></a>6月、7月回顾</h2><p>在 <a href="https://mp.weixin.qq.com/s/XWfjJ9WJ8DpxoVpaW1tacg">财务自由实证#7——实证升级了</a> 中，我对该实证计划进行了升级：日后该实证计划将会逐渐变成个<strong>人成长实证</strong>，除了例行的<strong>实证进展</strong>模块外，还会有<strong>本月回顾</strong>模块以及<strong>下月计划</strong>模块。</p><p>下面就来检验一下6月、7月计划的进展情况~~</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/08/01/8f415916899d6347d8491f28f774f8d0.jpg" alt=""></p><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p><strong>1.</strong> 《Go 并发编程实战》文章计划4篇，实际完成0篇，完成度 <em>0%</em>。<br><strong>2.</strong> 指数研究相关文章输出4篇，完成度 <em>75%</em></p><p>完成度一般，偏差较大，羞愧中~</p><h3 id="个人项目"><a href="#个人项目" class="headerlink" title="个人项目"></a>个人项目</h3><p><strong>1.</strong> 完成一个最简单的基金问答的机器人，并利用公众号实现基本的交互，进展 <strong>0%</strong></p><p>最近对小程序感兴趣，so这个一直在搁置状态，套用一句开发中的说辞就是：这个项目优先级不高，没排上。。。</p><p>争取下个月排上！</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何计算收益率？</title>
    <link href="/2021/07/25/how-to-compute-irr/"/>
    <url>/2021/07/25/how-to-compute-irr/</url>
    
    <content type="html"><![CDATA[<p>又到周六了，这次写个轻松一点的话题：<strong>如何计算收益率?</strong></p><p>也大之前在文章中举过一个真实的例子。身边有一个小伙伴，一直在往账户中打钱，账户的净值也一直在稳步增长。所以这个小伙伴平时都在讲发现了什么策略，如何赚钱。</p><p>后来也大手贱，帮他点了一下账户分析，发现账户的累计收益率是-60%，小伙伴瞬间不淡定了。。。</p><p>好在小伙伴通过大力投入指数基金，终于将账户的累计收益率掰成了正数。</p><p>此事一时之间成为圈友们茶余饭后的笑谈。</p><h2 id="为什么要计算收益率"><a href="#为什么要计算收益率" class="headerlink" title="为什么要计算收益率"></a>为什么要计算收益率</h2><p>上面的这个例子充分说明了在投资的路上，关注收益率的重要性。</p><p><strong>如果说不同的投资策略代表着不同的前进方向，那收益率就是修正方向的依据！</strong></p><p>现在大部分的投资APP都有账户分析功能，都能提供累计收益、收益率、盈亏分析以及和沪深300指数对比的功能，使用起来十分便利。</p><p>但是很多人的资金都被分散各个APP的账户中，无法通过某一个APP直观的分析收益率情况。</p><p>因此，自己计算收益率就变成了一个无法避免的问题。</p><h2 id="收益率怎么计算？"><a href="#收益率怎么计算？" class="headerlink" title="收益率怎么计算？"></a>收益率怎么计算？</h2><p>那么收益率如何计算呢？</p><p>根据平时的经验，大家最关心的收益率有两个：累计收益率和年化收益率。下面分别介绍下如何计算这两个收益率。</p><h3 id="累计收益率"><a href="#累计收益率" class="headerlink" title="累计收益率"></a>累计收益率</h3><p>累计收益率反应的是从开始投资至今的整体收益情况，计算公式十分简单：</p><blockquote><p>累计收益率 = 总收益 / 总投入 = （总资产 - 总投入） / 总投入</p></blockquote><p>多账户下，只需要把各个账户的资产累加得到总资产，然后根据投资记录计算出总投入，就能很容易的计算出累计收益率了。</p><h3 id="年化收益率"><a href="#年化收益率" class="headerlink" title="年化收益率"></a>年化收益率</h3><p>相比于累计收益率，大部分人更关注的是如何计算年化收益率。</p><p>年化收益率反应的是资产一年的盈利水平，是复利，第一年产生的盈利会被计入到第二年的本金中，所以年化收益率不等于年利率！</p><p>比如年初小明在银行存款10000元，年利率是3%，那他第一年末和第二年末的账户净值分别是 100300 和 100600。第一年的 300 并不会在第二年产生利息。所以有时候你会听到周围某某把钱从银行取出来再存进去的例子，就是为了把年利率变年化收益率。</p><p>年化收益率的概念比较好理解，但是如何根据现金流计算出理论上的收益率值，却不是那么容易。</p><p><strong>最简单的场景</strong>: </p><p><em>小明有一笔10000的投资，第一年末净值变成11000，第二年末变成12100，依次类推，年化收益率是多少？</em></p><p>这种已知初期投入以及期末净值计算年化收益率的场景比较简单，直接能看出年化收益率是10%。</p><p><strong>复杂一点的场景</strong></p><p><em>小明每月初投入1000，年末净值变成12670.28，问年化收益率是多少？</em></p><p>答案还是10%。这个计算稍微复杂一点，但是即使不知道 IRR 公式，只要具备了高一等比数列相关的知识，还是能很容易的推导出公式（先计算月化利率，再转成年化利率），得出结果的。</p><p><strong>最复杂的场景</strong></p><p>小明不定期不定额的投入，比如这个月1号投入500，6号投入700，30号投入100等等，最终账户123456元，问年化收益率多少？</p><p>看上去挺难算，其实把年化收益率转成日化收益率，对每一笔投入计算期末净值，最后累加，就是账户终值，再用逼近法可以计算年化收益率的近似值。</p><p>原理归原理，你就告诉我有没有工具能快速计算出来就行？（会不会有读者心里这么想🤔）</p><h2 id="计算年化收益率的几种方法"><a href="#计算年化收益率的几种方法" class="headerlink" title="计算年化收益率的几种方法"></a>计算年化收益率的几种方法</h2><h3 id="第三方记账软件"><a href="#第三方记账软件" class="headerlink" title="第三方记账软件"></a>第三方记账软件</h3><p>我又要推荐一次<strong>有知有行APP</strong>了，没错，我的<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg5NjU0MzU1Mg==&amp;action=getalbum&amp;album_id=1660571680026492929&amp;scene=173&amp;from_msgid=2247484140&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect">实证系列文章</a> 中的实证进展截图就是用的这个软件。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/25/imgee9a593183311.jpeg" alt="IMG_EE9A59318331-1"></p><p>如图所示，只需要傻瓜式的记录转入转出，然后期末更新一下总资产，APP会自动计算出年化收益率，并会对比沪深300以及中证500的走势，简洁明了。</p><p>强烈推荐~~</p><h3 id="Excel的XIRR函数"><a href="#Excel的XIRR函数" class="headerlink" title="Excel的XIRR函数"></a>Excel的XIRR函数</h3><p>Excel 的功能十分强大，我们平时用的功能只占很小的一部分，它内置的 XIRR 函数就可以用来计算不定期不定额投资的收益率。</p><p>示例如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/25/16271154863404.jpg" alt="-w376"></p><p><strong>年化收益率 = XIRR(现金流, 投资日期)</strong></p><p>需要注意的是，投入在现金流中用负数表示，卖出用正数表示，期末净值用正数表示。</p><h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3><p>如果有读者熟悉一点编程知识，也可以根据下面的公式自行计算：</p><script type="math/tex; mode=display">\begin{gather*}\large  0 = \sum_{i=1}^{n}\frac{C_i}{(1+r)^{\frac{d_i-d_1}{365}}}\end{gather*}</script><p>其中 $C_i$ 是现金流，$r$ 是年化收益率，$d_i$ 是产生现金流的日期。</p><p>这个公式对应的函数是单调函数，可以通过逼近法求解 $r$，具体的实现可参考：<a href="https://github.com/AFreeCoder/quant-toolbox/blob/main/util/rr.py">https://github.com/AFreeCoder/quant-toolbox/blob/main/util/rr.py</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>啰啰嗦嗦说了这么多，归根结底我们需要的只是一个准确的年化收益率，用什么工具、怎么算的其实并不重要！</p><p>所以真正要做的只有一件事情：记账[旺柴]</p><hr><p><strong>都看到这里了, 不如顺手加个关注？</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何提高定投收益率（中）—— 指数组合的威力</title>
    <link href="/2021/07/18/fix-investment-2/"/>
    <url>/2021/07/18/fix-investment-2/</url>
    
    <content type="html"><![CDATA[<h1 id="如何提高定投收益率（中）"><a href="#如何提高定投收益率（中）" class="headerlink" title="如何提高定投收益率（中）"></a>如何提高定投收益率（中）</h1><p><em>原本这一篇应该是《如何提高定投收益率（下）》，但是忽然发现两篇可能写不完，先用“中”顶一下。</em></p><p>上一篇<a href="https://mp.weixin.qq.com/s/9_YBNH_8V5DTbgfMQuXitA">《如何提高定投收益率（上）》</a>对比了<strong>普通定投</strong>和<strong>估值定投V1版</strong>的优劣。</p><div class="table-container"><table><thead><tr><th>定投策略</th><th>定投时间</th><th>年化收益率</th><th>总收益率</th></tr></thead><tbody><tr><td>普通定投</td><td>2005.4.1-2021.6.19</td><td><strong>102.43%</strong></td><td><strong>8.03%</strong></td></tr><tr><td>估值定投V1版</td><td>2005.4.1-2021.6.19</td><td><strong>102.43%</strong></td><td><strong>8.03%</strong></td></tr></tbody></table></div><p><em>注：估值定投V1版策略的详细内容见<a href="https://mp.weixin.qq.com/s/9_YBNH_8V5DTbgfMQuXitA">《如何提高定投收益率（上）》</a></em></p><p>普通定投的优势是无视市场行情，操作极其简单，不需要投入任何精力；缺点是收益率稍微低一些。</p><p>估值定投V1版的优势能根据指数估值进行简单的“低买高卖”，收益率相比普通定投要高一些；缺点是指数估值水平较高时，现金持有比重较高，资金利用率低。</p><p>针对估值定投V1版策略的缺点，自然而然的，我们会猜想：如果同时购买多只指数，提高资金利用率，收益率是否会更高呢？</p><h2 id="估值定投V2版"><a href="#估值定投V2版" class="headerlink" title="估值定投V2版"></a>估值定投V2版</h2><p>有了上面的猜想，在估值定投V1版策略的基础上，衍生出如下的<strong>估值定投V2版</strong>策略：</p><ul><li>采用市盈率PE百分位计算估值，百分位计算采用近10年数据，不满10年采用全部历史数据。</li><li>任何一只指数，PE 百分位小于 0.3 为低估，PE 百分位大于 0.7 为高估。</li><li>按月定投，投入到现金账户。</li><li>定投当日，筛选出低估的指数，将现金账户余额等分并投入低估指数；筛选出高估的指数，全部卖出到现金账户。</li></ul><p>由于数据源限制，手上只有沪深300、中证500、创业板指的PE数据，所以接下来就用这三只指数做一个组合，对估值定投V2版策略做一个回测。</p><p>这三只指数的发布日期不一样，创业板指发布的最晚，因此取公共时间段2010.6.1-至今，分别回测定投1年、3年、5年、以及至今的收益率。</p><p>回测结果如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/18/16263639832957.jpg" alt=""></p><p>其中单只指数采用的是<strong>估值定投V1版</strong>策略，指数组合采用的是<strong>估值定投V2版</strong>策略。</p><p>从图中能看出，除了定投3年时，指数组合的年化收益率低于创业板指，其余时间跨度，指数组合的收益率都是大于等于单只指数的收益率的。</p><p>总收益率的表现也同样如此：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/18/16263640265930.jpg" alt=""></p><p>这个回测结果验证了本文开头的猜想：对指数组合进行采用估值定投V2版策略，是能提高收益率的。</p><h2 id="如何配置指数组合？"><a href="#如何配置指数组合？" class="headerlink" title="如何配置指数组合？"></a>如何配置指数组合？</h2><p>这其实是个开放性问题~~</p><p>虽然估值定投V2版能进一步提高收益率，但是因为数据源所限，回测采用的指数组合是【沪深300+中证500+创业板指】。</p><p>那么问题来了，这个组合是完美的组合吗？或者这么问：</p><blockquote><p>定投什么样的指数组合收益率最大？</p></blockquote><p>​理想组合应该是这样的：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/18/16263617214217.jpg" alt=""></p><p>指数组合中各指数的走势不相关，甚至负相关。比如指数A高估的时候，指数B低估；指数B高估的时候，指数A低估。这样就能最大限度的利用资金实现完美的实现“低买高卖”😝。</p><p>然而，理想有多丰满，现实就有多骨感~~</p><p>我们把沪深300、中证500、创业板指的走势画出来，对比一下（为了方便讨论，加入了中证红利）：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/18/16262835996868.jpg" alt=""></p><p>一眼看去，这四只指数的走势竟然基本一致！让人大跌眼镜！</p><p>为了更加精确的描述，计算一下这四只指数的相关系数，结果如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/18/16262833665001.jpg" alt=""></p><p>这四个指数两两之间不仅正相关，而且相关系数很高。</p><p>相关系数高意味着<strong>要涨一起涨，要跌一起跌</strong>。显然组合【沪深300+中证500+创业板指】并不是一个好的组合，尽管该组合的收益率比单只指数要高。</p><p>一个好的组合内部各指数应该是不相关或者负相关的。比如不同行业指数的组合，不同国家的宽基指数的组合等。</p><p>但是由于前文所述的数据源的问题，暂时还无法验证，感兴趣的读者如果有相关数据不妨验证一番。</p><p><em>注：相关系数区间为[-1, 1]，-1 表示完全负相关，+1表示完全正相关。</em></p><h2 id="下期预告"><a href="#下期预告" class="headerlink" title="下期预告"></a>下期预告</h2><p>题目既然是中，肯定就有下。</p><p>指数的估值有很多方法，利用PE（PB）百分位计算估值只是其中一种。这种方法的问题是，PE（PB）的波动通常来自于市场情绪的变化，所以它只适合盈利（资产）比较稳定的指数（企业）。</p><p>下一篇会介绍另一种指数的估值方法—博格公式法。</p><p>敬请期待~</p><h2 id="说点其它的"><a href="#说点其它的" class="headerlink" title="说点其它的"></a>说点其它的</h2><p>最近开始开发和验证一些简单但有效的投资策略，以期构建属于自己的投资组合，在实践中加快自己投资体系的建立。</p><p>由于深知“闭门造车”的弊端，所以借这篇文章推广一下：</p><p>如果你对投资理财感兴趣，或者也想自己写一些策略，公众号回复【搞事情】or 【联系方式】，欢迎进群一起交流！</p><hr><p><strong>都看到这里了，不如顺手加个关注？~~</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>定投</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#9——来一次说走就走的旅行！</title>
    <link href="/2021/07/14/invest-pratice-9/"/>
    <url>/2021/07/14/invest-pratice-9/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a></p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更“美好”的事物上。</p><h2 id="本月进展"><a href="#本月进展" class="headerlink" title="本月进展"></a>本月进展</h2><p>6月份进展如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/18/16261938179961.jpg" alt=""></p><p>当前进展 2.63%，相比上个月增加了 0.04%。本星期最后一天回调了不少，没想到总额还是在增加。继续缓慢而坚定的爬坡。</p><p>本月操作：无。</p><h2 id="一次说走就走的旅行"><a href="#一次说走就走的旅行" class="headerlink" title="一次说走就走的旅行"></a>一次说走就走的旅行</h2><p>题目有点标题党，不过上周六来了一次差不多的旅行，所以今天就来聊一聊这个话题。</p><p>自从高晓松喊出那句“生活不止眼前的苟且，还有诗和远方”后，“诗”、“远方”、“说走就走的旅行”等文艺词汇在各种文章中迅速泛滥开来，已有成灾的趋势。</p><p>然而困于996的我们，仅仅眼前的苟且就已经疲于应付，哪还能随心所欲的说走就走呢？</p><p>走就走的旅行的背后是自由的选择权，这也是财务自由追求的目标。</p><p>说起财务自由，很多人想当然的认为遥不可及，很难实现，并没有真正去想这个很难到底是多难？这个问题在 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a> 中讨论过，并没有很难，或者说没有想象中的那么难。</p><p>当然财务自由并不是今天的主题，今天想说的是，说走就走的旅行其实也没那么难。</p><p>假设财务自由对应的是一年365天我们可以自由的规划生活方式，那把时间区间缩短到成周六日2天，在这两天里面，没有房贷，没有房租，近乎自由的状态下，能否规划出一个高质量的短途旅行？</p><p>答案是完全可以。</p><p>上周六临时起意，去了趟张北草原天路。因此本篇以这次旅行为例，讨论一下说走就走的旅行成本。</p><p>以我有限的旅行经历，总结了如下三个主要的旅行成本：</p><ul><li>旅行攻略的成本</li><li>旅行的时间成本</li><li>旅行的金钱成本</li></ul><p><strong>旅行攻略的成本</strong></p><p>说到旅行的成本，大家第一想到的一般都是时间和金钱，很少会把做攻略当成成本，但我认为这是旅行中十分重要的一环，甚至是最重要的一环。</p><p>去哪玩，怎么去，怎么玩，住哪，怎么回来，怎么在不降低旅行质量的前提下降低成本，这都是攻略需要考虑的。</p><p>尽管如此，做攻略的成本仍然很低。出行前随便抽出一点时间，到网上搜集汇总一下资料，就能做出一个不错的攻略。</p><p>简而言之，做旅游攻略是一项 ROI（投入产出比）极高的活动。</p><p>这次去草原天路，除了前几天刷了几遍马蜂窝，正儿八经坐下来写攻略只有1小时。</p><p><strong>旅行的时间成本</strong></p><p>从我住的地方到草原天路，来回400多公里，加上天路100公里，一共500多公里。</p><p>早上8点半出发，晚上11点半到家，耗时15小时，周六一整天。</p><p><strong>旅行的金钱成本</strong></p><p>到了大家最关心的一块了（瞎猜的）。</p><p>短途旅行的成本并不高，毕竟一个周六日，也走不了多远。比如我这次的具体开销如下：</p><ul><li>油费：266</li><li>过路费：163</li><li>零食饮料：70</li></ul><p>一共499，估计就是大家搓一顿的价格。</p><p>另外，我还有个小窍门来覆盖旅行成本。很早之前，我就在支付宝上设置了一个旅游基金的账户（其实就是余额宝的心愿储蓄功能），每月小额定投，不考虑任何收益，就那么放着。</p><p>每次旅行，开支都从这个账户中出。专款专项，花起来没有任何心理负担（明明都是自己的钱，但是心态就是不一样，很神奇~）。</p><p>是不是有点像一个乞丐版的旅行自由计划😂？虽然投的少，但是旅行本身也是低频行为，积累下来，短途旅行基本可以算自由了。</p><p>最后总结下来，这次说走就走的旅行的总成本如下：</p><ul><li>做攻略1小时</li><li>旅途全程耗时15小时</li><li>花费499</li></ul><p>量化之后，是不是比想象中的要低很多？</p><h2 id="附上旅途中的一些照片"><a href="#附上旅途中的一些照片" class="headerlink" title="附上旅途中的一些照片"></a>附上旅途中的一些照片</h2><p>草原天路其实就是一条公路，但是因为它从草原中穿过，地貌特殊，风景奇特，故而被称为中国的66号公路。</p><p>去景点的高速上。</p><p>上午天气十分不错，高速从群山之间穿过，把城市的喧嚣远远甩在身后。<br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/11/16254177919305.jpg" alt=""></p><p>草原天路的西入口，看着有点俗气。<br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/11/601625931531pichdfu-ben3.jpg" alt=""></p><p>进去之后，画风突变。这就是今天的主角：<strong>草原天路</strong>了。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/11/wechatimg61.jpeg" alt=""></p><p>路上车不多，随手一拍，公路感十足。<br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/11/16259335364378.jpg" alt=""></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/11/16259336522508.jpg" alt=""></p><p>陡坡下坡。<br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/11/16259337033746.jpg" alt=""></p><p>远处云雾缭绕，电机耸立成群。<br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/11/16254192663037.jpg" alt=""></p><p>停在路边拍的，是不是和想象中的草原不太一样？<br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/11/16259373362705.jpg" alt=""></p><p>草原上气候多变，光线变化很大。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/11/16254189397437.jpg" alt=""></p><p>换了个地儿。一望无际的草原上，牧民策马奔腾。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/11/16259377678923.jpg" alt=""></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/11/16259375806112.jpg" alt=""></p><p>近距离看一下羊群。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/11/16254190379020.jpg" alt=""></p><p>一只落单的马儿。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/11/16259376471198.jpg" alt=""></p><p>最后一张收尾。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/07/11/16259380168543.jpg" alt=""></p><p>尤其喜欢这张。天地之间，草原之上。天路之际，野马之旁。</p><p>乘兴而来，兴尽而返。</p><p><em>这次就不放6月回顾了，放出来尴尬😓，下回再说~~</em></p><hr><p><strong>都看到这里了, 不如顺手加个关注？</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何提高定投收益率（上）</title>
    <link href="/2021/06/27/fix-investment-1/"/>
    <url>/2021/06/27/fix-investment-1/</url>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://mp.weixin.qq.com/s/Rh3cXEVwjGecFXPkw7z66w">《定投的“陷阱”》</a> 把定投的“面纱”揭开了一部分，讨论了定投的效果和指数（净值）走势的关系。</p><p>今天这一篇，我们继续来扯一扯定投的“面纱”，看看如何定投才能尽可能提高收益率。</p><h2 id="普通定投"><a href="#普通定投" class="headerlink" title="普通定投"></a>普通定投</h2><p>定投的全称其实叫<strong>定期定额投资</strong>，它有以下三个要素：</p><ul><li>投资频率</li><li>单次投资金额</li><li>投资对象</li></ul><p>投资频率和单次投资金额很好理解，这两个的关系是反比，频率升高，单次金额就会下降，反之亦然。</p><p>投资对象就是我们要买的基金。因为如何挑选基金不是今天的主题，所以接下来的讨论中，投资对象都选用常见的几种指数。</p><p>下面进入正题。</p><p>对于上班族来说，每个月能拿出来的投资总额是有上限的。因此关于定投，有一个话题常常被拿出来讨论：</p><p><strong>定投频率是按月好还是按周好？</strong></p><p>有说按周好的，有说按月好的，也有说没区别的。本着<strong>实践是检验真理的唯一标准</strong>，我们就用沪深300来做一个回测，看看<strong>按周定投</strong>和<strong>按月定投</strong>差距有多少？</p><p>先给一张沪深300至今的走势图：<br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/27/16245572675656.jpg" alt="沪深300走势"></p><p>重点注意下其中几个波峰，这样就能理解下面回测中收益率的异常波动了。</p><p>由于手上沪深300的指数数据起始日期是 2005-01-04，所以下面的回测以这个时间点为起点：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/27/16242042864171.jpg" alt="普通定投年化收益率"></p><p>从上图中可以看出，随着时间跨度的增加，按周定投和按月定投年化收益率的差距逐步缩小，从第三年开始，差距就几乎可以忽略不计。</p><p>有人又会说，上面这个是年化收益率，是一个倒推的值，实际收益率对比如何呢？且看下图：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/27/16242049245969.jpg" alt="普通定投总收益率"></p><p>几乎一样。</p><p>所以，按月定投还是按周定投，真的一点区别没有。</p><p>个人建议定投频率和发工资的频率持一致，按月定投，这样最是省事。</p><h2 id="不定期不定额"><a href="#不定期不定额" class="headerlink" title="不定期不定额"></a>不定期不定额</h2><p>定期定额投资的方式固然省事，但却不是最优的方案。《指数基金投资指南》上举了个例子：</p><blockquote><p>王大爷2014年7月买了2万的沪深300指数基金，到2015年5月，打开账户一看，发现当初的2万元变成了4万元。</p><p>王大爷很高兴，这个基金这么好，应该多买点，于是又买了10万。结果到2016年初，打开账户一看，不仅一分钱没赚到，还倒赔了1万。</p></blockquote><p>同一只基金，为什么会出现这种情况呢？很简单，第二次，王大爷买贵了！</p><p>我们买东西，都希望能买到一个便宜的价格。基金是资产，因此如果能以一个便宜的价格买入，在一个较高的价格卖出，赚钱就是一个大概率的事情了。</p><h3 id="利用估值定投"><a href="#利用估值定投" class="headerlink" title="利用估值定投"></a>利用估值定投</h3><p>一些常见的基金投资软件，都会提供指数估值作为投资参考，下面是这些软件提供的指数估值说明（从左到右边依次是蛋卷基金、天天基金、且慢、支付宝）：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/27/16247758342110.jpg" alt="各平台估值方式"></p><p>这四家思路都差不多。手机上不方便看图，我这里把4家的估值方法简单列举下：</p><p><strong>蛋卷基金</strong></p><ul><li>PE或PB百分位 &lt; 30%，且绝对值小于 20 为低估</li><li>PE或PB百分位 &gt; 70%，且绝对值大于 20 为高估</li><li>其余情况为正常估值</li><li>采用近10年数据，不满10年采用全部数据</li></ul><p><strong>天天基金</strong></p><ul><li>区分行业：盈利稳定的行业用PE指标；周期性行业或者盈利不稳定的行业用PB指标（宽基指数用PE）</li><li>PE（PB）百分位低于 35% 定义为低估</li><li>PE（PB）百分位高于 70% 定义为高估</li><li>采用近7年的数据，不满7年采用全部数据（根据PE走势图推测）</li></ul><p><strong>且慢</strong></p><ul><li>区分行业：周期行业采用PB指标；其它采用PE指标</li><li>具体的计算方式（阈值）没有给出</li><li>采用近8年数据，不满8年采用全部数据</li></ul><p><strong>支付宝</strong></p><ul><li>区分行业：金融行业采用PB指标；其它采用PE指标</li><li>PE百分位低于 30% 定义为低估（询问智能客服）</li><li>PE百分位高于 70% 定义为高估</li><li>采用指数发布之日至今的数据（根据部分PE走势图推测，实际时间跨度不超过14年）</li></ul><p>这里解释下百分位，它是一个统计指标，用来表明当前值在历史区间中所处的位置。</p><p>按照这些估值建议，真的能获得一个更高的收益吗？</p><p>接下来，我们仍然选取沪深300指数，来做一个回测。</p><p>为了简化运算，我们设定如下策略：</p><ul><li>估值指标选用市盈率PE</li><li>按月定投，投入到现金账户</li><li>如果PB百分位低于 30%，则买入沪深300指数，买入金额为现金账户全部余额；如果PB百分位高于 70%，则卖出到现金账户；其它情况不买也不卖</li><li>采用近10年数据，不满10年采用全部历史数据</li></ul><p>简而言之就是，定投依旧，但是买卖基金却视估值而定。</p><p>假设把这种策略叫做<strong>估值定投V1版</strong>，经过回测，它和<strong>普通定投</strong>的年化收益率对比如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/27/16247344831795.jpg" alt="普通定投 vs 估值定投V1版-1"></p><p>可以看到，根据PE指标进行“低买高卖”确实会有更高的收益，从开始至今，年化收益率多 6 个百分点。</p><p><strong>但是</strong>，上面这张图在计算估值定投V1版年化收益率的时候，<strong>仅仅计算了买入和卖出沪深300部分资金的收益率</strong>，并没有计算闲置资金对收益率的影响。</p><p>如果我们将持有的现金部分也参与计算，回测对比结果如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/27/16247365110337.jpg" alt="普通定投 vs 估值定投V1版-2"></p><p>虽然估值定投V1版的年化收益率还是高一些，但是比上一张图低了近 4 个百分点。</p><p>并且定投时间为1年、3年、5年时，都是普通定投的年化收益更高。因为对应的时间段正好是A股牛市，估值较高，没有买点，过多的持有现金，拉低了估值定投V1版的收益率。</p><p>由此可看，简单的利用市盈率PE等指标的百分位进行“低买高卖”，相比傻瓜式的普通定投，是能获取更高的收益的。</p><p><em>注：由于手上沪深300的 PB 数据是从2005-04-08开始的，所以上面两张图回测的起始日期是2005-04-08</em></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天这篇文章，简单回测了普通定投和估值定投V1版这两种策略。</p><p>对于普通定投，回测发现，按周定投和按月定投的收益率并没有显著区别，因此如果采取这种策略，选择自己舒服的定投频率即可。</p><p>对于不定期不定额投资策略估值定投V1版，回测发现，简单的”低买高卖“确实能提高不少收益，但是资金的利用率较低，会拉低整体收益水平。</p><p>有了估值定投V1版做基础，自然而然的我们就会想到，当沪深300高估时，如果寻找其它的一些处于低估阶段的指数买入，提高资金的利用率，收益是否会更高呢？</p><p>另外，除了使用PE、PB等技术指标，还有其它方式对指数进行估值吗？</p><p>嗯，这些会在下一篇中进行探讨，敬请期待！</p><p><strong>最后留个小问题</strong>：</p><p>计算百分位的时候，都会有一个最长期限，蛋卷是10年，天天是7年，且慢是8年，即使是支付宝，说是全部历史数据，实际最长也只有14年，你知道这是为什么吗？</p><h2 id="说点其它的"><a href="#说点其它的" class="headerlink" title="说点其它的"></a>说点其它的</h2><p>最近终于捡起了去年的想法，开始验证和开发一些简单但有效的投资策略，以期构建属于自己的投资组合，在实践中加快自己投资体系的建立。</p><p>由于深知“闭门造车”的弊端，所以借这篇文章推广一下：</p><p>如果你对投资理财感兴趣，或者也想自己写一些策略，公众号回复【搞事情】，欢迎进群一起交流！</p><p>另外，这两天会整理下本文涉及的代码，提交一波，也欢迎一起贡献代码，一起 cr ~</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>定投</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#8——长赢发车了！</title>
    <link href="/2021/06/11/invest-pratice-8/"/>
    <url>/2021/06/11/invest-pratice-8/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://mp.weixin.qq.com/s/49KY32C-X93hovNyAXdBLQ">财务自由实证#0——自由能实现吗？</a>。</p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更“美好”的事物上。</p><h2 id="本月进展"><a href="#本月进展" class="headerlink" title="本月进展"></a>本月进展</h2><p>5月份进展如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/16230792543686.jpg" alt=""></p><p>当前进展 2.59%，相比上个月增加了 0.13%，继续缓慢而坚定的爬坡。</p><p>由于几笔大额支出，家庭备用金出现了一定程度的短缺，为了确保现金流以及该计划的完整执行，5月份有意识的控制了下跟投的频率。</p><p>本月特殊操作：无。</p><h2 id="长赢发车了！"><a href="#长赢发车了！" class="headerlink" title="长赢发车了！"></a>长赢发车了！</h2><p>6.9号 <strong>长赢计划</strong> 和 <strong>长赢S定投</strong> 同时发车，买入中国海外互联。</p><p>中国海外互联全称是【交银中证海外中国互联网指数】，交银施罗德基金管理公司旗下的一只追踪【中证海外中国互联网指数】的指数基金，基金类型<strong>LOF</strong>，也就是说这只基金可同时在场内、场外交易。</p><p>很明显，该基金追踪的就是中证海外中国互联网指数。接下来我们从指数以及基金本身两个方面来扒一扒。</p><h3 id="中证海外中国互联网指数"><a href="#中证海外中国互联网指数" class="headerlink" title="中证海外中国互联网指数"></a>中证海外中国互联网指数</h3><blockquote><p>中证海外中国互联网指数选取海外交易所上市的中国互联网企业作为样本股，采用自由流通市值加权计算，以反映在海外交易所上市中国互联网企业的整体走势。</p></blockquote><p>为什么会有这个指数？</p><p>因为很多中国的互联网企业，出于各种原因到境外上市，国内主流的指数如沪深300、中证500等无法包含这些公司，所以中证公司就专门编制了这个指数用以追踪海外上市的中国互联网公司。</p><p>那这个指数中到底包含哪些公司呢？我们看一下它的前10大成份股：</p><div class="table-container"><table><thead><tr><th>公司名称</th><th>上市地点</th><th>权重</th></tr></thead><tbody><tr><td>腾讯控股</td><td>香港</td><td>11.72%</td></tr><tr><td>阿里巴巴</td><td>纽约</td><td>10.31%</td></tr><tr><td>美团</td><td>香港</td><td>7.78%</td></tr><tr><td>拼多多</td><td>纳斯达克</td><td>6.33%</td></tr><tr><td>百度</td><td>纳斯达克</td><td>5.6%</td></tr><tr><td>网易</td><td>纳斯达克</td><td>5.38%</td></tr><tr><td>携程网</td><td>纳斯达克</td><td>5.31%</td></tr><tr><td>哔哩哔哩</td><td>纳斯达克</td><td>4.67%</td></tr><tr><td>贝壳</td><td>纽约</td><td>4.57%</td></tr><tr><td>京东商城</td><td>纳斯达克</td><td>3.97%</td></tr></tbody></table></div><p>这一堆公司，相信只要家里通了网，或多或少都会听过一些，尤其是腾讯阿里，已经渗透进我们生活的方方面面了。</p><p>关于这只指数，还有一点值得说一下，就是它的单只成份股权重上限为10%，每半年调整一次。</p><p>为什么要强调这点？</p><p>因为还有一个比较出名的追踪海外互联网公司的指数：中国互联网50，这两只指数成份股完全一样，区别就在中国互联网50的单只成份股权重上限是30%，所以中国互联50里面腾讯+阿里的权重达到了60%。</p><h3 id="基金本身"><a href="#基金本身" class="headerlink" title="基金本身"></a>基金本身</h3><p>该基金的管理人是交银施罗德基金管理有限公司，它的一些基本信息如下：</p><div class="table-container"><table><thead><tr><th>项目</th><th>细节</th></tr></thead><tbody><tr><td>成立日期</td><td>2015-07-10</td></tr><tr><td>基金经理</td><td>邵文婷（21年4月份开始担任）</td></tr><tr><td>规模</td><td>25.23亿</td></tr><tr><td>申购费</td><td>1.2%（50万以下）</td></tr><tr><td>赎回费</td><td>1.5%(<7天), 0.5%(<1年), 0.2%(<2年), 0(>2年)</td></tr><tr><td>管理费</td><td>1.2%</td></tr><tr><td>托管费</td><td>0.25%</td></tr></tbody></table></div><p>由于是指数基金，也没有太多可研究的。基金规模还可以，费用不低，但也在正常范围内。</p><p>自该基金成立以来，其收益走势如下图：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/16233386166800.jpg" alt=""></p><p>很明显，相比沪深300，它的收益率更高，波动也更大。</p><p>由于中国互联网指数的前十大成份股几乎是中国最优秀的一批互联网公司，其优质程度远超A股的公司，所以长期来看，中国互联的收益率一定是高于沪深300的。</p><p>但是由于这些公司都在海外上市，它们所面临的文化差异和信息差异较大，影响股价因素较多，波动也较大。</p><p>如果想投资这些优秀的互联网公司，但是苦于投资途径限制，这个指数还是比较推荐的。</p><h2 id="5月回顾"><a href="#5月回顾" class="headerlink" title="5月回顾"></a>5月回顾</h2><p>在上一篇 <a href="https://mp.weixin.qq.com/s/XWfjJ9WJ8DpxoVpaW1tacg">财务自由实证#7——实证升级了</a> 中，我对该实证计划进行了升级：日后该实证计划将会逐渐变成个<strong>人成长实证</strong>，除了例行的<strong>实证进展</strong>模块外，还会有<strong>本月回顾</strong>模块以及<strong>下月计划</strong>模块。</p><p>下面就来检验一下5月计划的进展情况~~</p><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p><strong>1.</strong> 《Go 并发编程实战》channel 部分文章计划4篇，实际完成3篇，完成度 <em>75%</em>。<br><strong>2.</strong> 指数相关文章输出，以及温度计调研，完成度 <em>0%</em></p><h3 id="个人项目"><a href="#个人项目" class="headerlink" title="个人项目"></a>个人项目</h3><p><strong>1.</strong> 语料库存储方案调研，仅仅是比较了常见的几种数据库的优劣，算不上调研，不过方案也定了，完成度就算 <em>100%</em><br><strong>2.</strong> 基金入门知识语料的整理，6篇文章均已整理完成，完成度 <em>100%</em></p><p>整个5月份，有几周因为工作原因特别忙，而且周末也各种事，整体进展并不是很满意。</p><h2 id="下月计划"><a href="#下月计划" class="headerlink" title="下月计划"></a>下月计划</h2><h3 id="写作-1"><a href="#写作-1" class="headerlink" title="写作"></a>写作</h3><ul><li>继续完成《Go 并发编程实战》部分文章的输出，数量&gt;=4</li><li>继续完成行业指数、国外主流指数相关文章的输出，同时开始温度计的调研，数量&gt;=4</li></ul><h3 id="个人项目-1"><a href="#个人项目-1" class="headerlink" title="个人项目"></a>个人项目</h3><ul><li>完成一个最简单的基金问答的机器人，并利用公众号实现基本的交互</li></ul><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><ul><li>减少熬夜，保证每日睡眠时间&gt;=6.5h</li></ul><p>就这样，继续期待6月底的实证~~</p><hr><p><strong>都看到这里了, 不如顺手点个 赞/在看, 加个关注？</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/06/11/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 并发基石之 channel (三) —— 几种典型的应用模式</title>
    <link href="/2021/05/23/go-channel-3/"/>
    <url>/2021/05/23/go-channel-3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Go 并发系列是根据我对晁岳攀老师的《Go 并发编程实战课》的吸收和理解整理而成，如有偏差，欢迎指正~</p></blockquote><p>在上一篇 <a href="https://mp.weixin.qq.com/s/uS4jS26V7jfJW80Jpsh3RA">Go 并发基石之 channel (二) —— 源码初探</a> 中粗略的了一遍 channel 的源码，大致了解了背后的实现思路。</p><p>这一篇，主要介绍 channel 的几种经典的应用模式。</p><h2 id="channel-的五种应用场景"><a href="#channel-的五种应用场景" class="headerlink" title="channel 的五种应用场景"></a>channel 的五种应用场景</h2><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/22/channel-de-wu-zhong-ying-yong-chang-jing.jpg" alt="channel 的五种应用场景"></p><h2 id="消息交流"><a href="#消息交流" class="headerlink" title="消息交流"></a>消息交流</h2><p>channel 的底层是一个循环队列，当队列的长度大于 0 的 时候，它会被当做线程安全队列和 buffer。利用这个特性，一个 goroutine 可以安全的往 channel 中存放数据，另一个 goroutine 可以安全的从 channel 中读取数据，这样就实现了 goroutine 之间的消息交流。</p><p>这个比较简单，就不展开了。</p><h2 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h2><p>数据传递类似游戏“击鼓传花”。鼓响时，花（或者其它物件）从一个人手里传到下一个人，数据就类似这里的花。</p><p>现在有下面这样一个任务：</p><blockquote><p>有 4 个 goroutine，编号为 1、2、3、4。每秒钟会有一个 goroutine 打印出它自己的编号，要求你编写程序，让输出的编号总是按照 1、2、3、4、1、2、3、4……这个顺序打印出来。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startTask</span><span class="hljs-params">(id, n <span class="hljs-keyword">int</span>, chans []<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-comment">// 每个任务从对应的 chan 读取数据，并传递给下一个chan</span><br><span class="hljs-keyword">for</span> &#123;<br>token := &lt;-chans[id]<br>fmt.Printf(<span class="hljs-string">&quot;%d \n&quot;</span>, id+<span class="hljs-number">1</span>)<br>chans[(id+<span class="hljs-number">1</span>)%n] &lt;- token<br>time.Sleep(time.Second)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>n := <span class="hljs-number">4</span><br>chans := []<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>chans = <span class="hljs-built_in">append</span>(chans, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;))<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br><span class="hljs-keyword">go</span> startTask(i, n, chans)<br>&#125;<br>chans[<span class="hljs-number">0</span>] &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中，token 代指“击鼓传花”中的“花”，chans 代指围坐一圈的人。每个 chan（人）都是从上一个 chan（人）手中拿到 token，放在自己手上，从而实现顺序打印 1，2，3，4。</p><h2 id="信号通知"><a href="#信号通知" class="headerlink" title="信号通知"></a>信号通知</h2><p>channel 类型有这样一个特性：如果 channel 为空，那么 recevier 接收数据的时候就会阻塞，直到有新的数据进来或者 channel 被关闭。</p><p>利用这个特性，就可以实现 wait/notify 设计模式。另外还有一个经常碰到的场景，实现程序的 graceful shutdown。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      ...... <span class="hljs-comment">// 执行业务处理</span><br>    &#125;()<br><br>  <span class="hljs-comment">// 处理CTRL+C等中断信号</span><br>  termChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal)<br>  signal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM)<br>  &lt;-termChan <br><br>  <span class="hljs-comment">// 执行退出之前的清理动作</span><br>  doCleanup()<br>  <br>  fmt.Println(<span class="hljs-string">&quot;优雅退出&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，如果清理操作很耗时，需要增加超时限制，doClenup() 可以进行如下改写：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    closed := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>    <br>    ...... <span class="hljs-comment">// 中间过程都一样</span><br>    <br>    <span class="hljs-comment">// 执行退出之前的清理操作</span><br>    <span class="hljs-keyword">go</span> doCleanup(closed)<br>    <br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-closed:<br>    <span class="hljs-keyword">case</span> &lt;-time.After(time.Second):<br>        fmt.Println(<span class="hljs-string">&quot;清理超时，不等了！&quot;</span>)<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;优雅退出！&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doCleanup</span><span class="hljs-params">(closed <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br>    time.Sleep(time.Minute)<br>    <span class="hljs-built_in">close</span>(closed)<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>在这个系列最开始就介绍了 <a href="https://mp.weixin.qq.com/s/gjXH9RU_8X_MASHMINHNVQ">Go 中 Mutex 设计原理详解（一）</a>。利用 channel 我们也能实现锁的功能。</p><p>sync.Mutex 通过修改持有锁标记位的状态达到占有锁的目的，因此 channel 可以通过转移这个标记位的所有权实现占有锁。</p><p>具体代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// 使用chan实现互斥锁</span><br><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;<br>    ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 使用锁需要初始化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMutex</span><span class="hljs-params">()</span> *<span class="hljs-title">Mutex</span></span> &#123;<br>    mu := &amp;Mutex&#123;<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)&#125;<br>    mu.ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    <span class="hljs-keyword">return</span> mu<br>&#125;<br><br><span class="hljs-comment">// 请求锁，直到获取到</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">Lock</span><span class="hljs-params">()</span></span> &#123;<br>    &lt;-m.ch<br>&#125;<br><br><span class="hljs-comment">// 解锁</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">Unlock</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> m.ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;:<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unlock of unlocked mutex&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 尝试获取锁</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">TryLock</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-m.ch:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">default</span>:<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 加入一个超时的设置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">LockTimeout</span><span class="hljs-params">(timeout time.Duration)</span> <span class="hljs-title">bool</span></span> &#123;<br>    timer := time.NewTimer(timeout)<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-m.ch:<br>        timer.Stop()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">case</span> &lt;-timer.C:<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 锁是否已被持有</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">IsLocked</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(m.ch) == <span class="hljs-number">0</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := NewMutex()<br>    ok := m.TryLock()<br>    fmt.Printf(<span class="hljs-string">&quot;locked v %v\n&quot;</span>, ok)<br>    ok = m.TryLock()<br>    fmt.Printf(<span class="hljs-string">&quot;locked %v\n&quot;</span>, ok)<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这里实现锁主要利用了向满 channel 发送数组或从空 channel 接收数据会阻塞的特性。另外，利用 select 很容易实现 TryLock 和 Timeout 的功能。</p><h2 id="任务编排"><a href="#任务编排" class="headerlink" title="任务编排"></a>任务编排</h2><p>在前面的 <a href="https://mp.weixin.qq.com/s/GhM-xnBWazxii2G0uvwOew">Go 并发任务编排利器之 WaitGroup</a> 中介绍了 sync.WaitGroup。通过 sync.WaitGroup，我们能很容易的实现 <em>等待一组 goroutine 完成任务</em> 这种任务编排需求。同样，我们也可以用 channel 实现。</p><p>但是如果任务编排再复杂一些呢？如果面试官出了下面这个题目：</p><blockquote><p>有一批任务需要处理，但是机器资源有限，只能承受100的并发度，该如何实现？</p></blockquote><p>一种解决方案就是使用 channel，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">task</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-comment">//执行任务</span><br>time.Sleep(time.Second * <span class="hljs-number">10</span>)<br>ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">concurrency100</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">100</span>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        &lt;-ch<br>        <span class="hljs-keyword">go</span> task(ch)<br>    &#125;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> &#123;<br>fmt.Println(runtime.NumGoroutine())  <span class="hljs-comment">// 观察并发度</span><br>time.Sleep(time.Second)<br>&#125;<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>利用 sender 给满员的 channel 发送数据会阻塞的特性，就实现了并发度始终维持在 100 的需求。</p><p>除此之外，下面再介绍几种常见的模式。</p><h3 id="or-Done-模式"><a href="#or-Done-模式" class="headerlink" title="or-Done 模式"></a>or-Done 模式</h3><p>or-Done 模式对应的场景很好理解，n 个任务，有一个完成就算完成。</p><p>看过之前文章 <a href="https://mp.weixin.qq.com/s/4Z2hhn1H6F95wPnFfMz1bA">记一次学习 orDone 模式爬坑经历</a> 读者对 or-Done 应该不陌生，因为课程中关于 or-Done 模式的代码是<strong>有问题的！</strong></p><p>正确的代码应该是下面这个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">or</span><span class="hljs-params">(channels ...&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123; <span class="hljs-comment">//1</span><br><br><span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(channels) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">//2</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">//3</span><br><span class="hljs-keyword">return</span> channels[<span class="hljs-number">0</span>]<br>&#125;<br><br>orDone := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//4</span><br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(orDone)<br><br><span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(channels) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">//5</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">0</span>]:<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">1</span>]:<br>&#125;<br><span class="hljs-keyword">default</span>: <span class="hljs-comment">//6</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">0</span>]:<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">1</span>]:<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">2</span>]:<br><span class="hljs-keyword">case</span> &lt;-or(<span class="hljs-built_in">append</span>(channels[<span class="hljs-number">3</span>:], orDone)...): <span class="hljs-comment">//6</span><br>&#125;<br>&#125;<br>&#125;()<br><span class="hljs-keyword">return</span> orDone<br>&#125;<br></code></pre></td></tr></table></figure><p>在编写 or-Done 的代码时，有两个点需要注意：</p><ol><li>递归前，需要声明一个 orDone 变量，用来通知子函数退出。</li><li>len(channels) == 2 是一种特殊情况，否则会因为 append orDone 产生无限递归。</li></ol><h3 id="扇入模式"><a href="#扇入模式" class="headerlink" title="扇入模式"></a>扇入模式</h3><p>扇入（Fan-In）是一个术语，用于描述将多个结果组合到一个 channel 中的过程。扇入模式下，输入源有多个，输出目标只有一个。下面是扇入模式的一种实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fanInRec</span><span class="hljs-params">(chans ...&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(chans) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>        <span class="hljs-built_in">close</span>(c)<br>        <span class="hljs-keyword">return</span> c<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> chans[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> mergeTwo(chans[<span class="hljs-number">0</span>], chans[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">default</span>:<br>        m := <span class="hljs-built_in">len</span>(chans) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> mergeTwo( <span class="hljs-comment">// 对多个数据进行合并处理</span><br>            fanInRec(chans[:m]...),<br>            fanInRec(chans[m:]...))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="扇出模式"><a href="#扇出模式" class="headerlink" title="扇出模式"></a>扇出模式</h3><p>扇出模式（Fan-Out）只有一个输入源，但是有多个输出目标。下面是一个扇出模式的实现，从源 channel 取出一个数据后，依次发送给多个目标 channel。发送的时候，既可以同步，也可以异步。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fanOut</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, out []<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, async <span class="hljs-keyword">bool</span>)</span></span> &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//退出时关闭所有的输出chan</span><br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(out); i++ &#123;<br>                <span class="hljs-built_in">close</span>(out[i])<br>            &#125;<br>        &#125;()<br><br>        <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123; <span class="hljs-comment">// 从输入chan中读取数据</span><br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(out); i++ &#123;<br>                <span class="hljs-keyword">if</span> async &#123; <span class="hljs-comment">//异步</span><br>                    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>                        out[i] &lt;- v <span class="hljs-comment">// 放入到输出chan中,异步方式</span><br>                    &#125;()<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    out[i] &lt;- v <span class="hljs-comment">// 放入到输出chan中，同步方式</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><p>stream 是把 channel 当做流式管道的方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// asStream 将一个 slice 转成流</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">asStream</span><span class="hljs-params">(done &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, values ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>    s := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-comment">//创建一个unbuffered的channel</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 启动一个goroutine，往s中塞数据</span><br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(s) <span class="hljs-comment">// 退出时关闭chan</span><br>        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123; <span class="hljs-comment">// 遍历数组</span><br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-done:<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">case</span> s &lt;- v: <span class="hljs-comment">// 将数组元素塞入到chan中</span><br>            &#125;<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>转成流之后，如果要实现取前 N 个数的功能 TakeN，可以再创建一个输出流，从输入流中读取:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">takeN</span><span class="hljs-params">(done &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, valueStream &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, num <span class="hljs-keyword">int</span>)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>    takeStream := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-comment">// 创建输出流</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(takeStream)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; num; i++ &#123; <span class="hljs-comment">// 只读取前num个元素</span><br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-done:<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">case</span> takeStream &lt;- &lt;-valueStream: <span class="hljs-comment">//从输入流中读取元素</span><br>            &#125;<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> takeStream<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map-reduce"></a>map-reduce</h3><p>map-reduce 是一种面向大规模数据处理的并行计算模型和方法，但是这里要介绍的是一种单机版的 map-reduce 模式。</p><p>map-reduce 分为两个步骤，第一步是 map，将队列中的数据用 mapFn 函数处理；第二步是 reduce，将处理后的数据用 reduceFn 函数汇总。</p><p>map 逻辑实现如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapChan</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, mapFn <span class="hljs-keyword">func</span>(<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125;) &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-comment">//创建一个输出chan</span><br>    <span class="hljs-keyword">if</span> in == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 异常检查</span><br>        <span class="hljs-built_in">close</span>(out)<br>        <span class="hljs-keyword">return</span> out<br>    &#125;<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 启动一个goroutine,实现map的主要逻辑</span><br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(out)<br>        <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> in &#123; <span class="hljs-comment">// 从输入chan读取数据，执行业务操作，也就是map操作</span><br>            out &lt;- mapFn(v)<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">return</span> out<br>&#125;<br></code></pre></td></tr></table></figure></p><p>reduce 逻辑实现如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reduce</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, reduceFn <span class="hljs-keyword">func</span>(r, v <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">if</span> in == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 异常检查</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    out := &lt;-in <span class="hljs-comment">// 先读取第一个元素</span><br>    <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> in &#123; <span class="hljs-comment">// 实现reduce的主要逻辑</span><br>        out = reduceFn(out, v)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> out<br>&#125;<br></code></pre></td></tr></table></figure></p><p>想象这样一个需求：将一组数据中每个数据乘以10，最后计算总和。为此，我们需要实现 mapFn (乘 10) 和 reduceFn （求和）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Go"><br><span class="hljs-comment">// 生成一个数据流</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">asStream</span><span class="hljs-params">(done &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>    s := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>    values := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(s)<br>        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123; <span class="hljs-comment">// 从数组生成</span><br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-done:<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">case</span> s &lt;- v:<br>            &#125;<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    in := asStream(<span class="hljs-literal">nil</span>)<br><br>    <span class="hljs-comment">// map操作: 乘以10</span><br>    mapFn := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>        <span class="hljs-keyword">return</span> v.(<span class="hljs-keyword">int</span>) * <span class="hljs-number">10</span><br>    &#125;<br><br>    <span class="hljs-comment">// reduce操作: 对map的结果进行累加</span><br>    reduceFn := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r, v <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>        <span class="hljs-keyword">return</span> r.(<span class="hljs-keyword">int</span>) + v.(<span class="hljs-keyword">int</span>)<br>    &#125;<br><br>    sum := reduce(mapChan(in, mapFn), reduceFn) <span class="hljs-comment">//返回累加结果</span><br>    fmt.Println(sum)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇过了一遍基于 channel 的几种典型应用模式，这些模式都不复杂，但是要做到灵活运用却不容易，平时写代码过程中如果遇到相应场景，还要仔细留心体会，多加练习。</p><p>到这里，channel 相关的知识点就告一段落了。</p><p>喜极而泣~</p><p>下期开始新的章节，再见~</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p><p><strong>都看到这里了，不如加个关注呗~~</strong></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>channel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 并发基石之 channel (二) —— 源码初探</title>
    <link href="/2021/05/16/go-channel-2/"/>
    <url>/2021/05/16/go-channel-2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Go 并发系列是根据我对晁岳攀老师的《Go 并发编程实战课》的吸收和理解整理而成，如有偏差，欢迎指正~</p></blockquote><p>在上一篇 <a href="https://afreecoder.cn/2021/05/06/go-channel-1/">Go 并发基石之 channel（一）</a> 中简单介绍了 channel 的由来、基本用法以及几种容易出错的场景。</p><p>这一篇，尝试通过 channel 源码的阅读，了解 channel 的实现思路。</p><p><em>说明：以下源码均基于 go1.16。</em></p><h2 id="channel-的定义"><a href="#channel-的定义" class="headerlink" title="channel 的定义"></a>channel 的定义</h2><p>channel 的数据类型是 <a href="https://github.com/golang/go/blob/release-branch.go1.16/src/runtime/chan.go">runtime.hchan</a>，其详细定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br>qcount   <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// channel中元素的个数</span><br>dataqsiz <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// channel的容量</span><br>buf      unsafe.Pointer <span class="hljs-comment">// 指向底层循环队列的指针</span><br>elemsize <span class="hljs-keyword">uint16</span>         <span class="hljs-comment">// 元素的大写</span><br>closed   <span class="hljs-keyword">uint32</span>         <span class="hljs-comment">// 是否关闭的标志</span><br>elemtype *_type <span class="hljs-comment">// 元素的类型</span><br>sendx    <span class="hljs-keyword">uint</span>   <span class="hljs-comment">// 已发送元素在队列中的索引</span><br>recvx    <span class="hljs-keyword">uint</span>   <span class="hljs-comment">// 已接收元素在队列中的索引</span><br>recvq    waitq  <span class="hljs-comment">// 等待接收数据的协程队列</span><br>sendq    waitq  <span class="hljs-comment">// 等待发送数据的协程队列</span><br><br><span class="hljs-comment">// 锁，保护hchan中所有字段</span><br>lock mutex<br>&#125;<br></code></pre></td></tr></table></figure><p>整体上，channel 的设计思路可以概述为用一个循环队列存储数据，send 索引和 recv 索引记录发送和接收数据的节点。向 channel 发送的数据会被添加循环队列尾部；从 channel 接收的数据来自于队列的首部。</p><h2 id="channel-的创建"><a href="#channel-的创建" class="headerlink" title="channel 的创建"></a>channel 的创建</h2><p>创建 channel 的语句如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)       <span class="hljs-comment">// 无缓冲的channel</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">2</span>)    <span class="hljs-comment">// 有缓冲的channel</span><br></code></pre></td></tr></table></figure><p>make 函数的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// walkMakeChan walks an OMAKECHAN node.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkMakeChan</span><span class="hljs-params">(n *ir.MakeExpr, init *ir.Nodes)</span> <span class="hljs-title">ir</span>.<span class="hljs-title">Node</span></span> &#123;<br><span class="hljs-comment">// When size fits into int, use makechan instead of</span><br><span class="hljs-comment">// makechan64, which is faster and shorter on 32 bit platforms.</span><br>size := n.Len<br>fnname := <span class="hljs-string">&quot;makechan64&quot;</span><br>argtype := types.Types[types.TINT64]<br><br><span class="hljs-keyword">if</span> size.Type().IsKind(types.TIDEAL) || size.Type().Size() &lt;= types.Types[types.TUINT].Size() &#123;<br>fnname = <span class="hljs-string">&quot;makechan&quot;</span><br>argtype = types.Types[types.TINT]<br>&#125;<br><span class="hljs-keyword">return</span> mkcall1(chanfn(fnname, <span class="hljs-number">1</span>, n.Type()), n.Type(), init, reflectdata.TypePtr(n.Type()), typecheck.Conv(size, argtype))<br>&#125;<br></code></pre></td></tr></table></figure><p>仅仅看注释，也能猜出来，make 的时候，编译器会根据系统的位数选择对应的函数： makechan64 还是 makechan。makechan64 底层直接调用的 makechan。所以我们直接看 makechane 的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">const</span> (<br>  <span class="hljs-comment">// maxAlign 用来设置内存最大对齐值</span><br>maxAlign  = <span class="hljs-number">8</span><br><span class="hljs-comment">// hchanSize 是大于 Sizeof(hchan&#123;&#125;) 的且为8的倍数中最小的一个</span><br>hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="hljs-keyword">uintptr</span>(-<span class="hljs-keyword">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="hljs-number">-1</span>))<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makechan</span><span class="hljs-params">(t *chantype, size <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">hchan</span></span> &#123;<br>elem := t.elem<br><br><span class="hljs-comment">// 元素最大不能超过64K</span><br><span class="hljs-keyword">if</span> elem.size &gt;= <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span> &#123;<br>throw(<span class="hljs-string">&quot;makechan: invalid channel element type&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> hchanSize%maxAlign != <span class="hljs-number">0</span> || elem.align &gt; maxAlign &#123;<br>throw(<span class="hljs-string">&quot;makechan: bad alignment&quot;</span>)<br>&#125;<br><br>mem, overflow := math.MulUintptr(elem.size, <span class="hljs-keyword">uintptr</span>(size))<br><span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;makechan: size out of range&quot;</span>))<br>&#125;<br><br>  <span class="hljs-comment">// 下面这个注释没太看明白，先放着，等以后看完 gc 再重新了解。 </span><br><span class="hljs-comment">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span><br><span class="hljs-comment">// buf points into the same allocation, elemtype is persistent.</span><br><span class="hljs-comment">// SudoG&#x27;s are referenced from their owning thread so they can&#x27;t be collected.</span><br><span class="hljs-keyword">var</span> c *hchan<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> mem == <span class="hljs-number">0</span>:<br><span class="hljs-comment">// 无缓冲</span><br>c = (*hchan)(mallocgc(hchanSize, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>))<br>c.buf = c.raceaddr()<br><span class="hljs-keyword">case</span> elem.ptrdata == <span class="hljs-number">0</span>:<br><span class="hljs-comment">// 非指针类型元素内存申请方式</span><br>c = (*hchan)(mallocgc(hchanSize+mem, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>))<br>c.buf = add(unsafe.Pointer(c), hchanSize)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// 指针类型元素内存申请方式</span><br>c = <span class="hljs-built_in">new</span>(hchan)<br>c.buf = mallocgc(mem, elem, <span class="hljs-literal">true</span>)<br>&#125;<br><br>c.elemsize = <span class="hljs-keyword">uint16</span>(elem.size)<br>c.elemtype = elem<br>c.dataqsiz = <span class="hljs-keyword">uint</span>(size)<br>lockInit(&amp;c.lock, lockRankHchan)<br><br><span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><p>梳理 makechan 的逻辑之前，先看下常量 maxAlign 和 hchanSize。</p><p><em>maxAlign</em>： 内存对齐最大值，这里8表示64位对齐。<br><em>hchanSize</em>： 大于 Sizeof(hchan{}) 且为8的倍数中最小的一个，其目的是提高 CPU 存取的速度（<strong>CPU 按块存取数据，块的大小可以是8、16、24等字节</strong>）。</p><p>第 20 行，计算需要给循环队列 buf 分配的内存，如果超过最大限制，则抛出异常。</p><p>接下来的内存分配流程比较清晰。</p><p>如果 mem == 0，说明是无缓冲 channel，只需要分配 hchan 本身的内存；如果缓冲数据是值类型，则分配 hchanSize+mem 大小的连续内存，buf 指向循环队列；如果缓冲数据是指针类型，则分别分配 hchan 和循环队列的内存。</p><h2 id="往-channel-发送数据"><a href="#往-channel-发送数据" class="headerlink" title="往 channel 发送数据"></a>往 channel 发送数据</h2><p>以下是往 channel 发送数据的语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Go">ch &lt;- <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>其对应源码如下（解释见注释）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// entry point for c &lt;- x from compiled code</span><br><span class="hljs-comment">//go:nosplit</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend1</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;<br>chansend(c, elem, <span class="hljs-literal">true</span>, getcallerpc())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-keyword">bool</span>, callerpc <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br>   <span class="hljs-comment">// 发送操作有个是否阻塞的判断，如果是非阻塞模式，直接返回false，不会被挂起（如果是select case 语句，block 就是 false）。</span><br><span class="hljs-keyword">if</span> !block &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">// waitReasonChanSendNilChan: &quot;chan send (nil chan)&quot;</span><br>gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>&#125;<br>   <span class="hljs-comment">// 非阻塞模式，缓冲区满了，直接返回false</span><br><span class="hljs-keyword">if</span> !block &amp;&amp; c.closed == <span class="hljs-number">0</span> &amp;&amp; full(c) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">var</span> t0 <span class="hljs-keyword">int64</span><br><span class="hljs-comment">// 控制协程信息的输出比例，具体可执行 go doc runtime.SetBlockProfileRate 看详细的解释。</span><br><span class="hljs-keyword">if</span> blockprofilerate &gt; <span class="hljs-number">0</span> &#123;<br>t0 = cputicks()<br>&#125;<br><br>lock(&amp;c.lock)<br>  <span class="hljs-comment">// 如果 channel 被关闭，抛出异常</span><br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;send on closed channel&quot;</span>))<br>&#125;<br>  <br>  <span class="hljs-comment">// 如果这会有正在等待接收数据的协程，则直接把数据传过去</span><br><span class="hljs-keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br>send(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br>  <span class="hljs-comment">// 如果缓冲队列还有空位，就把要发送的数据拷贝到 sendx 处</span><br><span class="hljs-keyword">if</span> c.qcount &lt; c.dataqsiz &#123;<br>qp := chanbuf(c, c.sendx)<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racenotify(c, c.sendx, <span class="hljs-literal">nil</span>)<br>&#125;<br>typedmemmove(c.elemtype, qp, ep)<br>c.sendx++<br><span class="hljs-keyword">if</span> c.sendx == c.dataqsiz &#123;<br>c.sendx = <span class="hljs-number">0</span><br>&#125;<br>c.qcount++<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">if</span> !block &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 如果缓冲区满了，将发送数据的协程挂起</span><br><span class="hljs-comment">// 构造一个 mysg:sudog(goroutine 的封装)</span><br>gp := getg()<br>mysg := acquireSudog()<br>mysg.releasetime = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> t0 != <span class="hljs-number">0</span> &#123;<br>mysg.releasetime = <span class="hljs-number">-1</span><br>&#125;<br><br>mysg.elem = ep<br>mysg.waitlink = <span class="hljs-literal">nil</span><br>mysg.g = gp<br>mysg.isSelect = <span class="hljs-literal">false</span><br>mysg.c = c<br>gp.waiting = mysg<br>gp.param = <span class="hljs-literal">nil</span><br><span class="hljs-comment">// 将发送协程放到发送队列中</span><br>c.sendq.enqueue(mysg)<br><br>atomic.Store8(&amp;gp.parkingOnChan, <span class="hljs-number">1</span>)<br>gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="hljs-number">2</span>)<br><br>KeepAlive(ep)<br><br><span class="hljs-comment">// 发送协程被唤醒</span><br><span class="hljs-keyword">if</span> mysg != gp.waiting &#123;<br>throw(<span class="hljs-string">&quot;G waiting list is corrupted&quot;</span>)<br>&#125;<br>gp.waiting = <span class="hljs-literal">nil</span><br>gp.activeStackChans = <span class="hljs-literal">false</span><br>closed := !mysg.success<br>gp.param = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> mysg.releasetime &gt; <span class="hljs-number">0</span> &#123;<br>blockevent(mysg.releasetime-t0, <span class="hljs-number">2</span>)<br>&#125;<br>mysg.c = <span class="hljs-literal">nil</span><br>releaseSudog(mysg)<br><span class="hljs-keyword">if</span> closed &#123;<br><span class="hljs-keyword">if</span> c.closed == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;chansend: spurious wakeup&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 如果不巧，channel 已经被关闭了，抛出异常</span><br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;send on closed channel&quot;</span>))<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不深究细节，只看流程，chansend 还比较好理解，只是 if 分支比较多，不容易厘清，可以对着下面的流程图一起看：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/16/chansend.png" alt="chansend"></p><h2 id="从-channel-接收数据"><a href="#从-channel-接收数据" class="headerlink" title="从 channel 接收数据"></a>从 channel 接收数据</h2><p>从 channel 接收数据的写法有两种：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Go">a := &lt;-ch<br>a, ok := &lt;-ch<br></code></pre></td></tr></table></figure><p>分别对应如下两个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// entry points for &lt;- c from compiled code</span><br><span class="hljs-comment">//go:nosplit</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv1</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;<br>chanrecv(c, elem, <span class="hljs-literal">true</span>)<br>&#125;<br><br><span class="hljs-comment">// 处理带 ok 的情形</span><br><span class="hljs-comment">//go:nosplit</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv2</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span> <span class="hljs-params">(received <span class="hljs-keyword">bool</span>)</span></span> &#123;<br>_, received = chanrecv(c, elem, <span class="hljs-literal">true</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这两个函数都是通过调用 chanrecv 实现（主要解释见注释）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-keyword">bool</span>)</span> <span class="hljs-params">(selected, received <span class="hljs-keyword">bool</span>)</span></span> &#123;<br><br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br>   <span class="hljs-comment">// 非阻塞模式下，直接返回false</span><br><span class="hljs-keyword">if</span> !block &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 否则挂起</span><br>gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>&#125;<br><br>  <span class="hljs-comment">// 非阻塞模式，且chanel缓冲队列为空的情况下，不涉及加锁解锁操作，故优先处理</span><br><span class="hljs-keyword">if</span> !block &amp;&amp; empty(c) &#123;<br><span class="hljs-keyword">if</span> atomic.Load(&amp;c.closed) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// empty 是在其它地方实现的，两种情况下会为true：</span><br><span class="hljs-comment">// 1) 无缓冲且无发送协程</span><br><span class="hljs-comment">// 2) 有缓冲但循环队列为空</span><br><span class="hljs-comment">// 故非阻塞情况下，可以直接返回false</span><br><span class="hljs-comment">// 这里channel已经被关闭，再次检查channel是否empty</span><br><span class="hljs-keyword">if</span> empty(c) &#123;<br>   <span class="hljs-comment">// 从关闭的channel中接收同样类型的零值</span><br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemclr(c.elemtype, ep)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> t0 <span class="hljs-keyword">int64</span><br><span class="hljs-keyword">if</span> blockprofilerate &gt; <span class="hljs-number">0</span> &#123;<br>t0 = cputicks()<br>&#125;<br><br>lock(&amp;c.lock)<br><br>  <span class="hljs-comment">// 阻塞模式下，如果channel已经被关闭，并且缓冲队列中为空</span><br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &amp;&amp; c.qcount == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquire(c.raceaddr())<br>&#125;<br>unlock(&amp;c.lock)<br><span class="hljs-comment">// 从关闭的channel中接收同样类型的零值</span><br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemclr(c.elemtype, ep)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span><br>&#125;<br>  <br>  <span class="hljs-comment">// 有等待的发送者，说明：</span><br>  <span class="hljs-comment">// 1) 无缓冲：直接将发送者的数据传给接收者</span><br>  <span class="hljs-comment">// 2) 缓冲已满：将队列首位数据给接收者，并将发送者的数据放到队列尾部</span><br>  <span class="hljs-comment">// 3) channnel 没有被关闭</span><br><span class="hljs-keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br>recv(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>&#125;<br><br>  <span class="hljs-comment">// 缓冲队列不为空</span><br>  <span class="hljs-comment">// 对recv而言，接下来只需要关心缓冲队列有没有元素，不需要关心channel有没有被关闭</span><br><span class="hljs-keyword">if</span> c.qcount &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Receive directly from queue</span><br>qp := chanbuf(c, c.recvx)<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racenotify(c, c.recvx, <span class="hljs-literal">nil</span>)<br>&#125;<br><span class="hljs-comment">// 将队列头部数据拷贝给接收者</span><br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemmove(c.elemtype, ep, qp)<br>&#125;<br><span class="hljs-comment">// 发送完之后，清空，同时 recv 往后挪一位</span><br>typedmemclr(c.elemtype, qp)<br>c.recvx++<br><span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;<br>c.recvx = <span class="hljs-number">0</span><br>&#125;<br>c.qcount--<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>&#125;<br><br>  <span class="hljs-comment">// 缓冲队列容量为0，且非阻塞，直接返回false</span><br><span class="hljs-keyword">if</span> !block &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 阻塞模式下，缓冲队列容量为0，将发送数据的协程挂起</span><br><span class="hljs-comment">// 构造一个 mysg:sudog(goroutine 的封装)</span><br>gp := getg()<br>mysg := acquireSudog()<br>mysg.releasetime = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> t0 != <span class="hljs-number">0</span> &#123;<br>mysg.releasetime = <span class="hljs-number">-1</span><br>&#125;<br><br>mysg.elem = ep<br>mysg.waitlink = <span class="hljs-literal">nil</span><br>gp.waiting = mysg<br>mysg.g = gp<br>mysg.isSelect = <span class="hljs-literal">false</span><br>mysg.c = c<br>gp.param = <span class="hljs-literal">nil</span><br>c.recvq.enqueue(mysg)<br><br>atomic.Store8(&amp;gp.parkingOnChan, <span class="hljs-number">1</span>)<br>gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 接收数据的协程被唤醒</span><br><span class="hljs-keyword">if</span> mysg != gp.waiting &#123;<br>throw(<span class="hljs-string">&quot;G waiting list is corrupted&quot;</span>)<br>&#125;<br>gp.waiting = <span class="hljs-literal">nil</span><br>gp.activeStackChans = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> mysg.releasetime &gt; <span class="hljs-number">0</span> &#123;<br>blockevent(mysg.releasetime-t0, <span class="hljs-number">2</span>)<br>&#125;<br>success := mysg.success<br>gp.param = <span class="hljs-literal">nil</span><br>mysg.c = <span class="hljs-literal">nil</span><br>releaseSudog(mysg)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, success<br>&#125;<br></code></pre></td></tr></table></figure><p>chanrecv 的 if 判断可以对着下面的流程图看：<br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/16/chanrecv.jpg" alt="chanrecv"></p><h2 id="close-一个-channel"><a href="#close-一个-channel" class="headerlink" title="close 一个 channel"></a>close 一个 channel</h2><p>关闭 一个 channel 的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">closechan</span><span class="hljs-params">(c *hchan)</span></span> &#123;<br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;close of nil channel&quot;</span>))<br>&#125;<br><br>lock(&amp;c.lock)<br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;close of closed channel&quot;</span>))<br>&#125;<br><br>c.closed = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">var</span> glist gList<br><br><span class="hljs-comment">// release all readers</span><br><span class="hljs-keyword">for</span> &#123;<br>sg := c.recvq.dequeue()<br><span class="hljs-keyword">if</span> sg == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> sg.elem != <span class="hljs-literal">nil</span> &#123;<br>   <span class="hljs-comment">// close之后，读到的都是零值</span><br>typedmemclr(c.elemtype, sg.elem)<br>sg.elem = <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;<br>sg.releasetime = cputicks()<br>&#125;<br>gp := sg.g<br>gp.param = unsafe.Pointer(sg)<br>sg.success = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquireg(gp, c.raceaddr())<br>&#125;<br>glist.push(gp)<br>&#125;<br><br><span class="hljs-comment">// release all writers (they will panic)</span><br><span class="hljs-keyword">for</span> &#123;<br>sg := c.sendq.dequeue()<br><span class="hljs-keyword">if</span> sg == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>sg.elem = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;<br>sg.releasetime = cputicks()<br>&#125;<br>gp := sg.g<br>gp.param = unsafe.Pointer(sg)<br>sg.success = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquireg(gp, c.raceaddr())<br>&#125;<br>glist.push(gp)<br>&#125;<br>unlock(&amp;c.lock)<br><br><span class="hljs-comment">// Ready all Gs now that we&#x27;ve dropped the channel lock.</span><br><span class="hljs-keyword">for</span> !glist.empty() &#123;<br>gp := glist.pop()<br>gp.schedlink = <span class="hljs-number">0</span><br>goready(gp, <span class="hljs-number">3</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>close 一个 channel 之前，如果这是 channel 是 nil 或者已经被 close ，则抛出异常。</p><p>接下来，close 的动作有三块：</p><p>1）修改 c.closed 标志位<br>2）唤醒所有读协程：读到的都是零值<br>3）唤醒所有写协程：chansend 中会抛出异常</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>粗略的过了一遍 channel 的源码，还是有不少细节没看明白，但是目前水平所限，只能看到这一步。期待对 Go 有了进一步的了解之后，再回过头来重温，能有新的认识。</p><p>下一期过一遍基于 channel 的几种并发模式。</p><p>就这样，下一期再见~</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>channel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#7——实证升级了！</title>
    <link href="/2021/05/06/invest-pratice-7/"/>
    <url>/2021/05/06/invest-pratice-7/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://afreecoder.cn/2020/07/18/invest-pratice-0/">财务自由实证#0——自由能实现吗？</a>。</p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更“美好”的事物上。</p><h2 id="准备换种方式来写实证"><a href="#准备换种方式来写实证" class="headerlink" title="准备换种方式来写实证"></a>准备换种方式来写实证</h2><p>五一假期已经过去一大半了，这个假期大家过的如何?</p><p>又到了写实证的时候，发现没太多东西可写。如果实证仅仅是记录一个数字，感觉意义不是很大。正好昨天看到<em>知行小酒馆</em>把之前对也大的一次访谈记录置顶了，就又重温了一遍。</p><p>这篇访谈中，也大强调了我们不应该被困在【<strong>等我自由了，我就如何如何</strong>】的假设里面，因为很多事情不需要等到自由，就可以开始行动。</p><p><strong>如果现在不做，那凭什么认为自由之后还会做呢？</strong></p><p>不是自由了才能怎样，而是做完了之后发现，自己离自由更近了一步。在追求自由的过程中，由于短期内市场的波动无法预测，财务计划的进展是不受控制的；但是为了追求自由所做的其它努力是可控，并且可以量化的。</p><p>因此经过思考，打算将该实证从单纯的财务实证<em>升级</em>为个人成长实证。格式上，固化以下三个模块：</p><p><strong>实证进展</strong></p><ul><li>虽然进展不可控，但是数字还是最直接的体现，所以这部分仍然保留。</li></ul><p><strong>本月回顾</strong></p><ul><li>该部分用于回顾本月计划完成情况。</li></ul><p><strong>下月计划</strong></p><ul><li>该部分用于规划下个月需要完成的任务。</li></ul><p>嗯，也好给年底的年终总结提供素材[\机智]</p><h2 id="实证进展"><a href="#实证进展" class="headerlink" title="实证进展"></a>实证进展</h2><p>本月进展如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/16199486555411.jpg" alt="-w414"></p><p>当前进展 2.46%，相比上个月增加了 0.2%，终于有了肉眼可变的变化了，喜极而泣~</p><p>其实在春节附近，就曾经达到过这个数字，后来市场急剧向下，花了2个多月的时间才再次站上了这个高点。</p><p>本月特殊操作：无。</p><h2 id="合理的家庭资产配置"><a href="#合理的家庭资产配置" class="headerlink" title="合理的家庭资产配置"></a>合理的家庭资产配置</h2><p>这是一个老生常谈的话题，很多文章都写过如何对家庭资产进行一个合理的配置，在我之前的文章 <a href="https://afreecoder.cn/2020/10/10/invest-pratice-1/">财务自由实证#1——如何开始？</a> 中也提到过。</p><p>一般而言，一个合理的家庭资产配置方向大致如下：</p><ul><li>规划紧急备用金：活钱</li><li>规划必要的保险：风险杠杆</li><li>规划3年内要用的钱：短期存款、债券</li><li>规划长期要用的钱：股票、基金等</li></ul><p>之所以再把这个话题拿出来说，是因为最近这个月的经历让我对这个<strong>看似普通</strong>的配置方案有了新的认识。</p><p>3月底的时候，刚好有一个朋友因为买房，首付还差一点，借了一些；紧接着，4月底，摇号意外中签。</p><p>借的那部分对应的是活钱，中签这个对应的是3年内要用的钱。短短一个月内，这两笔钱都派上了用场。</p><blockquote><p>有知有行的温度计：13℃，这意味着市场再次到达了一个黄金位置。</p></blockquote><p>如果最开始没有严格分配4笔钱，而是都放到长期组合中，现在就会十分被动，不得不<strong>忍痛割肉</strong>。</p><p>之前对这个家庭资产配置方案的理解比较肤浅，这次的经历让我开始从另一个角度来理解这个方案。</p><p>在之前的认知中，我认为4笔钱的地位是相等的，只是场景不同，实际上并不是。</p><p>根据墨菲定律:</p><blockquote><p>如果坏事有可能发生，不管这种可能性有多小，它总会发生，并造成最大可能的破坏。</p></blockquote><p>前3笔钱的使用场景相对于4而言，就是<strong>坏事</strong>。一旦<strong>坏事</strong>发生，最大的破坏就是长期计划无法执行，功亏一篑。</p><p>这个方案的目的不是为了应对平时零用，也不是为了应对可能的大病，更不是为了应对3年内的大额支出，而是为了实现资产的最终增值。也就是说，前3笔的配置都是为了确保第4笔钱在增值的过程中不受到任何干扰。</p><h2 id="4月回顾"><a href="#4月回顾" class="headerlink" title="4月回顾"></a>4月回顾</h2><p><strong>写作</strong></p><p>本月一共写了三篇文章，一篇 Go 的，两篇投资理财相关的。数量上严重不达标。。</p><p>不过 <a href="https://afreecoder.cn/2021/05/06/定投的陷阱/">定投的“陷阱” </a> 这一篇的数据很好看，阅读、点赞、在看分别是383、22、15，三个数据都是历史新高，说明花心思写还是有用的！</p><p><strong>个人项目</strong></p><p>4月份完成了公众号服务端Demo的开发以及服务的部署，项目地址见：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://github.com/AFreeCoder/wechat-official-account<br></code></pre></td></tr></table></figure><p>现在还只是一个Demo，刚跑通了流程，效果如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/16201088646753.jpg" alt="-w414"></p><p>有了这个作为基础，后面的基金入门知识的 QABot 可以提上日程了。</p><h2 id="5月计划"><a href="#5月计划" class="headerlink" title="5月计划"></a>5月计划</h2><p><strong>写作</strong></p><ul><li>完成《Go 并发编程实战》channel 部分文章的输出，数量&gt;=4</li><li>完成行业指数、国外主流指数相关文章的输出，同时开始温度计的调研，数量&gt;=4</li></ul><p><strong>个人项目</strong></p><ul><li>语料库存储方案调研，完成一篇调研</li><li>根据历史文章，完成基金入门知识语料的整理，待整理文章6篇</li></ul><p>就这样，期待5月底的实证~~</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定投的“陷阱”</title>
    <link href="/2021/05/06/%E5%AE%9A%E6%8A%95%E7%9A%84%E9%99%B7%E9%98%B1/"/>
    <url>/2021/05/06/%E5%AE%9A%E6%8A%95%E7%9A%84%E9%99%B7%E9%98%B1/</url>
    
    <content type="html"><![CDATA[<p>不知道从什么时候开始，每当基金行情火爆的时候，各种自媒体文章都开始贩卖理财焦虑，套路都是职场某不起眼的同事A，通过理财获得了远超工资的睡后收入，劝你不要在傻傻的挣死工资了！</p><p>那同事A是怎么理财的呢？答案都是定投。</p><p>接着，这些文章会用爱因斯坦的那句名言“复利是这个世界上的第八大奇迹”开头，然后假设每月定投500，年化利率20%，定投30年，你就会有1000多万啦。</p><p>可是，定投真有这么神奇吗？</p><h2 id="定投真的是“无所不能”的吗？"><a href="#定投真的是“无所不能”的吗？" class="headerlink" title="定投真的是“无所不能”的吗？"></a>定投真的是“无所不能”的吗？</h2><p>如果定投的威力真的有这么大，那我们所有人都进行定投，50年后，地球上的财富还够分吗？</p><p>在知乎上搜索关键词：定投，会出来很多问题，除了一些说定投有多好的话题外，还有很多问题对定投充满了疑惑，比如下面这些问题：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">长期定投基金是骗局吗？<br>基金定投一定赚钱吗？<br>在支付宝买定投基金1年半了，越定投亏越多，怎么办？<br></code></pre></td></tr></table></figure><p>显然，仍有很多人对定投充满了疑惑，觉得一个普普通通的定投怎么可能赚很多呢？</p><p>这是因为很多文章在解释基金定投的时候，都会犯一个错误，就是将名义利率当成实际利率来计算，从而忽略了基金增长过程中的波动情况。</p><p>举个例子，某基金的初始净值是1，25年后期末净值是32.9，倒推该基金的年化收益率是15%，但是如果你定投这个基金，能用15%来推算预期收益吗，显然不行。</p><p>下面我用<strong>三种增长曲线假设</strong>来解释，不同的增长曲线下，收益差距是有多么夸张！</p><h3 id="步步高升"><a href="#步步高升" class="headerlink" title="步步高升"></a>步步高升</h3><p>第一种假设我把它叫做<strong>步步高升</strong>，意思是基金的走势完美的符合复利增长的曲线，示意图如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/jie-ping20210404-142145.png" alt="截屏2021-04-04 14.21.45"></p><p>如果定投增长曲线如图所示的基金，25年和30年的收益情况如下：</p><div class="table-container"><table><thead><tr><th>期限（年）</th><th>净投入</th><th>期末资产</th><th>总收益率</th><th>平均年化收益率</th></tr></thead><tbody><tr><td>25</td><td>300000</td><td>3243529</td><td>980%</td><td>15%</td></tr></tbody></table></div><p>显然，标准走势下，如果我们定投该基金，是能获得期望的收益的。</p><h3 id="出道即巅峰"><a href="#出道即巅峰" class="headerlink" title="出道即巅峰"></a>出道即巅峰</h3><p>第二种假设我把它叫做<strong>出道即巅峰</strong>。意思是基金一发行就遇到了大牛市，净值一飞冲天，之后的多年都没有什么变化，它的增长曲线示例如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/jie-ping20210404-143529.png" alt="截屏2021-04-04 14.35.29"></p><p>如果定投增长曲线如图所示的基金，收益情况如下表所示：</p><div class="table-container"><table><thead><tr><th>期限（年）</th><th>净投入</th><th>期末资产</th><th>总收益率</th><th>平均年化收益率</th></tr></thead><tbody><tr><td>25</td><td>300000</td><td>331900</td><td>10.63%</td><td>0.8%</td></tr></tbody></table></div><p>出道即巅峰这种走势下，平均年化收益率才0.8%，还不如货币基金的年化收益率，收益情况远远不达预期。</p><h3 id="大器晚成"><a href="#大器晚成" class="headerlink" title="大器晚成"></a>大器晚成</h3><p>第三种假设我把它叫做<strong>大器晚成</strong>。意思是基金发行之后一直是熊市，直到25年期末才忽然暴涨，它的增长曲线示例如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/jie-ping20210404-144103.png" alt="截屏2021-04-04 14.41.03"></p><p>如果定投增长曲线如图所示的基金，收益情况如下表所示：</p><div class="table-container"><table><thead><tr><th>期限（年）</th><th>净投入</th><th>期末资产</th><th>总收益率</th><th>平均年化收益率</th></tr></thead><tbody><tr><td>25</td><td>300000</td><td>9870000</td><td>3190%</td><td>22.86%</td></tr></tbody></table></div><p>大器晚成这种走势下，总收益率达到了3190%，平均年化收益率达到了22.86%，远远超过了预期！</p><h2 id="真实市场回测"><a href="#真实市场回测" class="headerlink" title="真实市场回测"></a>真实市场回测</h2><p>真实的基金走势并不会像上面三种假设那样极端，但是通过这三种极端假设，我们仍然能得出一个结论：简单的定投并不一定能让我们获得预期的收益，还是得看真实的基金走势如何。</p><p>更何况，基金的真实波动远比这三种假设复杂很多，也更难预测的多。</p><p>回到真实环境中，我们可以用沪深300做一个简单的回测。沪深300的指数基日是2004年12月31日，基点1000，截止2021年4月2号，收盘指数值是5161.56，对应的平均年化收益率是10.53%</p><p>如果采取每月定投1000的方式定投沪深300ETF，最终收益如下：</p><div class="table-container"><table><thead><tr><th>期限（年）</th><th>净投入</th><th>期末资产</th><th>总收益率</th><th>平均年化收益率</th></tr></thead><tbody><tr><td>16年零5个月</td><td>197000</td><td>408,658</td><td>107.44%</td><td>8.41%</td></tr></tbody></table></div><p>定投的实际年化收益率是8.41%，比指数的年化收益率低一些，不过也还不错了。</p><h2 id="定投还有必要吗？"><a href="#定投还有必要吗？" class="headerlink" title="定投还有必要吗？"></a>定投还有必要吗？</h2><p>上面啰啰嗦嗦说了那么多，其实就想说明一件事，定投的收益不能简简单单的用平均年化收益率来衡量。</p><p>那定投的意义是什么呢？我认为主要三点，分别是：</p><ul><li>强制储蓄</li><li>降低风险</li><li>帮助投资者完成投资理财入门教育</li></ul><p><strong>强制储蓄</strong></p><p>定投这个概念最初源于美国，后经过不断发展，最终催生了401K退休计划。对应到国内，就是我们的社保（养老金）。我们每个月交的养老金其实就相当于定投，只是决定投资标的的是国家社保基金。</p><p>上班族最大的特点就是本金不多，但是有源源不断的收入作为现金流。故而通过定投这种方式能够实现强制储蓄的效果，同时还能分享部分经济发展的红利。</p><p><em>注：401K计划是美国养老保险的一部分：企业年金部分。按该计划，企业为员工设立专门的401K账户，员工每月从其工资中拿出一定比例的资金存入养老金账户（企业也会投入一定比例），企业向员工提供3到4种不同的证券组合投资计划。员工可任选一种进行投资。员工退休时，可以选择一次性领取、分期领取和转为存款等方式使用。</em></p><p><strong>降低风险</strong></p><p>虽然定投是因为没有多少本金而选择的无奈之举，但是这也避免了集中投资下风险过大的问题。</p><p>从一个较长的时间跨度来看，只要坚持定投，哪怕开始投资的时候是牛市顶点，也能通过后续的投入不断摊低成本，从而提高盈利的概率。</p><p><strong>帮助投资者完成投资理财入门教育</strong></p><p>证券市场不是取款机，股市七亏二平一赚也不是什么调侃，能盈利的始终是少数。很多投资者在没有完成基本的理论学习和实践之前，就拿着多年积蓄，一股脑的冲进去，最终亏了个精光。</p><p>定投是定期定额投入，即使出现亏损，一是亏不了多少，二是不会影响日常生活，反而能让投资者静下心来研究基本理论，找到适合自己的策略，同时养成良好的投资心态。</p><p>从以上这三点来看，尽管定投并没有许多自媒体吹嘘的那么强，但确实是普通投资者尤其是上班族入门投资的比较好的一种方式。</p><h2 id="我有一个想法"><a href="#我有一个想法" class="headerlink" title="我有一个想法"></a>我有一个想法</h2><p>说点其它的。</p><p>看过这个系列第一篇 <a href="https://afreecoder.cn/2020/07/18/invest-pratice-0/">《财务自由实证#0——自由能实现吗？》</a> 的读者们都知道，我对这个实证计划的预期年化收益率是15%。这是一个相对乐观但还算合理的目标。</p><p>现阶段我实现这个目标的方式是跟投知名的组合，虽然我个人比较喜欢这种方式，但是这种方式也有两个缺点：</p><p><strong>1. 组合的生命周期无法保证。</strong></p><p>组合的存在与否很大程度上由主理人主观决定，跟投者只能被动接受。我信任长赢计划，然而谁能保证它还有下一轮呢？</p><p><strong>2. 策略不透明。</strong></p><p>虽然每个组合都有其投资策略的介绍，但是策略的细节仍然是不透明的；而且具体到每一次的操作上，我们也无法判断主理人是否完美的执行了该策略。</p><p>本着“自主可控”的原则，打算捡起去年的想法，开发一些简单但有效的投资策略，构建属于自己的投资组合，在实践中加快自己投资体系的建立。</p><p>由于深知“闭门造车”的弊端，所以借这篇文章推广一下：</p><p>如果你也对构建自己的投资策略也感兴趣，欢迎私信（公众号回复【搞事情】），一起搞事情！</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>定投</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 并发基石之 channel（一）</title>
    <link href="/2021/05/02/go-channel-1/"/>
    <url>/2021/05/02/go-channel-1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Go 并发系列是根据我对晁岳攀老师的《Go 并发编程实战课》的吸收和理解整理而成，如有偏差，欢迎指正~</p></blockquote><p>作为 Go 的核心数据结构以及 goroutine 之间的通信方式，channel 是支撑 Go 语言高性能并发编程模型的重要数据结构。</p><p>学习 Go，channel 是无论如何都无法绕过的特性。因此本篇就和大家一起看下 channel 的由来、基本用法以及常犯的一些错误。</p><h2 id="1-channel-的发展"><a href="#1-channel-的发展" class="headerlink" title="1. channel 的发展"></a>1. channel 的发展</h2><p>要了解 channel 的设计思想，就得追溯到 CSP 理论。</p><p>CSP 是 Communication Sequential Process 的简称，最早由计算机科学家 Tony Hoare 在 1978 年发表的同名论文提出。最开始的 CSP 其实是一种并发编程语言，之后经过一系列发展和演化，才变成了现在的 CSP 理论。</p><p>作者认为，并发场景中，<strong>输入</strong>和<strong>输出</strong>是被忽略的两个原语。在最初的 CSP 中，Hoare 创造了 <strong>!</strong> 和 <strong>?</strong> 命令，分别表示输入和输出，并展示了如何用通信的方式来解决并发问题！</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/16/16198628955968.jpg" alt="-w1047"></p><p>在上图的最后一个例子中，描述了从 west 进程不断读取字符到变量 c 并发送给 east 进程的通信过程。</p><p>此外，CSP 中还使用了守护命令 <strong>—&gt;</strong>，命令左边的语句是 false 或者退出，那么命令的右边就不会执行。</p><p>这和 channel 的用法是何其的相似！</p><p>CSP 描述了一种多个任务之间通过通信来进行信息交互的处理问题的方案，这也构成了 Go 并发哲学的基础。</p><h2 id="2-channel-和-sync"><a href="#2-channel-和-sync" class="headerlink" title="2. channel 和 sync"></a>2. channel 和 sync</h2><p>前面一系列的文章介绍了 Go sync 包下的并发原语，如 Mutex，WaitGroup，Once，Cond 等。在 Go 中，它们和 channel 其实是竞争关系。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/16/channel-hesync.jpg" alt="channel和sync"></p><blockquote><p>Don’t communicate by sharing memory, share memory by communicating.</p></blockquote><p>学习 Go 的过程中，总是时不时的看到这句话。直白的翻译就是：不要通过共享内存来通信，而要通过通信来共享内存。</p><p>sync 和 channel 就分别代表了这两种解决并发问题的方式。</p><p>以最常见的计数器为例，看一下这两种方式分别是如何处理的。</p><h3 id="1-sync-的解决方案"><a href="#1-sync-的解决方案" class="headerlink" title="1) sync 的解决方案"></a>1) sync 的解决方案</h3><p>sync 的解决方式很直观，就是通过 Mutex 来确保同一时刻只有一个 goroutine 在修改数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">//countByShareMemory</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countByShareMemory</span><span class="hljs-params">()</span></span> &#123;<br>count := <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> w sync.WaitGroup <span class="hljs-comment">// 用于确保100个 goroutine 都执行完毕</span><br><span class="hljs-keyword">var</span> m sync.Mutex<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>w.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>m.Lock()<br><span class="hljs-keyword">defer</span> w.Done()<br><span class="hljs-keyword">defer</span> m.Unlock()<br>count++<br>&#125;()<br>&#125;<br>w.Wait()<br>fmt.Println(count)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-channel-的解决方案"><a href="#2-channel-的解决方案" class="headerlink" title="2) channel 的解决方案"></a>2) channel 的解决方案</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// countByCommunicating</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countByCommunicating</span><span class="hljs-params">()</span></span> &#123;<br>w := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">100</span>) <span class="hljs-comment">// 用于确保100个 goroutine 都执行完毕</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">1</span>)<br>ch &lt;- <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> count := &lt;-ch:<br>ch &lt;- count + <span class="hljs-number">1</span><br>&#125;<br>w &lt;- <span class="hljs-number">0</span><br>&#125;()<br><br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>&lt;-w<br>&#125;<br>fmt.Println(&lt;-ch)<br>&#125;<br></code></pre></td></tr></table></figure><p>并发场景下，需要保证 count++ 操作的原子性，也就是 count 变量独占权的问题。sync.Mutex 的解决方案中，通过<strong>互斥锁</strong>保证同一时刻只有一个 goroutine 对count 拥有所有权；channel 的解决方案中，则是通过管道<strong>转移</strong>对 count 的所有权。</p><h3 id="3-如何选择-sync-和-channel"><a href="#3-如何选择-sync-和-channel" class="headerlink" title="3) 如何选择 sync 和 channel"></a>3) 如何选择 sync 和 channel</h3><p>尽管 Go 的设计者极力推荐使用 CSP 的方式来解决并发问题，但是 CSP 只是解决并发安全问题的其中一种途径，在某些场景，还是要具体问题具体分析。</p><p>该课程中给出的建议如下：</p><ul><li>共享资源的并发访问使用传统并发原语；</li><li>复杂的任务编排和消息传递使用 Channel；</li><li>消息通知机制使用 Channel，除非只想 signal 一个 goroutine，才使用 Cond；</li><li>简单等待所有任务的完成用 WaitGroup，也有 Channel 的推崇者用 Channel，都可以；</li><li>需要和 Select 语句结合，使用 Channel；</li><li>需要和超时配合时，使用 Channel 和 Context。</li></ul><h2 id="3-channel-的基本用法"><a href="#3-channel-的基本用法" class="headerlink" title="3. channel 的基本用法"></a>3. channel 的基本用法</h2><p>你既可以往 channel 中发送数据，也可以从 channel 中接收数据，所以，channel 的类型有如下三种：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">chan</span>    <span class="hljs-comment">// 既可以发送数据，又可以接收数据的 channel</span><br><span class="hljs-keyword">chan</span>&lt;-  <span class="hljs-comment">// 只能接收数据的 channel</span><br>&lt;-<span class="hljs-keyword">chan</span>  <span class="hljs-comment">// 只能发送数据的 channel</span><br></code></pre></td></tr></table></figure><p>channel 是管道，因此一个传输具体类型数据的 channel 声明方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>      <span class="hljs-comment">// 既可以往 ch 中写，也可以从 ch 中读 string 类型数据</span><br><span class="hljs-keyword">var</span> ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">struct</span>&#123;&#125;  <span class="hljs-comment">// 只能往 ch 中发送 struct&#123;&#125; 类型数据</span><br><span class="hljs-keyword">var</span> ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>       <span class="hljs-comment">// 只能从 ch 中读取 int 数据</span><br></code></pre></td></tr></table></figure><p>channel 的初始化和 slice 类似，都是使用关键字 make，未初始化的 channel 零值是 nil。具体的声明方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>其中 5 是 channel 的容量。也可以不指定 channel 的容量，即容量为 0，这样的 channel 一般叫做 unbuffered channel。</p><h3 id="1-发送数据"><a href="#1-发送数据" class="headerlink" title="1) 发送数据"></a>1) 发送数据</h3><p>往 channel 中发送数据使用 “ch&lt;-“，示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Go">ch &lt;- <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>这里的 ch 的类型是 <code>chan int</code> 或者 <code>chan&lt;- int</code>。</p><h3 id="2-接收数据"><a href="#2-接收数据" class="headerlink" title="2) 接收数据"></a>2) 接收数据</h3><p>从 channel 中接收数据使用 “&lt;-ch”，示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go">x := &lt;-ch  <span class="hljs-comment">// 把 ch 中接收到的一条数据赋值给 x</span><br>foo(&lt;-ch) <span class="hljs-comment">// 把 ch 中接收到的一条数据作为函数 foo 的参数</span><br>&lt;-ch      <span class="hljs-comment">// 丢弃一条从 ch 中接收到的数据</span><br></code></pre></td></tr></table></figure><p>从 channel 中接收数据的时候，还可以接收两个值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Go">x, ok := &lt;-ch<br></code></pre></td></tr></table></figure><p>ok 是一个 bool 值，表示是否成功的从 channel 中接收到了数据。如果 ok 是 false，ch 已经被 close，且 ch 中没有缓存数据，那么 x 就是零值。所以，如果 x 是零值，有可能是接收到了零值，也有可能是空的且被 close 的 channel 产生的零值。</p><h3 id="3-其它操作"><a href="#3-其它操作" class="headerlink" title="3) 其它操作"></a>3) 其它操作</h3><p>Go 的内建函数 close、cap、len 都可以操作 channel。close 可以关闭 channel，关闭之后的 channel 无法接收数据；cap 返回 channel 的容量；len 返回 channel 的长度。</p><p>发送和接收数据还可以作为 select 语句的 case clause，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> ch &lt;- i:<br>        <span class="hljs-keyword">case</span> v := &lt;-ch:<br>            fmt.Println(v)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>channel 还可以用于 for-range 语句中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123;<br>    fmt.Println(v)<br>&#125;<br></code></pre></td></tr></table></figure></p><p>或者是忽略读取的值，只是清空 channel：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> ch &#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>到这里，channel 的基本用法就介绍完了，下面说几种使用 channel 过程中常见的错误。</p><h2 id="4-使用-channel-常见的错误"><a href="#4-使用-channel-常见的错误" class="headerlink" title="4. 使用 channel 常见的错误"></a>4. 使用 channel 常见的错误</h2><p>使用 channel 最常见的错误就是 panic 和 goroutine 泄露。</p><h3 id="1-panic-错误"><a href="#1-panic-错误" class="headerlink" title="1) panic 错误"></a>1) panic 错误</h3><p>常见的会导致 panic 的三种场景如下：</p><ul><li>close 为 nil 的 channel</li><li>send 已经 close 的 channel</li><li>recv 已经 close 的 channel</li></ul><h3 id="2-goroutine-泄露"><a href="#2-goroutine-泄露" class="headerlink" title="2) goroutine 泄露"></a>2) goroutine 泄露</h3><p>这里的泄露指的是 channel 阻塞导致 goroutine 一直无法退出的情况。下面是课程中的一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(timeout time.Duration)</span> <span class="hljs-title">bool</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 模拟处理耗时的业务</span><br>        time.Sleep((timeout + time.Second))<br>        ch &lt;- <span class="hljs-literal">true</span> <span class="hljs-comment">// block</span><br>        fmt.Println(<span class="hljs-string">&quot;exit goroutine&quot;</span>)<br>    &#125;()<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> result := &lt;-ch:<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">case</span> &lt;-time.After(timeout):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该示例中，假设业务处理的时间大于超时时间，故 select 语句先接收超时的信号，返回 false，这导致第 7 行一直阻塞，goroutine 无法退出，进而造成泄露。</p><p>出现这种情况的原因是第二行初始化的 ch 是一个 unbuffered channel，向 unbuffered channel 发送数据的时候，由于容量为 0，必须同时存在接收方接收数据，发送方才能将数据发送出去，否则只能阻塞。</p><p>改进的方式也很简单，ch 初始化的时候，指定容量为 1 就行。</p><h2 id="5-结尾"><a href="#5-结尾" class="headerlink" title="5. 结尾"></a>5. 结尾</h2><p>这一篇，简单的介绍了 channel 的由来以及它的一些基本用法。CSP 理论那其实没怎么讲清楚，只是搬运了《Concurrency in Go》关于 CSP 的一些介绍，短期内也不打算深究，能明白大概意思就行。</p><p>下一篇，尝试写一下 channel 源码解析。</p><p>大家五一假期快乐~~</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>channel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次学习 orDone 模式爬坑经历</title>
    <link href="/2021/04/25/go-or-done/"/>
    <url>/2021/04/25/go-or-done/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Go 并发系列是根据我对晁岳攀老师的《Go 并发编程实战课》的吸收和理解整理而成，如有偏差，欢迎指正~</p></blockquote><p>看了下上次 Go 技术学习的文章 《Go 并发之原子操作 atomic》发布时间: 3月27，一个月之前。再想一想最初立的 flag：每周一篇 Go 技术学习的文章。霍，脸真疼！</p><p>最近在看 channel 。作为 Go 核心的数据结构和 goroutine 之间的通信方式，channel 是支撑 Go 语言高性能并发编程模型的重要数据结构。</p><p>今天就来聊一聊 channel 实现的 Go 的并发模式 orDone 以及我在学习这个模式中不断跳坑出坑的经历。</p><h2 id="任务编排之-orDone-模式"><a href="#任务编排之-orDone-模式" class="headerlink" title="任务编排之 orDone 模式"></a>任务编排之 orDone 模式</h2><p>先介绍一下 orDone 模式。</p><p>orDone 模式是信号通知模式中应用比较广泛的一种模式。</p><p>什么是信号通知模式呢？信号通知模式实现了某个任务执行完成后的通知机制。在实现的时候，通常使用 channel strcut{} 类型，如果任务完成就 close 这个 channel，其它 receiver 就会收到这个信号。</p><p>orDone 模式是说我们有一个任务可以发送给 n 个处理方来执行，只要有一个处理方完成，就返回任务完成的信号。</p><p>如果 n 已知，实现方式很简单，用 select-case 语句就行。但是有些时候，你并不知道有多少个处理者，有可能是10个，也有可能是100个，所以没办法直接使用 select-case 。</p><p>在 《Go 并发编程实战》的 channel 相关的章节中，orDone 模式的代码实现如下（这段代码其实是有问题的，后面会说）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">or</span><span class="hljs-params">(channels ...&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>    <span class="hljs-comment">// 特殊情况，只有零个或者1个chan</span><br>    <span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(channels) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> channels[<span class="hljs-number">0</span>]<br>    &#125;<br><br>    orDone := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(orDone)<br><br>        <span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(channels) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">// 2个也是一种特殊情况</span><br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">0</span>]:<br>            <span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">1</span>]:<br>            &#125;<br>        <span class="hljs-keyword">default</span>: <span class="hljs-comment">//超过两个，二分法递归处理</span><br>            m := <span class="hljs-built_in">len</span>(channels) / <span class="hljs-number">2</span><br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-or(channels[:m]...):<br>            <span class="hljs-keyword">case</span> &lt;-or(channels[m:]...):<br>            &#125;<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">return</span> orDone<br>&#125;<br></code></pre></td></tr></table></figure><p>该示例代码中，采取二分递归的方式来监听任务的完成信号。</p><p>附带测试代码如下 ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sig</span><span class="hljs-params">(after time.Duration)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(c)<br>        time.Sleep(after)<br>    &#125;()<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    start := time.Now()<br><br>    &lt;-or(<br>        sig(<span class="hljs-number">20</span>*time.Second),<br>        sig(<span class="hljs-number">10</span>*time.Second),<br>        sig(<span class="hljs-number">30</span>*time.Second),<br>        sig(<span class="hljs-number">40</span>*time.Second),<br>        sig(<span class="hljs-number">50</span>*time.Second),<br>        sig(<span class="hljs-number">01</span>*time.Minute),<br>    )<br><br>    fmt.Printf(<span class="hljs-string">&quot;done after %v&quot;</span>, time.Since(start))<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果完美符合预期，10s 之后，printf 语句成功打印。</p><h2 id="问题1：goroutine-泄露问题"><a href="#问题1：goroutine-泄露问题" class="headerlink" title="问题1：goroutine 泄露问题"></a>问题1：goroutine 泄露问题</h2><p>上面的代码乍看之下很合理，但是仔细想一想，却有两个问题：</p><ol><li>变量 orDone 在函数中的作用到底是什么？ </li><li>case 2 所说的特殊情况到底是什么？能否在 case 2 处就递归？</li></ol><p>带着这两个问题，一顿搜索，搜到了《Concurrency in Go》这本书。在这本书中，orDone 模式的代码示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">or</span><span class="hljs-params">(channels ...&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123; <span class="hljs-comment">//1</span><br><br><span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(channels) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">//2</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">//3</span><br><span class="hljs-keyword">return</span> channels[<span class="hljs-number">0</span>]<br>&#125;<br><br>orDone := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//4</span><br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(orDone)<br><br><span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(channels) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">//5</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">0</span>]:<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">1</span>]:<br>&#125;<br><span class="hljs-keyword">default</span>: <span class="hljs-comment">//6</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">0</span>]:<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">1</span>]:<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">2</span>]:<br><span class="hljs-keyword">case</span> &lt;-or(<span class="hljs-built_in">append</span>(channels[<span class="hljs-number">3</span>:], orDone)...): <span class="hljs-comment">//6</span><br>&#125;<br>&#125;<br>&#125;()<br><span class="hljs-keyword">return</span> orDone<br>&#125;<br></code></pre></td></tr></table></figure><p>对比发现，这两种写法最主要的一个区别就是变量 orDone 有没有作为参数传递给子函数中。</p><p>在 or 函数执行结束前，orDone 会被 close，递归子函数的 case 分支接收到这个信号后，在立即退出的同时会将新 orDone 的 close 信号传递给它的递归子函数。也就是说，变量 orDone 的作用是用来通知其它协程退出。</p><p>在《Concurrency in Go》一书中，有如下解释：</p><blockquote><p>Here we recursively create an or-channel from all the channels in our slice after the third index, and then select from this. This recurrence relation will destructure the rest of the slice into or-channels to form a tree from which the first sig‐ nal will return. <strong>We also pass in the orDone channel so that when goroutines up the tree exit, goroutines down the tree also exit</strong>.</p></blockquote><p>到这里，基本可以确认，晁老师的二分递归版本的代码是有问题的。这个版本没有传递 orDone 信号，通知其它协程退出，<strong>会造成 goroutine 泄露问题</strong>！</p><p>谨慎起见，我还是大胆的联系了晁老师，进行确认。</p><p><em>注：为了方便起见，下文中用二分递归版代指晁老师的代码示例，用直接递归版代指《Concurrency in Go》中的示例。</em></p><h2 id="问题2：slice-切片问题"><a href="#问题2：slice-切片问题" class="headerlink" title="问题2：slice 切片问题"></a>问题2：slice 切片问题</h2><p>在和晁老师确认的过程中，我先根据自己的理解，对他的代码进行了一番修改，改动点（default 分支）如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">default</span>: <span class="hljs-comment">//超过两个，二分法递归处理</span><br>    m := <span class="hljs-built_in">len</span>(channels) / <span class="hljs-number">2</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-or(<span class="hljs-built_in">append</span>(channels[:m], orDone)...):<br>    <span class="hljs-keyword">case</span> &lt;-or(<span class="hljs-built_in">append</span>(channels[m:], orDone)...):<br>    &#125;<br></code></pre></td></tr></table></figure><p>用上文的测试代码测试发现，程序在30s末的时候，才执行了 print 语句，不符合预期！</p><p>这个时候，晁老师回复了，先是夸了一通我看的仔细，然后确认这个地方确实遗漏了 orDone 信号的传递，并给出了修改版代码，改动如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">default</span>:<br>    m := <span class="hljs-built_in">len</span>(channels) / <span class="hljs-number">2</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-or(<span class="hljs-built_in">append</span>(channels[:m:m], orDone)...): <span class="hljs-comment">// must append orDone to avoid leak!!!!</span><br>    <span class="hljs-keyword">case</span> &lt;-or(<span class="hljs-built_in">append</span>(channels[m:], orDone)...):<br>    &#125;<br></code></pre></td></tr></table></figure><p>我一看，这不和我改的一样嘛。再一想，晁老师不可能未经测试就给出代码，于是我跑了一遍测试代码，不出所料，这个结果是正确的！</p><p>问题出在哪呢？</p><p>逐字对比后，发现这两份代码在 slice 切片上有细微差别。晁老师版本指定了切片容量 m。</p><p>经过一番查阅，发现 slice 切片的时候，如果不指定容量，直接 append，仍然会对底层的 slice 产生影响。这里的影响就是 channels[m:] 的第一个元素 sig(10*time.Second) 被 orDone 覆盖了。</p><p><strong>注：slice 切片的知识点其实很基础，各位读者稍微一搜就知道，我就不详细介绍了，不要像我一样犯这个错误😂。</strong></p><h2 id="问题3：二分递归无法退出问题"><a href="#问题3：二分递归无法退出问题" class="headerlink" title="问题3：二分递归无法退出问题"></a>问题3：二分递归无法退出问题</h2><p>到这里，问题已经得到了解决，接下来的剧情本应是和大佬客气几句然后愉快的结束讨论，继续接下来的学习。</p><p>但是！转折来了！</p><p>在执行二分递归版代码的过程中，电脑的风扇总是发出“呼呼”的噪音，而执行直接递归版代码的时候，就没有这个问题。</p><p>似乎有哪里不对🤔？</p><p>带着这个疑问，我写了下面的测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>start := time.Now()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>time.Sleep(time.Second)<br>fmt.Println(<span class="hljs-string">&quot;任务进行中，当前协程数:&quot;</span>, runtime.NumGoroutine())<br>&#125;()<br><span class="hljs-comment">//测试 orDone 模式</span><br>&lt;-or(<br>sig(<span class="hljs-number">20</span>*time.Second),<br>sig(<span class="hljs-number">10</span>*time.Second),<br>sig(<span class="hljs-number">30</span>*time.Second),<br>sig(<span class="hljs-number">40</span>*time.Second),<br>sig(<span class="hljs-number">50</span>*time.Second),<br>sig(<span class="hljs-number">01</span>*time.Minute),<br>)<br>fmt.Printf(<span class="hljs-string">&quot;done after %v\n&quot;</span>, time.Since(start))<br>fmt.Println(<span class="hljs-string">&quot;任务结束后，当前协程数:&quot;</span>, runtime.NumGoroutine())<br>&#125;<br></code></pre></td></tr></table></figure><p><em>注：sig 函数的实现和原来一样。</em></p><p>二分递归版代码的测试结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">任务进行中，当前协程数: 233059<br><span class="hljs-keyword">done</span> after 10.011710905s<br>任务结束后，当前协程数: 1248213<br></code></pre></td></tr></table></figure><p>直接递归版代码测试结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">任务进行中，当前协程数: 11<br><span class="hljs-keyword">done</span> after 10.002369341s<br>任务结束后，当前协程数: 6<br></code></pre></td></tr></table></figure></p><p>对比之下，问题很明显：二分递归版本创建的协程数巨多！且任务执行结束后，协程数翻了6倍！</p><p>根据这个结果，我们大胆的猜测一下：二分递归的代码陷入了无穷递归。</p><p>在纸上画一下测试 case 的递归树，发现 len(channels) == 3 的情况下，左右子树 len(channels) 分别是 1 和 2，但是加上退出信号 orDone 之后，变成了2和3。这里长度为 3 的这个分支发生了无穷递归。</p><p>这也解答了<strong>问题1</strong>最开始的第2个疑问：case2 为什么是特殊情况？能不能省掉，直接递归？</p><p>答案是 case len(channels)\=\=2 如果直接递归，会发生无穷递归，所以不能省掉。并且 case len(channels)\=\=3 也应该作为特殊情况处理，避免无穷递归。</p><p>所以二分递归版正确的写法是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(orDone)<br><br><span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(channels) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">0</span>]:<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">1</span>]:<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">0</span>]:<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">1</span>]:<br><span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">2</span>]:<br>&#125;<br><span class="hljs-keyword">default</span>:<br>m := <span class="hljs-built_in">len</span>(channels) / <span class="hljs-number">2</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-or(<span class="hljs-built_in">append</span>(channels[:m:m], orDone)...): <span class="hljs-comment">// must append orDone to avoid leak!!!!</span><br><span class="hljs-keyword">case</span> &lt;-or(<span class="hljs-built_in">append</span>(channels[m:], orDone)...):<br>&#125;<br>&#125;<br>&#125;()<br></code></pre></td></tr></table></figure></p><p>再次和晁老师沟通后，得到了肯定的答复！</p><h2 id="问题4：二分递归的效率问题"><a href="#问题4：二分递归的效率问题" class="headerlink" title="问题4：二分递归的效率问题"></a>问题4：二分递归的效率问题</h2><p>如果你不怕麻烦，在跑一遍二分递归的最终版代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">任务进行中，当前协程数: 15<br><span class="hljs-keyword">done</span> after 10.002655818s<br>任务结束后，当前协程数: 6<br></code></pre></td></tr></table></figure><p>结果没有异常，任务结束后，剩余协程数是6，说明任务结束信号正常传递，递归出来的协程都正常退出了。但是任务进行中的协程数比直接递归多4个！</p><p>难道二分递归的效率反而更低些？</p><p>随便测试几组 case 就能发现，随着 len(channels) 的上升，二分递归版衍生出来的协程数与直接递归衍生出来的协程数的差值也在上升。</p><p>这是因为二分递归版每递归一次，len(channels) 就会加2，而直接递归版 len(channels) 只会加1。而且为了减少递归衍生出的协程数，直接递归版把 case 2 单独拎了出来进行处理​。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>本文记录了学习 channel 的应用场景 orDone 模式中一次又一次的跳坑出坑的经历，虽然痛苦，却苦尽甘来。</p><p>文末留个开放性问题吧，二分递归和直接递归衍生出来的协程数似乎能用数学表达式写出来，你知道怎么写吗？</p><p>我反正是干不动，躺下了。</p><p>下期再见。</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p><p><strong>都看到这里了，不如加个关注呗~~</strong></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>channel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#6——你的预期年化收益率是多少？</title>
    <link href="/2021/03/30/invest-pratice-6/"/>
    <url>/2021/03/30/invest-pratice-6/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://afreecoder.cn/2020/07/18/invest-pratice-0/">财务自由实证#0——自由能实现吗？</a>。</p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更“美好”的事物上。</p><h2 id="实证进展"><a href="#实证进展" class="headerlink" title="实证进展"></a>实证进展</h2><p>本月进展如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/16170307690332.jpg" alt=""></p><p>当前进展 2.26%，相比上个月，增加 0%。较真的话，其实是有增加的，增加了不到400，聊胜于无。毛估了下，从春节到现在，回撤大概10%。</p><p>不过这才是真实的市场，不是吗？</p><h2 id="春节之后"><a href="#春节之后" class="headerlink" title="春节之后"></a>春节之后</h2><p>随着A股市场近一个多月的断崖式下跌，公募基金募集日光的现象暂时偃旗息鼓，多只基金的募集都发出了延期的公告。</p><p>由于有些基金跌的太厉害，还出现了基金经理回怼投资人的情况：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/16169274119020.jpg" alt="-w717"></p><p>这一个多月的时间里面，相关公司的基本面没有发生重大变化，基金经理的投资理念和投资风格也没有发生变化，变的只有我们的心态。</p><p>正好借着这波震荡的行情，来聊一聊股票的预期年化收益率应该是多少这个话题。</p><h2 id="你的预期年化收益率是多少？"><a href="#你的预期年化收益率是多少？" class="headerlink" title="你的预期年化收益率是多少？"></a>你的预期年化收益率是多少？</h2><p>聊这个话题之前，先弄个投票，看下大家的年化收益率的预期都是多少。</p><ul><li>没有预期收益率</li><li>5%以下</li><li>10%左右</li><li>15%左右</li><li>20%以上</li><li>50%以上</li></ul><p>为什么要问这个问题，是因为平时偶尔的聊天中，发现好多人对预期收益率这件事情没有概念，你问他的预期年化收益率是多少，他也说不上来，就觉得越高越好。</p><p>预期年化收益率其实就是投资目标。没有目标的投资，投资行为很容易变形。而且，有了合理的预期之后，我们面对暴涨暴跌，也会从容许多，因为那超出预期的，必然会回落；而那低于预期的，必然会反弹。</p><p>那么，重点来了，合理的预期年化收益率是多少？我们应该如何估计呢？</p><h2 id="股票合理的预期收益率应该是多少？"><a href="#股票合理的预期收益率应该是多少？" class="headerlink" title="股票合理的预期收益率应该是多少？"></a>股票合理的预期收益率应该是多少？</h2><p>在之前的文章《为什么要坚持长期投资？》中贴过一张图：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/16169417733213.jpg" alt=""></p><p>这张图是1802年到2008年这207年间，不同的统计周期下，年回报率的均值和标准差的对应情况。</p><p>以一年为统计周期，207年的平均收益率是6.5%，标准差是18.3%，也就是说，大约2/3的时间里，年回报率在-11.3%~25.3% 之间波动。实际上，一年的回报率最高能到66.6%，最低只有-38.6%。</p><p>统计周期拉长后，年回报率的标准差迅速减小，但是均值却没有什么变化，这说明，无论短期收益率波动如何剧烈，长期下来，收益率都会回归到某个值附近，这才是我们更有可能获得的真实收益率。</p><p><em>注：上图中的回报率是指剔除通货膨胀率之后收益率，加上通货膨胀率之后的名义收益率是10%左右。</em></p><p>很多人可能会说，美股的资本市场历史较长，制度比较完善，不能直接在A股上套用这个统计规律。</p><p>确实是这样。</p><p>之前看有知有行的文章《股票的预期收益率应该是多少？》，里面给出了一个自上而下的推导过程。</p><p>这个推导过程的依据是：<strong>GDP的增长率 &lt; 全体上市公司的增长率 &lt; 优质上市公司的增长率。</strong></p><p>GDP我们都知道，国民生产总值，也可以理解成所有大大小小的企业的生产总值。因此GDP的增速就是全部企业增长速度的均值。在过去的几十年里，中国的GDP经历了一个高速增长的阶段，但是随着经济体量的增大、人口红利的减少以及科技水平的制约，新常态下的GDP的增速肯定不可能有以前那么高，但是5%~6%的增长水平还是可以预期的。</p><p>当我们投资股票或者股票基金的时候，实际上投资的是这个国家规模比较大、盈利能力比较强的一些企业。毕竟无论是主板还是创业板、科创板块上市，都是需要满足一定的筛选条件的。基于这个事实，全体上市公司的增长率比GDP的增长率高3到4个百分点是比较合理的，因此如果我们投资全体上市公司，8%~10%的长期年化收益率是可以预期的。</p><p>尽管全体上市公司代表着国内比较优秀的一批公司，但是这一堆公司里面，也有许多平庸的公司，如果我们能从中挑选出一批更加优质的公司，我们的预期收益率还能再提高2到3个百分点。基于这个事实，10%~12%的长期年化收益率也是可以预期的。</p><p>除此之外，A股还有个所有人都体会深刻的特性：巨大的波动性。从人性的角度看，绝大部分人都是厌恶波动，喜欢确定性。但是投资的角度看，波动如果利用的好，是可以提升收益率的。</p><p>有知有行做过一个测算，如果在市场情绪较低的情况下买入，持有三年平均累计收益率可以达到130%，相反，如果是在高估的情况下买入，同样持有三年，平均亏损幅度高达46%。因此如果依据估值进行低买高卖，就有可能把长期收益率拉高到12%~15%的水平。</p><p>所以，对于普通投资者而言，12%~15%是一个比较合理且偏乐观的预期年化收益率。</p><h2 id="我有一个想法"><a href="#我有一个想法" class="headerlink" title="我有一个想法"></a>我有一个想法</h2><p>说点其它的。</p><p>看过这个系列第一篇 <a href="https://afreecoder.cn/2020/07/18/invest-pratice-0/">《财务自由实证#0——自由能实现吗？》</a> 的读者们都知道，我对这个实证计划的预期年化收益率是15%。这是一个相对乐观但还算合理的目标。</p><p>现阶段我实现这个目标的方式是跟投知名的组合，虽然我个人比较喜欢这种方式，但是这种方式也有两个缺点：</p><ol><li>组合的生命周期无法保证。</li></ol><p>组合的存在与否很大程度上由主理人主观决定，跟投者只能被动接受。我信任长赢计划，然而谁能保证它还有下一轮呢？</p><ol><li>策略不透明。</li></ol><p>虽然每个组合都有其投资策略的介绍，但是策略的细节仍然是不透明的；而且具体到每一次的操作上，我们也无法判断主理人是否完美的执行了该策略。</p><p>本着“自主可控”的原则，打算捡起去年的想法，开发一些简单但有效的投资策略，构建属于自己的投资组合，在实践中加快自己投资体系的建立。</p><p>由于深知“闭门造车”的弊端，所以借这篇文章推广一下：</p><p>如果你也对构建自己的投资策略也感兴趣，欢迎私信，一起搞事情！</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#5——我迁移了投资记账软件</title>
    <link href="/2021/02/27/invest-pratice-5/"/>
    <url>/2021/02/27/invest-pratice-5/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://afreecoder.cn/2020/07/18/invest-pratice-0/">财务自由实证#0</a>。</p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更“美好”的事物上。</p><h2 id="拖更太久了"><a href="#拖更太久了" class="headerlink" title="拖更太久了"></a>拖更太久了</h2><p>看了下上次写的那理财相关的文章，2月9号，到今天已经过去了大半个月。</p><p>反思了下，主要有两个原因：</p><p>一是春节。从初二开始，天天串亲戚，要么中午，要么下午，要么全天，天天串，天天吃，完全没有学习时间写文章。。</p><p>说好的疫情期间不串门呢？</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/wo-neng-you-shen-me-ban-fa.gif" alt="我能有什么办法"></p><p>二是投资理财部分没想好要怎么展开。这一部分能写的点太多，却又都不深刻，无法形成系统的文章。</p><p>不过这个问题最近已经想的差不多了，所以接下来奋力码字~</p><h2 id="实证进展"><a href="#实证进展" class="headerlink" title="实证进展"></a>实证进展</h2><p>不再多说废话，上图：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/16143531861520.jpg" alt=""></p><p>本月进展2.26%，相比上个月增加0.1%，缓慢而顽强的朝着目标前进。。。</p><p>特殊操作，除了之前跟投的组合外，新增两个组合的跟投：积极进取和全球精选。</p><p>感觉每个月的跟投额度有渐渐不受控制的倾向😂，不过积极进取和全球精选侧重资产配置，定期会有平衡操作，所有后续即使不跟投，问题也不大。</p><p>这个星期，出了个新词，不少小伙伴应该都看到了：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/wechatimg8649.jpeg" alt="WechatIMG8649"></p><p>过于真实。</p><p>看了下明星基金【易方达蓝筹精选】最近一段时间的走势：</p><p>年前净值创新高，过年之后一直在跌，一共跌了15%，堪比小型股灾。</p><p>没忍住去看了下支付宝【易方达蓝筹精选】的评论区，不少基民已经开始质疑张坤会不会炒股，为啥不减仓，，哈哈哈~</p><p>​下回再看支付宝的基金讨论区，算我输。</p><p>多说一句，买基金这事，既然选择了信任，不妨先坚持个几年试试，反正是闲钱，没必要着急。</p><h2 id="为什么要迁移记账软件？"><a href="#为什么要迁移记账软件？" class="headerlink" title="为什么要迁移记账软件？"></a>为什么要迁移记账软件？</h2><p>有看过之前实证记录的小伙伴，细心一点会发现，投资记账的软件换掉了。</p><p>是的，从这个月开始，所有的投资记录都从【且慢小账本】迁移到【有行记账】了。</p><p>为什么要迁移呢？</p><p>最主要的原因是【且慢小账本】已经停止维护，说不定什么时候就不能用了。其次就是相比与【且慢小账本】，【有行记账】还是一个有温度的工具。</p><p>【且慢小账本】原本是孟岩在且慢主导的一个记账软件，但是由于产品定位不清晰，过于工具化，有些用户除了它来记账，还会用它来记录彩票的收益率，或者是零花钱的流水，并且使用起来毫不违和。</p><p>然而这种使用方式和产品的初衷完全背离。【有行记账】的产品认为：</p><blockquote><p>记账的目的是为了投资，投资的目的是为了挣钱，挣钱的目的是为了生活。</p></blockquote><p>【有行记账】就是希望成为体现这种理念、关注投资本质，能帮大家走到投资大道上去的记账工具。</p><p>更具体的特征，大家不妨自己下载来体验一下~~</p><h2 id="迁移过程中的意外收获"><a href="#迁移过程中的意外收获" class="headerlink" title="迁移过程中的意外收获"></a>迁移过程中的意外收获</h2><p>由于【且慢小账本】不支持数据导出，而且我在它上面记录的数据也不全面，就想着干脆将这两年全部的投资记录全部都翻出来，重新都记录一遍。</p><p>为了防止之后再更换投资账本，以及更方便的进行数据导入导出分析，我使用了如下的步骤来进行数据迁移：</p><ol><li>在记账软件 MoneyWiz 上新建一个投资账户，记录完整的投入和转出。</li><li>将历史投资记录按月记录到有行账本中。</li><li>根据且慢小账本的记录，更新有行账本上部分历史时间节点的总资产。</li></ol><p>迁移的过程中，正好利用 MoneyWiz 的统计功能，把投入数据导出成 Excel，生成了下面这张表格：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/shi-zheng-ji-hua-tou-ru-ji-lu.png" alt="实证计划投入记录"></p><p>图虽然简单，却真实反应了我这两年来的投资历程。</p><p>2019年1月，出于纯粹的跑赢通胀的目的，首次投入【长赢指数计划】。由于当时市场低迷，组合中大部分基金的持仓成本都低于E大，运气好。</p><p>2019年2月到7月的这段时间，偶尔的跟调，但是读了（听了）不少书，算是完成了一个基本入门教育。</p><p>2019年7月之后，由于对基金有了进一步的认识，开始买入一些投资组合，从这之后，每月的净投入上了一个新台阶。</p><p>2020年2月份之后，疫情导致市场大跌，这期间加大了投入的额度。</p><p>2020年9月份之后，逐渐保持了一个稳定的投入额度。</p><p>现在回顾整个过程，比较可惜的就是3月份那次机会，毕竟像疫情这种非系统性的风险引起市场大幅下跌的机会，很难再遇到第二次了。</p><p>不过投资就是这样，你不可能抓住所有的机会，唯一能做的就是不断提升自己，静静的等待下一次的机会。</p><h2 id="再唠叨几句"><a href="#再唠叨几句" class="headerlink" title="再唠叨几句"></a>再唠叨几句</h2><p>春节之后的行情，想必大家都很不爽。我也是，毕竟累计收益的第一个数字直接减了1。</p><p>但是这才是正常情况，不是吗？从一开始我们就知道，市场是剧烈波动的，唯有有效的策略，正确的认知，再加上一个长长的期限，才能有所收获。</p><p>多年之后再回过头来看，这些波动不过就是几朵浪花而已，不值一提。</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么要坚持长期投资？</title>
    <link href="/2021/02/09/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9D%9A%E6%8C%81%E9%95%BF%E6%9C%9F%E6%8A%95%E8%B5%84/"/>
    <url>/2021/02/09/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9D%9A%E6%8C%81%E9%95%BF%E6%9C%9F%E6%8A%95%E8%B5%84/</url>
    
    <content type="html"><![CDATA[<h2 id="基金赚钱-≠-基民赚钱"><a href="#基金赚钱-≠-基民赚钱" class="headerlink" title="基金赚钱 ≠ 基民赚钱"></a>基金赚钱 ≠ 基民赚钱</h2><p>前几天，E大微博放出了一张中欧基金统计的客户收益和基金收益的对比图，十分震撼：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/7d46c32ba4fa44f4921f65242b46853d.png" alt="7D46C32B-A4FA-44F4-921F-65242B46853D"></p><p>图中蓝色柱状图是客户的累计收益，橙色柱状图是基金成立以来的收益。<strong>权益类基金的客户收益仅有基金累计收益的零头</strong>！</p><p>另外，中欧旗下的财务管理平台钱滚滚数据表示，2020年90%的基民实现了正收益，43%的基民平均投资收益超过了10%，但是反过来想就是<strong>近60%的基民收益不到10%</strong>。要知道2020年可是权益基金的大年。</p><p>这说明绝大部分的基金投资者都是短期投资者。</p><h2 id="为什么要坚持长期投资？"><a href="#为什么要坚持长期投资？" class="headerlink" title="为什么要坚持长期投资？"></a>为什么要坚持长期投资？</h2><blockquote><p>我对预测股市的短期波动一无所长，我对未来六个月、未来一年或未来两年内的股票市场的走势一无所知。—— 巴菲特</p></blockquote><p>商品价格受供求关系影响，围绕价值上下波动。而股票是股份公司发行的所有权凭证（股权凭证），股票的价值对应着公司的价值。虽然股票不能算完全意义的商品，但是其价格仍然符合价值规律的表现形式。</p><p>短期来看，公司的价值不可能发生巨大的变化，这个时候股票价格就会受到供求关系的影响。又因为股票不是完全意义的商品，没有使用价值，所以影响供求关系的其实是市场参与者对股票价格未来的期望。期望是一种心里预期，所以巴菲特才说他对未来一两年的股票市场走势一无所知。</p><p>长期来看，公司不断进行创新（技术创新、组织创新、模式创新），不断提高生产力，公司的价值也在不断提高，相应的，股票的价值也不断提高。这才是我们应该去争取获得的利润的来源。</p><h3 id="股票的长期收益"><a href="#股票的长期收益" class="headerlink" title="股票的长期收益"></a>股票的长期收益</h3><p>如果坚持长期投资，能获得多少收益呢？这里引用《共同基金十周年纪念版》中的数据（美股）：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/16128407901664.jpg" alt=""></p><p>表格数据补充说明：</p><ol><li>三个阶段：a)1802-1870年，美国从农业经济转为工业经济；b)1871-1925年，美国成为全球重要的经济和政治大国；c) 1926至今，现代股票市场时代。</li><li>1997和2008分别对应《共同基金常识》第一版和十周年纪念版的初版时间。</li><li>阴影部分数据是十周年再版时更新的数据。</li><li>消费者价格指数（CPI）指通货膨胀率。</li><li>90年代美股走强，2008年金融危机，所以1998-2008年间，实际回报率为负值。</li></ol><p>从这张图里能看到，从19世纪到20世纪，通货膨胀率急剧上升（二战后金本位解体），股市的名义回报率也大幅上升，但是实际总回报率（名义回报率减去通货膨胀率）仍然在7%左右。</p><h3 id="波动巨大的年回报率"><a href="#波动巨大的年回报率" class="headerlink" title="波动巨大的年回报率"></a>波动巨大的年回报率</h3><p>虽然股市长期回报率趋于稳定，但绝不能认为股市每年的实际收益率都是7%左右（很多投资者有一个错误的认知，长期回报率7%就是每年7%）。实际上，以一年为单位，股票的收益率存在巨大的波动。</p><p>下图是1802年到2008年期间，股票逐年波动率的情况：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/16128408642617.jpg" alt=""></p><p>表格中的数据不少，其实只要看1802-2008年这一行，这207年间，回报率的均值是7%，标准差是18.3%，也就是说，大约2/3的时间里，实际回报率在-11.3%~25.3%之间波动。实际上，这一段时期内，回报率最高能到66.6%，最低只有-38.6%。</p><p>显然，割裂的看每一年的回报率，存在巨大的不确定性。</p><h3 id="不同周期下年回报率的波动范围"><a href="#不同周期下年回报率的波动范围" class="headerlink" title="不同周期下年回报率的波动范围"></a>不同周期下年回报率的波动范围</h3><p>虽然具体到每一年，回报率波动十分剧烈，但是这个波动的剧烈程度，随着时间跨度的增加会迅速下降。</p><p>如下图所示：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/16128410086854.jpg" alt=""></p><p>在这张图里面，横坐标标识持有股票的时间，以年为单位；纵坐标显示的是年化回报率；而柱状图的高度代表了在相应的年限里，最高与最低的回报率范围。需要注意的是，这个波动范围是是根据标准差计算出来的一个范围，实际波动高于这个估计。</p><p>从图里我们可以看到，随着持有年限的增加，标准差迅速从18.3%下降到1.0%，前期下降远远快于后期下降。这说明我们持有的时间越长，获得一个稳定收益的概率越高。</p><h2 id="长期投资的风险"><a href="#长期投资的风险" class="headerlink" title="长期投资的风险"></a>长期投资的风险</h2><p>上面的数据<strong>仅仅证明了长期投资远远优于短期投资</strong>，但这并不意味着长期投资就没有风险。</p><blockquote><p>长期投资风险不是短期的波动，因为长期投资者可以忽略短期波动。而且，并不存在任何预定的回报率，而仅仅可能是一个无法实现的期望回报率，风险是这样一种可能性。在长期，股票的回报可能很差。</p></blockquote><p>上面是福特基金会财务官劳伦斯·西格尔关于长期历史回报率的忠告，长期下来，股票的回报可能不及预期。因为长期的终点，很可能正好是市场的寒冬。但是寒冬终会过去，只要继续等待，就一定能等到收货的季节。所以投资界还有一句名言：</p><blockquote><p>当闪电劈下来的时候，你要在场。</p></blockquote><p>需要说明的是，上面的回报率的计算不是基于某个股票，而是基于一堆股票，也就是说这个回报率是市场的平均水平。这就是为什么巴菲特推荐普通投资者购买推荐指数基金的原因：</p><blockquote><p>一个投资者虽然不了解具体企业的经济状况，但又想成为 美国产业的长期拥有者，应当定期地投资于指数基金。以这种方式，一无所知的投资者就能够超越大多数投资专家。但悖谬的是，当迟钝的投资者承认其局限时，他就再不迟钝了。长期 投资者就像寓言里步履蹒跚的乌龟，最终赢得了与投机者的竞赛，而投机者就像那只跑跑停停的兔子。</p></blockquote><p>再强调一下，<strong>关注长期远优于短期</strong>。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>文中表格数据均来自《共同基金常识》十周年纪念版，所以最后再次推荐下这本书。<br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/jie-ping20210125-013013.png" alt="截屏2021-01-25 01.30.13"></p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#4——基金组合和 FOF</title>
    <link href="/2021/01/30/invest-pratice-4/"/>
    <url>/2021/01/30/invest-pratice-4/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://afreecoder.cn/2020/07/18/invest-pratice-0/">财务自由实证#0</a>。</p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更”美好“的事物上。</p><h2 id="实证进展"><a href="#实证进展" class="headerlink" title="实证进展"></a>实证进展</h2><p>本月进展如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/16120621994964.jpg" alt="-w414"></p><p>当前进度：2.16%，相比上个月，增加0.16%。本月无特殊操作，按时定投，按比例跟投，其它时间老老实实学习，工作，写公众号。</p><h2 id="目前跟投的基金组合"><a href="#目前跟投的基金组合" class="headerlink" title="目前跟投的基金组合"></a>目前跟投的基金组合</h2><p>附一下当前实证计划中主要的组合：</p><div class="table-container"><table><thead><tr><th>组合名称</th><th>平台</th><th>主理人</th><th>特点</th></tr></thead><tbody><tr><td>长赢指数投资计划-150份</td><td>且慢APP</td><td>ETF拯救世界</td><td>一次性投入</td></tr><tr><td>长赢指数投资计划-S定投</td><td>且慢APP</td><td>ETF拯救世界</td><td>按比例跟投</td></tr><tr><td>云长进取</td><td>且慢APP</td><td>刘备教授</td><td>按比例跟投 + 定投</td></tr><tr><td>日积月累</td><td>蛋卷基金</td><td>Alex价值发现者</td><td>按比例跟投</td></tr></tbody></table></div><p>强调一下，实证中的这些组合服务于长期投资组合，能承受的风险等级较高，因此仅供参考。</p><h3 id="什么是基金组合"><a href="#什么是基金组合" class="headerlink" title="什么是基金组合"></a>什么是基金组合</h3><p>基金组合是这两年兴起的一种比较流行的投资方式。这些基金组合是组合的主理人（管这个组合的人）根据一定的投资策略，购买的一篮子基金。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/ji-jin-zu-he.jpg" alt="基金组合"></p><p>有没有发现基金组合的概念十分类似类似 FOF（超链接：什么是FOF）？其实本质都一样，只不过 FOF是正规的基金，受监管部门监管，而普通的基金组合则是由一些知名的大V管理，相对更灵活一些。</p><h3 id="为什么推荐基金组合"><a href="#为什么推荐基金组合" class="headerlink" title="为什么推荐基金组合"></a>为什么推荐基金组合</h3><p>推荐基金组合的原因如下：</p><ol><li>风险相对较低，收益相对稳定</li><li>主理人对外沟通频繁</li><li>主理人真金白银的投资自己的组合</li><li>操作便捷</li></ol><p>第1点，风险相对较低，收益相对稳定。基金本身就是一篮子同类资产，风险相对低一些；基金组合再通过不同类型的基金搭配，进行风险对冲，相对会更稳健一些。</p><p>第2点，<strong>主理人对外沟通频繁</strong>，这是我推荐基金组合的最大原因。普通基金，一般一个季度、甚至半年才会公布一次持仓情况以及调仓理由，其它时间你对这个基金内部的变动一无所知。</p><p>很多人都说要相信基金经理，要长期持有基金，但是关于基金经理的公开资料太少，又不能直接和基金经理沟通，甚至连基金经理买不买自己的基金都不知道，这让投资者怎么始终如一的信任基金经理？靠一腔热血吗？</p><p>主理人就不一样了。大部分基金组合的主理人都有自己偏爱的自媒体渠道，比如前面的<em>ETF拯救世界</em>，尤其喜欢发微博，天天在苦口婆心跟你讲市场怎么样，为什么这么做，要保持什么样的心态等等。</p><p>说的多了，你就能判断出来，这个主理人的投资行为是不是和他的理念一致。只要你认同这种理念，并且对他有了一定的信任，坚持就变成了一件水到渠成的事情。</p><p>第3点，主理人真金白银的投资自己的组合，这个很好理解，因为这样更能获得投资者的信任。</p><p>第4点操作便捷也是我推荐基金组合的原因。这些基金组合一般都依托于较大的第三方基金销售平台（支付宝、且慢、蛋卷等），当主理人对基金组合进行调仓时，平台通过短信或者公众号等方式通知，收到通知后，按比例一键买入即可。</p><p>这里以蛋卷基金上的日积月累组合为例：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/02/gen-tou-bu-zhou001.jpeg" alt="跟投步骤.001"></p><p>第一步，下载蛋卷APP，搜索日积月累组合，左下角点关注。<br>第二步，微信关注蛋卷基金服务号，登录。然后等通知。<br>第三、四步，根据调仓通知，选择适合自己的比例跟投。</p><p>需要强调的是，这里说的基金组合只是一个名义上的组合，<em>你并不会和主理人发生任何交易</em>，实际直接交易的还是相应的基金公司，跟投仅仅是复制了主理人的操作而已。</p><h3 id="为什么不推荐-FOF"><a href="#为什么不推荐-FOF" class="headerlink" title="为什么不推荐 FOF"></a>为什么不推荐 FOF</h3><p>一方面，FOF基金 作为国内17年新出现的基金品种，还没有广为人知。目前国内公募基金10000多只，FOF 基金只有174只，占比很小，业绩历史较短。</p><p>另一方面，FOF作为正统的基金，受到各种监管限制。比如，最新版的《基金中基金(FOF)审核指引》有如下规定：</p><p>1）FOF中单只基金的市值，不得高于FOF基金资产净值的20%。<br>2）投资于货币市场基金的比例不得超过基金资产的15%。<br>3）某一类型的FOF（如股票型FOF），其80%以上的资产需要投资于股票基金</p><p>其中第2点，最开始 FOF 投资货币基金的资产占比限制时不能超过5%。也就是说如果市场股票和债券都向下的情况下，基金经理却没法大量购买货币基金来避险。这个比例直到19年6月才上调为15%。</p><p>由于 FOF 相比于其它类别的基金，还是新品种（仅就国内而言），所以监管政策还在完善中，FOF 的发展也还在完善中。</p><p>最后还有一个双重收费问题。FOF投资非自家基金公司的基金时，需要支付常规的基金费用项目，而投资者申购FOF也需要支付一定的申购费、管理费等。</p><p>所以目前阶段，我更推荐跟投基金组合的方式（<strong>主理人对外的频繁沟通是巨大的优势</strong>）。</p><h2 id="基金组合的缺点"><a href="#基金组合的缺点" class="headerlink" title="基金组合的缺点"></a>基金组合的缺点</h2><p>上面说了那么多，并不是说基金组合就没有缺点了。</p><p>比如，基金组合其实是主理人的个人组合，每个人都能建立组合。所以这个市场也会越来越鱼龙混杂，</p><p>还有就是主理人虽然会投资自己的组合，但是他不会公布该组合占了他全副身家的多少比例。很多时候你会发现主理人的钱无穷无尽，而你很快就没钱了，最终你的收益也不如主理人。</p><p>另外有些主理人管理的组合很多，并且有越来越多的趋势，很难让人不怀疑他在每个组合上到底能花多少精力。</p><p>不过，仅就 <strong>主理人对外沟通频繁</strong> 这一个理由，我会推荐初学者从跟投基金组合开始，并在这个跟投的过程中完善自己。</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#3——2020年回顾</title>
    <link href="/2020/12/30/invest-pratice-3/"/>
    <url>/2020/12/30/invest-pratice-3/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://afreecoder.cn/2020/07/18/invest-pratice-0/">财务自由实证#0</a>。</p><p>追求财务自由，并不是希望大富大贵，而是希望能拥有自由选择生活方式的权利，能更有底气的把生命浪费在更”美好“的事物上。</p><h2 id="实证进展"><a href="#实证进展" class="headerlink" title="实证进展"></a>实证进展</h2><p>12月份进展如下：<br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2020/12/31/16094299697597.jpg" alt="-w414"></p><p>当前进度：2%。相比上个月增加0.12%。这个月前面都没涨，就这两天涨的。。</p><p>特殊操作方面，值得一提的就是正在逐渐把自己定投的那部分资金卖出，改成跟投其它组合，预计年前能调整完毕。</p><h2 id="2020回顾"><a href="#2020回顾" class="headerlink" title="2020回顾"></a>2020回顾</h2><p>2020年还有几天就要过去了，正好回顾一下这一年的投资理财历程。且慢没有按时间点展示投资及收益的功能，所以投资收益部分只能大概回忆一下，如果记错了，反正也没人知道。</p><p>1月份的时候，也就是春节前，本金2、3万，收益5000+，当时自我感觉良好，觉得自己有抄作业的天赋。</p><p>2月份，疫情发酵。3号，沪深300下跌7.88%。市场吓崩了，我也吓坏了，第一次见指数这么跌。虽然吓的不轻，但操作上啥也没做。之后指数迅速回升到年前水平。</p><p>3月份，疫情的影响持续扩大，从3月5号到3月23号，沪深300累计下跌16%。且慢上19年的收益基本跌没了，累计收益记得只剩200左右。不过因为收益始终是正的，所以心态上还好。</p><p>3月份，9号，12号，16号，18号，美股连续熔断4次，巴菲特天天在说见证历史，大家已经麻木了。</p><p>从3月底到6月底，各国积极应对疫情，尤其是中国，控制的非常好，日常活动已经和平时没有太大差别。资本市场发现被吓过头之后，开始自行修复。不过3长达个月的修复，也才达到了年前的水平。</p><p>这期间，上证指数最低是2680左右，那个时候想着指数每跌50就加一些，哪知道之后再也没有跌到2700以下。不过这个期间也陆陆续续的买了不少。现在回想起来，当时的行情是值得投入绝大部分资产，奋力一博的，可惜了。</p><p>到七月份，市场忽然就火了，可能是大家被憋的太久了，短短几天，沪深300涨了18%，市场情绪被全面点燃：</p><ul><li>部分机构喊出了“全面牛”的口号</li><li>A股的交易量天天破万亿</li><li>新股民开户过于热情导致多家券商平台崩溃</li></ul><p>7月初的这两周，眼见且慢上的收益从5000到10000，又迅速到了15000。这两天深刻认识到了A股暴涨暴跌的特性。（媳妇那个时候已经嚷嚷着要从她的小金库里掏出一部分来买基金了~）</p><p>7月下旬到年底，A股进入了横盘震荡的模式，涨跌比较随性。也正是这段时间的训练，现在每天如果跌个2000、3000，内心毫无波澜。</p><h2 id="一些感悟"><a href="#一些感悟" class="headerlink" title="一些感悟"></a>一些感悟</h2><p>2020年不管对谁，都是难忘且难过的一年。</p><p>从投资角度看，2020年，见证了美股历史上5次熔断中的4次；见证了A股的低迷，也见证了A股的爆发。原本3-5年甚至7年才能遇到市场的各种极端情况，这一年都遇到了。</p><p>经历了魔幻的2020年之后，关于市场和投资，有几个感悟特别强烈：</p><ol><li>不要对市场的顶部和底部设限。它能跌的让你怀疑人生，也能涨的让你怀疑人生。</li><li>不要去追求完美的最低点，模糊的低位区间，就已经值得加仓了。</li><li>无论买什么，都要了解所买资产的底层逻辑，明确自己想要得到什么已经自己能承担失去什么。</li><li>专业的事情交给专业的人做。</li><li>好好学习，好好工作，天天向上，攒钱才是王道。</li></ol><p>希望接下来的市场不要那么快起来，好让我多囤点资产~~</p><h2 id="说一说2020年理财上做的比较好的几点"><a href="#说一说2020年理财上做的比较好的几点" class="headerlink" title="说一说2020年理财上做的比较好的几点"></a>说一说2020年理财上做的比较好的几点</h2><h3 id="投资体系（框架）的知行合一"><a href="#投资体系（框架）的知行合一" class="headerlink" title="投资体系（框架）的知行合一"></a>投资体系（框架）的知行合一</h3><p><a href="https://afreecoder.cn/2020/10/10/invest-pratice-1/">财务自由实证#1</a> 中介绍了我的一个比较粗糙的投资体系：</p><ul><li>彻底了解自己</li><li>规划紧急备用金</li><li>规划必要的保险</li><li>规划3年内要用的钱</li><li>建立长期投资组合</li></ul><p>其实这里面的一些步骤或多或少都在其它地方看过或者听过，但是真正相信并彻底执行却是在今年下半年。</p><p>就是写 <a href="https://afreecoder.cn/2020/10/10/invest-pratice-1/">财务自由实证#1</a> 之前，有个周末，坐下仔细的梳理了自己的财务状况，严格按照上面的步骤走了一遍。</p><p>紧急备用金买了余额宝和互联网银行存款，保险基本配置完，3年内要用的钱买的债券基金组合中，长期投资组合的钱放在实证计划中的组合里。</p><h3 id="家庭内部实现理财观念的统一"><a href="#家庭内部实现理财观念的统一" class="headerlink" title="家庭内部实现理财观念的统一"></a>家庭内部实现理财观念的统一</h3><p>还记得刚开始的时候，特别希望能和媳妇一起研究如何理财，怎奈媳妇一点兴趣都没有，各种APP都懒得下，还得我去她手机里安装。</p><p>但是一个长达25年的理财规划，如果两个人的观念不能一致，是很难坚持下去的。比如如果市场一路下跌，但是你清楚的这个只是暂时的，撑过去就是海阔天空，但是你的另一半看到账户里天天都绿的发毛，要你赶紧取出来，怎么办？又或者是要买辆车了，但是行情不好，你要不要亏损取出来？</p><p>一边是金钱，一边是家庭和谐，如何选择？当然是两手都要抓，两手都要硬！</p><p>所以平时一有机会，我都会现学现卖，将我刚了解到东西讲给她听，跟她讲指数，讲基金，讲可转债，还有港股，也会把平时看到的比较好的公众号文章分享给她。</p><p>此外，无论赚多少亏多少，我从不瞒着，都会及时告诉她。</p><p>经过这些潜移默化的影响，媳妇现在已经完全认同我的观点，并且偶尔还会主动关心一下收益如何，或者主动和我讨论一下她看到的一些理财观点。</p><p>感谢媳妇一路以来的支持和理解，希望能早点带媳妇实现各种画出去的大饼！</p><h2 id="新年期望"><a href="#新年期望" class="headerlink" title="新年期望"></a>新年期望</h2><p>关于投资理财方面，期望主要有两个。</p><p>一是希望能在投资理财的认知层面和操作层面有一个比较大的进步；二是实证的金额翻个倍？</p><p>元旦快乐~~</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>聊一聊 golang 中的 Context 的实现</title>
    <link href="/2020/12/15/go-context/"/>
    <url>/2020/12/15/go-context/</url>
    
    <content type="html"><![CDATA[<h2 id="编程语言中的-Context"><a href="#编程语言中的-Context" class="headerlink" title="编程语言中的 Context"></a>编程语言中的 Context</h2><p>Context 的直接翻译是上下文或环境。在编程语言中，翻译成运行环境更合适。</p><p>比如一段程序，在执行之初，我们可以设定一个环境参数：最大运行时间，一旦超过这个时间，程序也应该随之终止。</p><p>在 golang 中， Context 被用来在各个 goroutine 之间传递取消信号、超时时间、截止时间、key-value等环境参数。</p><h2 id="golang-中的-Context-的实现"><a href="#golang-中的-Context-的实现" class="headerlink" title="golang 中的 Context 的实现"></a>golang 中的 Context 的实现</h2><p>golang中的Context包很小，除去注释，只有200多行，非常适合通过源码阅读来了解它的设计思路。</p><p><strong><em>注：本文中的golang 均指 go 1.14</em></strong></p><h3 id="接口-Context-的定义"><a href="#接口-Context-的定义" class="headerlink" title="接口 Context 的定义"></a>接口 Context 的定义</h3><p>golang 中 Context 是一个接口类型，具体定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>Deadline() (deadline time.Time, ok <span class="hljs-keyword">bool</span>)<br>Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>Err() error<br>Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Deadline()</strong></p><p>Deadline() 返回的是当前 Context 生命周期的截止时间。</p><p><strong>Done()</strong></p><p>Done() 返回的是一个只读的 channel，如果能从这个 channel 中读到任何值，则表明context的生命周期结束。</p><p><strong>Err()</strong></p><p>这个比较简单，就是返回异常。</p><p><strong>Value(key interface{})</strong></p><p>Value(key interface{}) 返回的是 Context 存储的 key 对应的 value。如果在当前的 Context 中没有找到，就会从父 Context 中寻找，一直寻找到最后一层。</p><h3 id="4种基本的context类型"><a href="#4种基本的context类型" class="headerlink" title="4种基本的context类型"></a>4种基本的context类型</h3><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">emptyCtx</td><td style="text-align:left">一个没有任何功能的 Context 类型，常用做 root Context。</td></tr><tr><td style="text-align:left">cancelCtx</td><td style="text-align:left">一个 cancelCtx 是可以被取消的，同时由它派生出来的 Context 都会被取消。</td></tr><tr><td style="text-align:left">timerCtx</td><td style="text-align:left">一个 timeCtx 携带了一个timer(定时器)和截止时间，同时内嵌了一个 cancelCtx。当 timer 到期时，由 cancelCtx 来实现取消功能。</td></tr><tr><td style="text-align:left">valueCtx</td><td style="text-align:left">一个 valueCtx 携带了一个 key-value 对，其它的 key-value 对由它的父 Context 携带。</td></tr></tbody></table></div><h3 id="emptyCtx-定义及实现"><a href="#emptyCtx-定义及实现" class="headerlink" title="emptyCtx 定义及实现"></a>emptyCtx 定义及实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> emptyCtx <span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span> <span class="hljs-title">Deadline</span><span class="hljs-params">()</span> <span class="hljs-params">(deadline time.Time, ok <span class="hljs-keyword">bool</span>)</span></span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span> <span class="hljs-title">Done</span><span class="hljs-params">()</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">struct</span></span>&#123;&#125; &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span> <span class="hljs-title">Err</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span> <span class="hljs-title">Value</span><span class="hljs-params">(key <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>看 emptyCtx 很轻松，因为它什么都没做，仅仅是实现了 Context 这个接口。在 context 包中，有一个全局变量 background，值为 new(emptyCtx)，它的作用就是做个跟 Context。其它类型的 Context 都是在 background 的基础上扩展功能。</p><h3 id="cancelCtx-定义及实现"><a href="#cancelCtx-定义及实现" class="headerlink" title="cancelCtx 定义及实现"></a>cancelCtx 定义及实现</h3><p>先看下 cancelCtx 的定义和创建。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义</span><br><span class="hljs-keyword">type</span> cancelCtx <span class="hljs-keyword">struct</span> &#123;<br>Context<br><br>mu       sync.Mutex            <span class="hljs-comment">// protects following fields</span><br>done     <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;         <span class="hljs-comment">// created lazily, closed by first cancel call</span><br>children <span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// set to nil by the first cancel call</span><br>err      error                 <span class="hljs-comment">// set to non-nil by the first cancel call</span><br>&#125;<br><br><span class="hljs-comment">// 创建</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancel</span><span class="hljs-params">(parent Context)</span> <span class="hljs-params">(ctx Context, cancel CancelFunc)</span></span> &#123;<br>c := newCancelCtx(parent)<br>propagateCancel(parent, &amp;c)<br><span class="hljs-keyword">return</span> &amp;c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;<br>&#125;<br><br><span class="hljs-comment">// newCancelCtx returns an initialized cancelCtx.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newCancelCtx</span><span class="hljs-params">(parent Context)</span> <span class="hljs-title">cancelCtx</span></span> &#123;<br><span class="hljs-keyword">return</span> cancelCtx&#123;Context: parent&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>总体来说，cancelCtx 的创建就是把父 Context 复制到 cancelCtx 的成员 Context 上，然后把父 Context 的一些信号广播到子 Context 上。最后返回了 cancelCtx 的引用，以及一个 cancelFunc。</p><p>我们看一下 cancel 实现的细节：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span> <span class="hljs-title">cancel</span><span class="hljs-params">(removeFromParent <span class="hljs-keyword">bool</span>, err error)</span></span> &#123;<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;context: internal error: missing cancel error&quot;</span>)<br>&#125;<br>c.mu.Lock()<br><span class="hljs-keyword">if</span> c.err != <span class="hljs-literal">nil</span> &#123;<br>c.mu.Unlock()<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// already canceled</span><br>&#125;<br>c.err = err<br><span class="hljs-keyword">if</span> c.done == <span class="hljs-literal">nil</span> &#123;<br>c.done = closedchan<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">close</span>(c.done)<br>&#125;<br><span class="hljs-keyword">for</span> child := <span class="hljs-keyword">range</span> c.children &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> acquiring the child&#x27;s lock while holding parent&#x27;s lock.</span><br>child.cancel(<span class="hljs-literal">false</span>, err)<br>&#125;<br>c.children = <span class="hljs-literal">nil</span><br>c.mu.Unlock()<br><br><span class="hljs-keyword">if</span> removeFromParent &#123;<br>removeChild(c.Context, c)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>cancel 有两个参数，一个是 removeFromParent，表示当前的取消操作是否需要把自己从父 Context 中移除，第二个参数就是执行取消操作需要返回的错误提示。</p><p>根据 cancel 的流程，如果 c.done 是 nil (父 Context 是 emptyCtx 的情况)，就赋值 closedchan。（ closedchan 是一个被关闭的channel）；如果不是nil，就直接关闭。然后递归关闭子 Context。</p><p>这里注意一下，关闭子 Context 的时候，removeFromParent 参数传值是 false，这是因为当前 Context 在关闭的时候，把 child 置成了 nil，所以子 Context 就不用再执行一次从父 Context 移除自身的操作了。</p><p>最后，我们重点说一说 <strong>propagateCancel</strong> 函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">propagateCancel</span><span class="hljs-params">(parent Context, child canceler)</span></span> &#123;<br>done := parent.Done()<br><span class="hljs-keyword">if</span> done == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// parent is never canceled</span><br>&#125;<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-done:<br><span class="hljs-comment">// parent is already canceled</span><br>child.cancel(<span class="hljs-literal">false</span>, parent.Err())<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br><br><span class="hljs-keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;<br>p.mu.Lock()<br><span class="hljs-keyword">if</span> p.err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// parent has already been canceled</span><br>child.cancel(<span class="hljs-literal">false</span>, p.err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> p.children == <span class="hljs-literal">nil</span> &#123;<br>p.children = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125;)<br>&#125;<br>p.children[child] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>p.mu.Unlock()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>atomic.AddInt32(&amp;goroutines, +<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-parent.Done():<br>child.cancel(<span class="hljs-literal">false</span>, parent.Err())<br><span class="hljs-keyword">case</span> &lt;-child.Done():<br>&#125;<br>&#125;()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从函数名 propagateCancel 大概能看出看出来这个函数的功能，即 “传播取消（信号）”。回想一下，父 Context 是如何判断有没有收到取消信号的？是根据它的私有成员 ctx.done 来判断的。那子 Context 如何能接收到这个信号呢？这就是函数 propagateCancel 干的事情，把 ctx.done 赋值给子 Context 的私有成员 done，子 Context 就可以获取到取消的信号。</p><p>propagateCancel 的实际处理要更为复杂一些。首先是判断判断父 Context 有没有被 cancel 掉？如果已经 cancel 掉，那么直接 cancel 掉当前的子 Context；如果没有的话，就会<strong>断言父 Context 是否是emptyCtx 类型</strong>，如果是，就通过父 Context 的成员 children 把子 Context 挂在父 Context 下面；如果不是，就启一个协程监听父 Context 信号。</p><p>解释一下为什么会 <strong>断言父 Context 是否是emptyCtx 类型</strong> ？想象一下，如果是你来写这段逻辑，会怎么写？最简单的方法就是每个子 Context 启一个协程，监听取消信号。这种方式能确实能实现取消信号广播的功能，但缺点就是如果子 Context 过多，协程就会很多，一直占用系统资源；而如果父 Context 的类型是 cancelCtx，那么它就能通过成员 children 递归的取消子 Context。一边是 n 个协程监听取消信号，一遍是一个协程就能递归取消所有子 Context，哪种方式消耗资源少，一目了然。</p><h3 id="timerCtx-定义及实现"><a href="#timerCtx-定义及实现" class="headerlink" title="timerCtx 定义及实现"></a>timerCtx 定义及实现</h3><p>先看以下 timerCtx 的定义和创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> timerCtx <span class="hljs-keyword">struct</span> &#123;<br>cancelCtx<br>timer *time.Timer <span class="hljs-comment">// Under cancelCtx.mu.</span><br><br>deadline time.Time<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithDeadline</span><span class="hljs-params">(parent Context, d time.Time)</span> <span class="hljs-params">(Context, CancelFunc)</span></span> &#123;<br><span class="hljs-keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;<br><span class="hljs-comment">// The current deadline is already sooner than the new one.</span><br><span class="hljs-keyword">return</span> WithCancel(parent)<br>&#125;<br>c := &amp;timerCtx&#123;<br>cancelCtx: newCancelCtx(parent),<br>deadline:  d,<br>&#125;<br>propagateCancel(parent, c)<br>dur := time.Until(d)<br><span class="hljs-keyword">if</span> dur &lt;= <span class="hljs-number">0</span> &#123;<br>c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded) <span class="hljs-comment">// deadline has already passed</span><br><span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">false</span>, Canceled) &#125;<br>&#125;<br>c.mu.Lock()<br><span class="hljs-keyword">defer</span> c.mu.Unlock()<br><span class="hljs-keyword">if</span> c.err == <span class="hljs-literal">nil</span> &#123;<br>c.timer = time.AfterFunc(dur, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded)<br>&#125;)<br>&#125;<br><span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithTimeout</span><span class="hljs-params">(parent Context, timeout time.Duration)</span> <span class="hljs-params">(Context, CancelFunc)</span></span> &#123;<br><span class="hljs-keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))<br>&#125;<br></code></pre></td></tr></table></figure><p>有了前面的 cancelCtx 的基础后，看 timerCtx 会清晰很多。timerCtx 的结构简单一些。timeCtx 有三个成员，第一个是 cancelCtx，这意味这 timerCtx 的取消的操作其实是通过 cancelCtx 实现的；第二个成员是 timer，这是一个定时器，干的事情就是到 deadline 的时候，执行 cancel 操作；第三个成员就是 deadline。</p><p>当然，除了等定时器到期自动执行 cancel 操作，也可以主动执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *timerCtx)</span> <span class="hljs-title">cancel</span><span class="hljs-params">(removeFromParent <span class="hljs-keyword">bool</span>, err error)</span></span> &#123;<br>c.cancelCtx.cancel(<span class="hljs-literal">false</span>, err)<br><span class="hljs-keyword">if</span> removeFromParent &#123;<br><span class="hljs-comment">// Remove this timerCtx from its parent cancelCtx&#x27;s children.</span><br>removeChild(c.cancelCtx.Context, c)<br>&#125;<br>c.mu.Lock()<br><span class="hljs-keyword">if</span> c.timer != <span class="hljs-literal">nil</span> &#123;<br>c.timer.Stop()<br>c.timer = <span class="hljs-literal">nil</span><br>&#125;<br>c.mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><p>如果主动执行 cancel 操作，除了会递归取消子 Context，还是终止定时器。</p><h3 id="valueCtx-的定义和创建"><a href="#valueCtx-的定义和创建" class="headerlink" title="valueCtx 的定义和创建"></a>valueCtx 的定义和创建</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> valueCtx <span class="hljs-keyword">struct</span> &#123;<br>Context<br>key, val <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValue</span><span class="hljs-params">(parent Context, key, val <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">Context</span></span> &#123;<br><span class="hljs-keyword">if</span> key == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;nil key&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;key is not comparable&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *valueCtx)</span> <span class="hljs-title">Value</span><span class="hljs-params">(key <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br><span class="hljs-keyword">if</span> c.key == key &#123;<br><span class="hljs-keyword">return</span> c.val<br>&#125;<br><span class="hljs-keyword">return</span> c.Context.Value(key)<br>&#125;<br></code></pre></td></tr></table></figure><p>valueCtx 也很简单，一个 Context 类型的成员，还有两个都是 interface{} 类型的成员 key，value。</p><p>从 valueCtx 的创建能看到，如果想给 Context 存储一个键值对，只能通过 WithValue 函数创建，且每个 Context 只能存储一对。取值的方式是递归寻找父 Context 存储的键值对，所以一个 Context 相当于存储了全部父节点的键值对。</p><p>另外可以看到，valueCtx 的成员是 Context 类型，不是 cancelCtx 类型，这一点需要注意。所以不同的业务场景需要选择不同的 Context。</p><h2 id="golang-中-Context-的使用"><a href="#golang-中-Context-的使用" class="headerlink" title="golang 中 Context 的使用"></a>golang 中 Context 的使用</h2><p>golang 中 Context 的使用套路是在最开始的时候，创建一个 root Context，这个 root Context 就是 emptyCtx 的一个实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>background = <span class="hljs-built_in">new</span>(emptyCtx)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Background</span><span class="hljs-params">()</span> <span class="hljs-title">Context</span></span> &#123;<br><span class="hljs-keyword">return</span> background<br>&#125;<br></code></pre></td></tr></table></figure><p>接着是根据各个场景，创建不同类型的 Context。</p><p>此外，官方博客也给出了 Context 使用的一些建议：</p><ol><li>不能在其它类型的结构下放 Context 类型的成员。</li><li>Context 类型应该作为函数的第一个参数使用，简写是 ctx</li><li>不要用 nil 来代替本该传入的 Context，实在不行可以先传 context.Todo() (和 background 类似)。</li><li>不要把函数内部的参数添加到 ctx 中。ctx 中应该存一些贯穿始终的数据。</li><li>Context 是并发安全的，所以不用担心多个线程同时使用。</li></ol><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>golang 的 Context 就讲到这里，由于篇幅原因，总觉得还有不少地方没有讲清楚，下回有机会结合业务场景讲一下 Context 的具体使用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/68792989">深度解密Go语言之context</a></li><li><a href="https://blog.csdn.net/u011957758/article/details/82948750?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160788294719726891176947%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160788294719726891176947&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-10-82948750.nonecase&amp;utm_term=golang%E4%B8%AD%E7%9A%84context&amp;spm=1018.2118.3001.4449">由浅入深聊聊Golang的context</a></li></ol><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>context</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go 性能优化之 benchmark + pprof</title>
    <link href="/2020/12/06/go-benchmark-pprof/"/>
    <url>/2020/12/06/go-benchmark-pprof/</url>
    
    <content type="html"><![CDATA[<blockquote><p>testing 是go自带的一个轻量级的测试框架，主要有三个用途：单元测试(Test)，基准测试(Benchmark)以及示例测试(Example)。</p></blockquote><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>写go也有几个月了，一直没太关注类似 <code>benchmark</code> 之类的性能分析工具，只知道埋头写业务代码。直到前几天，工作上的一个项目遇到了性能瓶颈，需要分析一下原因，就用到了 <code>benchmark</code>。一顿分析，终于发现了程序中的”性能消耗大户“，颇有成就感。</p><h2 id="测试case准备"><a href="#测试case准备" class="headerlink" title="测试case准备"></a>测试case准备</h2><p>平时写代码的过程中，会经常写一些 <code>print</code> 或者 <code>debug</code> 函数，谁又能想到，这些 <code>print</code> 偷偷摸摸的消耗了多少 <code>CPU</code> 和 内存资源呢？</p><p>AES对称加密是业务代码中经常会用到的一种加密方式，但是编码习惯如果不好，或者测试代码忘了删，就会导致加密性能急剧下降。</p><p><strong>大师兄写的AES加密函数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AesEncryptA</span><span class="hljs-params">(aesKey, IV, origin []<span class="hljs-keyword">byte</span>)</span> []<span class="hljs-title">byte</span></span> &#123;<br>block, err := aes.NewCipher(aesKey)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>blocksize := block.BlockSize()<br>blockMode := cipher.NewCBCEncrypter(block, IV)<br>originData := PKCS5Pading(origin, blocksize)<br>crypted := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-built_in">len</span>(originData))<br>blockMode.CryptBlocks(crypted, originData)<br><span class="hljs-keyword">return</span> crypted<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二师兄写的AES加密函数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AesEncryptB</span><span class="hljs-params">(aesKey, IV, origin []<span class="hljs-keyword">byte</span>)</span> []<span class="hljs-title">byte</span></span> &#123;<br>block, err := aes.NewCipher(aesKey)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>blocksize := block.BlockSize()<br>blockMode := cipher.NewCBCEncrypter(block, IV)<br>originData := PKCS5Pading(origin, blocksize)<br>crypted := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-built_in">len</span>(originData))<br>blockMode.CryptBlocks(crypted, originData)<br>    <br>    <span class="hljs-comment">// 把加密结果打印到日志看看</span><br>f, _ := os.Create(<span class="hljs-string">&quot;temp.log&quot;</span>)<br><span class="hljs-keyword">defer</span> f.Close()<br>log.SetOutput(f)<br>log.Println(fmt.Sprintf(<span class="hljs-string">&quot;encrypt res is %s&quot;</span>, base64.StdEncoding.EncodeToString(crypted)))<br><br><span class="hljs-keyword">return</span> crypted<br>&#125;<br></code></pre></td></tr></table></figure><p>乍一看，大师兄和二师兄写的差不多，只是二师兄多了一个把加密结果写到日志中的操作。</p><p><strong><em>就这么一点点的区别，性能能差多少呢?让我们把悬念留到最后。</em></strong></p><h2 id="benchmark-实施"><a href="#benchmark-实施" class="headerlink" title="benchmark 实施"></a>benchmark 实施</h2><p>假设当前项目中的代码就是二师兄写的，我们就来分析一下，当前的性能瓶颈到底在什么地方。</p><h3 id="benchmark编写"><a href="#benchmark编写" class="headerlink" title="benchmark编写"></a>benchmark编写</h3><p><strong>写benchmark几个注意点</strong>：</p><ul><li>文件名以 <code>_test.go</code> 结尾，如 <code>practice_test.go</code></li><li>函数名统一以 <code>Benchmark</code> 开头，参数是 <code>*testing.B</code></li><li>对于要测试的函数，函数外面套上一个 for 循环，for 循环次数的上限是 <code>b.N</code></li><li>为了排除其它流程的干扰，一般会在 for 循环前加上 <code>b.ResetTimer</code></li></ul><p><strong>对二师兄的加密函数写个基准测试</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkAesEncryptB</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>aesKey := []<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;1234567890abcdef&quot;</span>)<br>IV := []<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;7878676756564545&quot;</span>)<br><br>originData := bytes.Repeat([]<span class="hljs-keyword">byte</span>&#123;<span class="hljs-number">28</span>&#125;, <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">29</span>)<br>b.ResetTimer()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>AesEncryptB(aesKey, IV, originData)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了更加明显的对比，这里我们测试的加密数据的大小是512MB（即 1&lt;&lt; 29）</p><h3 id="执行benchmark命令"><a href="#执行benchmark命令" class="headerlink" title="执行benchmark命令"></a>执行benchmark命令</h3><blockquote><p>testing 框架下的基准测试依赖 <code>go test</code> 工具</p></blockquote><p><strong>benchmark 命令示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">test</span> -bench BenchmarkAesEncryptB -run none -benchmem -cpuprofile cpuprofile.out -memprofile memprofile.out<br></code></pre></td></tr></table></figure><p>这个命令中的参数比较多，我们一个个的解释。</p><ul><li><code>-bench</code> 表示执行哪些基准测试函数，后面可以加需要执行的基准测试函数名称，也可以加 <code>.</code>，表示执行全部的基准测试函数。（其实 <code>-bench</code> 后面可以加正则表达式）</li><li><code>-run</code> 表示执行哪些单元测试和示例测试函数，一般会加none，表示都不执行</li><li><code>-benchmen</code> 表示打印函数执行过程中的内存分配</li><li><code>-cpuprofile</code> 表示将全过程的 <code>CPU</code> 的一些概要数据写到文件 <code>cpuprofile.out</code> 中</li><li><code>memprofile</code> 表示将全过程的内存的一些概要数据写到文件 <code>memprofile.out</code> 中</li></ul><p><strong>执行结果分析</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">goos: darwin<br>goarch: amd64<br>pkg: go_practice/benchmart_example<br>BenchmarkAesEncryptB-8                 1        8570217455 ns/op        6218811264 B/op       55 allocs/op<br>PASS<br>ok      go_practice/benchmart_example   9.985s<br></code></pre></td></tr></table></figure><p>从执行结果中能看到，for 循环每执行一次，耗时 8570217455 纳秒，同时会有55次内存分配操作，每次操作 6218811264 字节。</p><p>到这里，我们其实已经完成了基准测试的一个基本流程，也对二师兄的加密函数的性能和内存使用状况有了一个初步的认识。</p><p><strong>但是，我们还是不知道性能瓶颈在哪！！</strong></p><h2 id="终极杀器：benchmark-pprof"><a href="#终极杀器：benchmark-pprof" class="headerlink" title="终极杀器：benchmark + pprof"></a>终极杀器：benchmark + pprof</h2><blockquote><p>pprof 是 go 自带的 <code>CPU</code> 分析器，常用来分析性能瓶颈。</p></blockquote><p>在前面的基准测试中，我们生成了 <code>CPU</code> 概要文件 <code>cpuprofile.out</code> 以及内存概要文件 <code>memprofile.out</code>，现在可以派上大用场了。</p><p>pprof 既可以通过命令行交互的方式查看CPU（内存）的概要数据，也可以通过web的方式查看直观的图形化展示。这里我们主要通过web的方式来展示。</p><p><strong><em>当然，使用pprof工具前，你需要先安装 <code>graphviz</code>，如果是mac，执行 <code>brew install graphviz</code> 就行。</em></strong></p><h3 id="pprof-分析-CPU"><a href="#pprof-分析-CPU" class="headerlink" title="pprof 分析 CPU"></a>pprof 分析 CPU</h3><p><strong>执行命令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool pprof -http=<span class="hljs-string">&quot;:8081&quot;</span> cpuprofile.out<br></code></pre></td></tr></table></figure></p><p>通过地址 <code>http://localhost:8081/ui/</code> 能看到</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/go-benchmark-pprof/cpuprofile.png" alt="cpuprofile.png"></p><p>从这个截图中，我们很容易看到，加密部分总共耗时5.11s，完全用在加密上的耗时才0.76s，其它时间都是用在日志打印上和字符串转化上，</p><h3 id="pprof-分析内存"><a href="#pprof-分析内存" class="headerlink" title="pprof 分析内存"></a>pprof 分析内存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool pprof -http=<span class="hljs-string">&quot;:8081&quot;</span> memprofile.out<br></code></pre></td></tr></table></figure><p>通过地址 <code>http://localhost:8081/ui/</code> 能看到</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/go-benchmark-pprof/memprofile.png" alt="memprofile.png"></p><p>从这个截图图中，我们很容易看到，5930.71MB的内存使用，真正用在加密上的才512MB以及对原始字符串padding操作的640MB，其它内存都耗费在字符串转化和各种 <code>print</code> 操作上。</p><p>很直观的，我们就知道了二师兄的代码问题就在那一段日志打印的操作上。</p><h3 id="优化二师兄的代码"><a href="#优化二师兄的代码" class="headerlink" title="优化二师兄的代码"></a>优化二师兄的代码</h3><p>根据上面的分析，我们需要优化的就是日志打印的那部分代码。二师兄的代码优化后其实就是大师兄的代码。</p><p>我们把大师兄和二师兄的代码放一起跑一遍基准测试：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">test</span> -bench . -run none -benchmem -cpuprofile cpuprofile.out -memprofile memprofile.out<br></code></pre></td></tr></table></figure></p><p><strong>得到</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">goos: darwin<br>goarch: amd64<br>pkg: go_practice/benchmart_example<br>BenchmarkAesEncryptA-8                 1        1174023307 ns/op        1207968624 B/op       13 allocs/op<br>BenchmarkAesEncryptB-8                 1        7496300203 ns/op        6218810296 B/op       50 allocs/op<br>PASS<br>ok      go_practice/benchmart_example   9.508s<br></code></pre></td></tr></table></figure><p>从 <code>CPU</code> 耗时上看，大师兄的代码耗时只有二师兄的 1/7，单次内存消耗只有二师兄的 1/5，并且内存分配次数也只有二师兄的 1/4 左右。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>二师兄在追赶大师兄的道路上，又前进了一大步，可喜可贺~~</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://my.oschina.net/solate/blog/3034188">go benchmark 性能测试</a></p><p>[2] <a href="https://golang.org/cmd/go/#hdr-Testing_flags">go testing</a></p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>testing</tag>
      
      <tag>benchmark</tag>
      
      <tag>pprof</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang下文件锁的使用</title>
    <link href="/2020/12/02/go-file-lock/"/>
    <url>/2020/12/02/go-file-lock/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>题目是golang下文件锁的使用，但本文的目的其实是通过golang下的文件锁的使用方法，来一窥文件锁背后的机制。</p><h2 id="为什么需要文件锁"><a href="#为什么需要文件锁" class="headerlink" title="为什么需要文件锁"></a>为什么需要文件锁</h2><blockquote><p>只有多线程/多进程这种并发场景下读写文件，才需要加锁，</p></blockquote><p><strong>场景1-读写并发</strong></p><p>读写并发场景下，如果不加锁，就会出现读到脏数据的情况。想象一下，读文件的进程，读到第500字节，有其它进程以覆盖写的方式向文件中写入1000字节，那读进程读到的后500字节就是脏数据。</p><p><strong>场景2-写写并发</strong></p><p>写写并发场景下，如果不加锁，假设A进程先写0-1000字节，B进程写0-900字节，以此类推，最后一个进程写0-100字节，那最终的文件内容就是每个进程前100个字节拼接起来的错乱的内容了。</p><h2 id="文件锁的几个概念"><a href="#文件锁的几个概念" class="headerlink" title="文件锁的几个概念"></a>文件锁的几个概念</h2><p><strong>共享锁</strong></p><p>共享锁，也叫读锁。某个进程首次获取共享锁后，会生成一个锁类型的变量L，类型标记为共享锁。其它进程获取读锁的时候，L中的计数器加1，表示又有一个进程获取到了共享锁。这个时候如果有进程来获取排它锁，会获取失败。</p><p><strong>排它锁</strong></p><p>排它锁，也叫写锁。某个进程首次获取排他锁后，会生成一个锁类型的变量L，类型标记为排他锁。其它进程获取任何类型的锁的时候，都会获取失败。</p><p><strong>阻塞</strong></p><p>阻塞的意思是说，新的进程发现当前的文件（数据）被加锁后，会一直处于等待状态，直到锁被释放，才会继续下一步的行为。</p><p><strong>非阻塞</strong></p><p>非阻塞的意思是说，新的进程发现当前的文件（数据）被加锁后，立即返回异常。业务上需要根据具体的业务场景对该异常进行处理。</p><p>阻塞和非阻塞其实是进程遇到锁的时候的两种处理模式。</p><h2 id="golang下如何使用文件锁"><a href="#golang下如何使用文件锁" class="headerlink" title="golang下如何使用文件锁"></a>golang下如何使用文件锁</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs golang"><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;syscall&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    f, err := os.Create(<span class="hljs-string">&quot;example.txt&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;create file example.txt failed&quot;</span>, err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> f.Close()<br>    <span class="hljs-comment">// 非阻塞模式下，加共享锁</span><br>    <span class="hljs-keyword">if</span> err := syscall.Flock(<span class="hljs-keyword">int</span>(f.Fd()), syscall.LOCK_SH|syscall.LOCK_NB); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;add share lock in no block failed&quot;</span>, err)<br>    &#125;<br>    <span class="hljs-comment">// 这里进行业务逻辑</span><br>    <span class="hljs-comment">// TODO</span><br><br>    <span class="hljs-comment">// 解锁</span><br>    <span class="hljs-keyword">if</span> err := syscall.Flock(<span class="hljs-keyword">int</span>(f.Fd()), syscall.LOCK_UN); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;unlock share lock failed&quot;</span>, err)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>示例中 <code>LOCK_SH</code> 表示当前获取的是共享锁，如果是 <code>LOCK_EX</code>，则表示获取的是排他锁。而 <code>LOCK_NB</code> 表示当前获取锁的模式是非阻塞模式，如果需要阻塞模式，不加这个参数即可。<code>LOCK_UN</code> 则表示解锁，即释放锁。</p><p>golang 下这种文件锁的使用方式其实是Linux下的系统级调用，使用的是Linux的原生的文件锁的相关能力。</p><h3 id="使用flock的几个注意点"><a href="#使用flock的几个注意点" class="headerlink" title="使用flock的几个注意点"></a>使用flock的几个注意点</h3><p>1、只要fd指向的是同一个文件指针，那么加锁解锁的行为都是继承和覆盖的（这个可以看最后的解释）。</p><p>2、flock这种方式加的是建议性锁，也就是说新的进程一上来不管三七二十一，不去通过flock获取锁，就对文件各种操作，也是可以正常生效的。</p><h2 id="说一说Linux下面的flock和fcntl"><a href="#说一说Linux下面的flock和fcntl" class="headerlink" title="说一说Linux下面的flock和fcntl"></a>说一说Linux下面的flock和fcntl</h2><p>和flock一样，fcntl也是系统级调用，但是在具体的使用上却有很大不用，并且两种锁互不干扰，用flock加锁，fcntl无法感知，反之也一样。</p><h3 id="建议性锁和强制锁"><a href="#建议性锁和强制锁" class="headerlink" title="建议性锁和强制锁"></a>建议性锁和强制锁</h3><p>flock加的是建议性锁，而fcntl加的是强制性锁。</p><p>建议性锁，本质是一种协议，约定读写操作前都去检查一下该文件是否有被其它进程加锁。如果不遵守该协议，一上来就对文件进行操作，不检查有没有锁，程序执行上是没有任何问题的，能执行成功。</p><p>强制性锁，才更像真正意义上的锁。只要加了锁，其它进程是无法执行非允许的操作的。</p><p>其实一些利用redis做的分布式锁，都是建议性锁。锁机的机制要生效，需要大家共同遵守这个约定才行。</p><h3 id="全局锁和局部锁"><a href="#全局锁和局部锁" class="headerlink" title="全局锁和局部锁"></a>全局锁和局部锁</h3><p>对于一个文件，flock加锁的范围是整个文件内容，而fcntl能对文件的任意部分加锁。</p><h3 id="锁的持有者问题"><a href="#锁的持有者问题" class="headerlink" title="锁的持有者问题"></a>锁的持有者问题</h3><p>flock认为，锁的持有者是文件表（可以理解为文件指针），所以对于fork和dup操作，他们都对应同一个文件指针，所有的操作都会作用到这个文件上。具体表现：</p><ul><li>A进程加锁，A的子进程进程可以解锁，新的操作会覆盖之前的操作</li><li>A进程加锁，A进程复制fd，仍然是可以通过新的fd操作文件锁，新的操作会覆盖之前的操作</li></ul><p>fcntl 认为，锁的持有者是进程。加锁和解锁的行为都是跟着进程走，具体表现为：</p><ul><li>A进程加锁，B进程得等A进程消亡或者解锁才能加锁</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/25134841">被遗忘的桃源——flock 文件锁</a></p><p>[2] <a href="https://www.cnblogs.com/charlesblc/category/914733.html">Linux文件锁学习-flock, lockf, fcntl</a></p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#2——延迟退休的影响</title>
    <link href="/2020/11/23/invest-pratice-2/"/>
    <url>/2020/11/23/invest-pratice-2/</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p><strong>财务自由实证</strong> 系列的第零篇是 <a href="https://afreecoder.cn/2020/07/18/invest-pratice-0/">财务自由实证#0</a>。</p><p>追求财务自由，并不是希望大富大贵，而是希望自由之后，能更有底气的把生命浪费在更”美好“的事物上，而无须担心生计问题。</p><h2 id="实证进展"><a href="#实证进展" class="headerlink" title="实证进展"></a>实证进展</h2><p>先上进展：<br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/invest_demostration2.jpeg" width="50%" height="50%"></p><p>当前进度：1.88%。相比上个月增加0.19%，呃，听上去有些微不足道。如果仔细看下就会发现，这1个多月中，总资产增加近1万，但是实际新增投入不到6000，这么一看，很惊喜有没有。</p><h2 id="投资计划的一些调整"><a href="#投资计划的一些调整" class="headerlink" title="投资计划的一些调整"></a>投资计划的一些调整</h2><p>这一个月中投资的观念发生了一些变化，具体表现就是新增资金不再定投宽基指数，全部改成跟投基金组合。</p><p>关于基金组合：</p><blockquote><p>由基金主理人结合自己的投资理念选择投资基金与比例，提供符合该理念的投资方案，并进行长期持续仓位管理与方案调整的产品。</p></blockquote><p>组合的买卖调仓操作都会通过短信、APP、微信服务号发送通知，当然跟不跟还是看自己。我的建议是既然选择了相信，就无脑跟投。</p><p>常用的两个软件是<strong>且慢</strong>和<strong>蛋卷基金</strong>，主要跟投两个组合，一个是<strong>E大</strong>(ETF拯救世界)的<strong>长赢计划</strong>，一个是<strong>Alex</strong>的<strong>日积月累</strong>。</p><p><strong>长赢计划</strong>19年初开始跟投，目前收益率60%，比较满意，就是本金有点少，才10000，颇为遗憾。补充一下，因为进去的时间点比较巧，刚好在低点，组合中的绝大部分基金组合持仓成本都比主理人的持仓成本低，所以这个收益率比主理人还要高。</p><p><strong>日积月累</strong>是19年12月开始跟，每月大概跟投1000左右，目前收益率20%多（由于是定投，这个收益率其实是低于组合的实际收益率的，此外，该组合中途也有不少获利了结的，实际收益是更高的）。整体比较满意，没法和<strong>长赢</strong>比，没办法，相比年初，那个时候市场已经起来了。</p><p>很高兴，目前为止，这两个组合的收益率都跑赢了沪深300。</p><h3 id="之前我是如何定投的"><a href="#之前我是如何定投的" class="headerlink" title="之前我是如何定投的"></a>之前我是如何定投的</h3><p>上一篇提到的养老金账户和教育金账户就是手动定投的，其中养老金账户归到了实证计划中，教育金账户另算。这两个账户的策略完全一致，都是按照低估值理论，定投沪深300、中证500和中证红利。</p><p>定投的策略依据的是低估值理论，月初执行定投（刚发完工资），具体执行的时候，会参考下蛋卷和且慢的指数估值，三个指数里面，谁低谁就多买一些（比例啥的，全都是拍脑袋），如此执行了大约1年多。</p><p>养老金的起投时间是2019年8月，截止目前收益率23.2%；教育金起投时间是2019年6月，截止目前收益率23.3%。粗看收益率还行，主要是因为上半年疫情的影响，指数大幅度下跌，那个时候除了严格的执行定投策略，还会不定期不定额的视市场情况，不断加仓。如果没有那段时间的频繁加仓，收益会逊色很多。</p><p>而且中间加仓的那段时间，天天看指数，每天都在想要不要加，加多少，后面又跌了怎么办，十分影响心情。</p><h3 id="调整方案"><a href="#调整方案" class="headerlink" title="调整方案"></a>调整方案</h3><p>基金组合的跟投有两种，一种是存量资金跟投，一种增量资金跟投（类似定投）。</p><p>打算已投部分全部调整到兴全基金管理的一个组合 <strong>兴全进取派选牛基</strong> 中，继续定投的组合还没想好，是且慢的 <strong>U定投</strong> 还是其它，等确定了，后续再公布。</p><h2 id="延迟退休"><a href="#延迟退休" class="headerlink" title="延迟退休"></a>延迟退休</h2><p>说一说最近比较火的《十四五规划建议》，该建议提出，实施渐进式延迟法定退休年龄。之前一直有传言的延迟退休，看这次是真的要落地了。</p><p>客观来说，延迟退休这个事迟早都是要来的，原因有三点：</p><p><strong>1. 人口预期寿命大幅增长</strong></p><p>当前退休年龄是上个世纪50年代指定的，那个时候人口平均预期寿命较低，才45岁左右，如今人口平均寿命大幅增加到77岁。退休年龄不变的情况下，养老金支出会迅猛增加。</p><p>假定一个人25岁开始工作，55岁退休，平均寿命是60岁，工作期间每年缴纳的养老金就是退休之后每年领取的退休金，那么一个劳动力能供养6个退休人员。但是如果平均寿命增加到77岁（2019年数据），那么一个劳动力仅能供养一个退休人员。何况一个劳动力每年缴纳的养老金远远少于之后每年领取的退休金，得多个劳动力才能供养一个退休人员。</p><p>所以说在不调整退休年龄的情况之下，如果平均寿命大幅增加，养老金压力会越来越大，但显而易见，平均寿命还会继续增加。</p><p><strong>2. 计划生育，中国提前步入老年化</strong></p><p>计划生育的一个影响是，新生儿出生率呈断崖式的下跌。这意味着劳动力人口的增长率页呈下跌趋势。</p><p>计划生育从70年代开始实施，70年代末后正式成为一项基本国策。以此推算，到2020年，实行计划生育之前出生的女性职工正式开始退休，到2030年，实行计划剩余之前的男性职工也开始正式退休。</p><p>目前，中国60岁以上的人口2.52亿，而1963年到1970年间出生的人口大约3亿，也就是说到2030年，60岁以上的人口将到5亿，这是很可怕的。</p><p>这么多的老年人口，对养老保险而言，是个很大很重的负担。</p><p><strong>3. 中国养老保险制度实施较晚</strong></p><p>中国的养老保险制度发展颇为曲折，直到1997年，才决定实施社会统筹和个人缴纳相结合的新的养老保险制度。</p><p>这就出现了养老保险的隐形债务问题。由于已经工作和退休的人员没有过去的积累，而他们又必须按新制度领取养老金，那么他们应得的，实际有没有缴纳的那部分，就是隐形的债务。</p><p>因为社会统筹的资金远远不够支付庞大的退休群体的需要。各省、市、县为了按时足额发放养老金，就挪用了本应是将来才能支付的现在在职职工个人账户的资金(社会统筹和个人账户没有分开管理)，从而造成了全国范围内养老金的有名无实，空账运行。</p><p>公开数据显示，我国养老保险个人账户空账规模已经超过1万多亿，虽然做实空账工作已经开展几年，但是空账规模扔在扩大。从债务关系来说，养老金的空账运转是现在向未来透支，是老一代向年轻一代的透支。长此下去必然蕴涵巨大的资金风险，</p><h3 id="如何应对延迟退休"><a href="#如何应对延迟退休" class="headerlink" title="如何应对延迟退休"></a>如何应对延迟退休</h3><p>首先我们要摒弃一个观念，即退休之后，完全靠退休金生活（体制内除外），不信，看下面各个年代的口号：</p><blockquote><p>1985年，宣传口号是”计划生育好，政府来养老”</p><p>1995年，宣传“只生一个好，政府帮养老”</p><p>2005年，宣传“养老不能全靠政府“</p><p>2012年，推出“推迟退休好，自己来养老”</p></blockquote><p>再过几年，会是啥口号呢，你猜~~</p><p>既然延迟退休是无法避免的趋势，那我们应该如何应对延迟退休呢？答案就是尽早开始自己的储蓄计划，无论是财务自由计划，还是养老金储蓄计划，都应该早早的开始。等到了真退休的时候，国家的每一笔退休金，都可以当成额外的收入，岂不美哉？</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#1——如何开始？</title>
    <link href="/2020/10/10/invest-pratice-1/"/>
    <url>/2020/10/10/invest-pratice-1/</url>
    
    <content type="html"><![CDATA[<p>这个系列的第零篇是 <a href="https://afreecoder.cn/2020/07/18/invest-pratice-0/">财务自由实证#0</a>，原本打算每月一篇，没想到这都过去两个月了。过去的就不补了，从10月份开始，立个flag，每月1篇。</p><h2 id="实证进展"><a href="#实证进展" class="headerlink" title="实证进展"></a>实证进展</h2><p>先看下当前进展。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/demonstration1.png" width="50%" height="50%"></p><p>当前进展 1.69%，本周上涨：无。图中记录的软件是且慢小账本（微信小程序），纯手动记录，由于开始几次记录的不完整，收益率等指标可能有偏差，等多记录几次就好了。</p><p>虽然这个实证计划最近才开始，但是实际上投资计划已经开始一年多了，不能完全算从0开始。开始投资的时候，还没有通过投资实现财务自由的想法，纯粹就是希望不贬值，能涨一些就更好。所以当前的账户体系比较混乱，有自己的养老金，也有小孩的教育金，还有一时冲动跟投的不同的投资组合。具体有以下几块：</p><div class="table-container"><table><thead><tr><th>计划</th><th>投资平台</th><th>备注</th></tr></thead><tbody><tr><td>长赢计划-150</td><td>且慢</td><td>主理人E大的公开计划，跟投</td></tr><tr><td>养老金计划</td><td>且慢</td><td>定投，不同指数基金的组合，瞎折腾</td></tr><tr><td>教育金计划</td><td>且慢</td><td>定投，不同指数基金的组合，瞎折腾</td></tr><tr><td>日积月累</td><td>蛋卷</td><td>主理人Alex的公开计划，跟投</td></tr><tr><td>2020短期计划</td><td>且慢</td><td>瞎折腾，指数基金</td></tr><tr><td>其它组合跟投</td><td>且慢</td><td>如云长进取等组合</td></tr></tbody></table></div><p>这两天重新梳理了下，觉得将非教育金计划的其它计划都归入到500万的目标中比较合理。因此当前以及之后的统计中均不会包含教育金计划。上文的截图就是除教育金计划之外的总额。</p><h2 id="如何开始自己的自由计划"><a href="#如何开始自己的自由计划" class="headerlink" title="如何开始自己的自由计划"></a>如何开始自己的自由计划</h2><blockquote><p>在真正重要的事情面前，我们一定要慎重，不能轻易的下决定，尤其是涉及到投资的时候。</p></blockquote><p>如果我们在买衣服甚至买菜的时候能花上半小时和老板讨价还价，并为节省下来的几十、几百暗爽不已，那么在面对投资的时候，就更有必要慢下来好好规划自己手上本就为数不多的本金了。</p><p>目前我的投资体系还在摸索中，同时参考其他人的方法，可以初步分为以下几个步骤：</p><ul><li>彻底了解自己</li><li>规划紧急备用金</li><li>规划必要的保险</li><li>规划3年内要用的钱</li><li>建立长期投资组合</li></ul><h3 id="彻底了解自己"><a href="#彻底了解自己" class="headerlink" title="彻底了解自己"></a>彻底了解自己</h3><p>这一步有3个目标：摸清自己手上有多少资金、平均每月支出多少、平均每月结余多少。</p><p>这一步看起来容易，却也不太容易。相信没有多少人能在10分钟内给出答案。然而这一步也是进行后面几步的前提。如果大家平时有记账习惯的话，这一步就很容易，没有的话，支付宝、微信、各银行软件等都有账本功能，能比较容易的统计出来。</p><p>所以到这，大家不妨先花时间好好梳理下，看下手里有多少钱，每月平均支出多少，又有多少结余。</p><h3 id="规划紧急备用金"><a href="#规划紧急备用金" class="headerlink" title="规划紧急备用金"></a>规划紧急备用金</h3><p>开启投资第一步，规划家庭紧急备用金。</p><p>这一步是投资新手们极易忽略却又是十分重要的一步。是否规划了紧急备用金直接关系着后面的长期投资组合能否顺利进行。</p><p>投资路上，难免会遇到各种各样的意外。小到去个急诊，大到忽然失业等。相信经历了2020年上半年之后，大家对意外情况能有一个更深的认识。</p><p>紧急备用金的作用就是当你真的突然需要用钱的时候，可以无视当前的市场行情，坦然渡过。经常有投资的朋友说，自己清楚的知道当前市场处于谷底，也清楚的知道此时正是需要坚持的时候，但是因为这样或者那样的无奈，必须把用于长期投资的资金提取出来，十分可惜。</p><p>一般而言，家庭紧急备用金需要能覆盖6个月的支出。也就是如果一家人忽然没有任何收入来源，仍然能维持当前生活水平继续生活6个月。注意，这里的支出是要全方位的覆盖，比如常规生活支出、房贷、房租、社保、医保等。</p><p>紧急备用金的要求是安全和随存随取。安全意味着比较合适的投资途径就是货币基金、国债或者银行存款。随存随取意味着比较合适的途径就是货币基金（余额宝等）和银行存款（短期存款，）了。</p><h3 id="规划必要的保险"><a href="#规划必要的保险" class="headerlink" title="规划必要的保险"></a>规划必要的保险</h3><p>保险的重要性怎么强调都不为过。哪怕你没有实现财务自由的计划和想法，也需要给自己和家人配置一份完善的保险。</p><p>大多数人家里都没矿，并且谁也不能保证不会遇到重大疾病或者事故。而且但凡遇到，就不是紧急备用金能解决的，甚至把家底掏空都有可能。所以在配置了紧急备用金之后，一定要尽快的把必要的保险都配置上，这样才能在投资长跑中没有后顾之忧</p><p>但是也不能本末倒置，保险的作用是为我们在实现既定目标的路上，保驾护航，保险并不是我们的目标。因此这部分配置完善即可，不需要过度配置。</p><h3 id="规划3年内要用的钱"><a href="#规划3年内要用的钱" class="headerlink" title="规划3年内要用的钱"></a>规划3年内要用的钱</h3><p>这一步的作用和紧急备用金的作用类似，都是为了防止突然从长期组合中取钱而影响收益。</p><p>不一样的是如果出现了需要用紧急备用金的情况，意味着这个钱是立马就需要用的，而如果是3年内要用的钱，通常都有缓冲的余地，不用立刻筹集。此外，3年内要用的钱不像紧急备用金那样可以准确估算，常见的开销有买房、买车、结婚、装修、生小孩等，所以这一步的估算大家只能根据自己的实际情况尽可能的估计了。</p><p>3年内要用的钱意味着它的流动性要求没有那么高，比较合适的投资方式就是定期理财和债券基金。如果持有事件超过半年，一般是债券基金收益更高，更推荐。</p><h3 id="建立长期投资组合"><a href="#建立长期投资组合" class="headerlink" title="建立长期投资组合"></a>建立长期投资组合</h3><p>在我的计划里，长期投资组合的目标就是财务自由的目标。所以以后每一期公布的实证进展就是长期投资组合的进展。</p><p>前面几步都是一次性配置，之后就不用管了，而长期投资组合这部分是最耗精力的。这一步，你有各种各样的选择，可以投资股票、基金、债券、黄金等，也可以投资各种股票基金、债券基金，亦或是无脑跟投你信任的主理人的组合。</p><p>关于如何建立长期投资组合，这一块需要讲述的很多。在后续的文章中我会结合我自己的经验，慢慢的展开。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>第一期实证，暂时先讲这么多。之后的实证计划中，我会详细的介绍我当前的组合，并分析优劣。希望在这个过程中，能不断的提升自己的认知，进一步完善自己的长期投资组合，同时也能向你们证明，工薪族仅仅依靠工资是能实现财务自由的。</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FAQBot 实践系列#1 —— 从开源语料入手</title>
    <link href="/2020/09/19/faq-bot-1/"/>
    <url>/2020/09/19/faq-bot-1/</url>
    
    <content type="html"><![CDATA[<h2 id="语料"><a href="#语料" class="headerlink" title="语料"></a>语料</h2><p>FAQBot构建的基础是有一份高质量的问答语料。通过不断的搜索和查找，找到一份 <code>保险行业</code> 的问答语料：<a href="https://github.com/chatopera/insuranceqa-corpus-zh">insuranceqa-corpus-zh</a></p><h3 id="语料背景"><a href="#语料背景" class="headerlink" title="语料背景"></a>语料背景</h3><p>该语料库包含从网站 <a href="https://www.insurancelibrary.com/">Insurance Library</a> 收集的问题和答案。<br>以下是官方介绍：</p><blockquote><ul><li><p>该语料库的内容由现实世界的用户提出，高质量的答案由具有深度领域知识的专业人士提供。 所以这是一个具有真正价值的语料，而不是玩具。</p></li><li><p>在上述论文中，语料库用于答复选择任务。 另一方面，这种语料库的其他用法也是可能的。 例如，通过阅读理解答案，观察学习等自主学习，使系统能够最终拿出自己的看不见的问题的答案。</p></li><li><p>数据集分为两个部分“问答语料”和“问答对语料”。问答语料是从原始英文数据翻译过来，未经其他处理的。问答对语料是基于问答语料，又做了分词和去标去停，添加label。所以，”问答对语料”可以直接对接机器学习任务。如果对于数据格式不满意或者对分词效果不满意，可以直接对”问答语料”使用其他方法进行处理，获得可以用于训练模型的数据。</p></li></ul></blockquote><h3 id="语料格式"><a href="#语料格式" class="headerlink" title="语料格式"></a>语料格式</h3><p>训练数据之前，我们先仔细看下语料的格式。</p><h4 id="原始语料"><a href="#原始语料" class="headerlink" title="原始语料"></a>原始语料</h4><p>原始语料的目录是 <code>/corpus/pool</code>。 </p><p><strong>问题</strong></p><p>train，test，valid 是存放问题的文件，分别对应着训练集、测试集和验证集。对应的 txt 文件中是中英对照的问题，json 文件中的信息比较全，包含了中英对照的问题，问题的领域（类别），对应的答案以及错误的答案（负样本）。示例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;0&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;zh&quot;</span>: <span class="hljs-string">&quot;医疗保险拿起公司支付吗？&quot;</span>,<br>        <span class="hljs-attr">&quot;en&quot;</span>: <span class="hljs-string">&quot;Does  Medicare  Pick  Up  Co  Pays?&quot;</span>,<br>        <span class="hljs-attr">&quot;domain&quot;</span>: <span class="hljs-string">&quot;medicare-insurance&quot;</span>,<br>        <span class="hljs-attr">&quot;answers&quot;</span>: [<br>            <span class="hljs-string">&quot;4436&quot;</span><br>        ],<br>        <span class="hljs-attr">&quot;negatives&quot;</span>: [<br>            <span class="hljs-string">&quot;1650&quot;</span>,<br>            <span class="hljs-string">&quot;14016&quot;</span>,<br>            <span class="hljs-string">&quot;24487&quot;</span>,<br>            <span class="hljs-string">&quot;18224&quot;</span>,<br>            <span class="hljs-string">&quot;15953&quot;</span>,<br>            <span class="hljs-string">&quot;16740&quot;</span><br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>zh</code> 是根据答案原文翻译过来的，翻译质量一般。比如示例中英文的意思其实是问【医疗保险会承担挂号费吗】（ <code>co-pay</code> 是看医生前需要支付的定额费用，类似挂号费），如果直接看翻译就不知所云了。<code>answers</code> 和 <code>negatives</code> 中的数字表示对应答案的id，下面会提到。</p><p><strong>答案</strong></p><p><code>answers</code> 中包含了答案的id和答案的中英文对照。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;0&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;zh&quot;</span>: <span class="hljs-string">&quot; 汽车跟随着。示例1：如果你被给了一辆汽车（借给），那辆车没有保险，你可以在汽车上买保险，你的保险将是主要的。另一个选择，有人帮你买车。例如，您的信用评分不足以融资，因此您的朋友在您的贷款下签署了主要付款人。您可以根据您的姓名获得保险，甚至将您的朋友列为保险单，作为损失赔偿人。在这种情况下，我们总是建议您获得贷款差距：汽车的实际现金价值与其仍然拥有的金额之间的差额。例2：你借的车有保险。您可以以您的名义购买政策，列出该政策的车辆，如果发生事故，您的政策将成为次要或超额。一旦主要汽车保险的限制用尽，您的保险将踢入，并希望支付其余费用。我特意用了这个词，因为每个事故都是独一无二的，没有实际的索赔情况就很难解释这个覆盖面。即使在给定的索赔情况下，有时索赔有两个可能的结果。&quot;</span>,<br>        <span class="hljs-attr">&quot;en&quot;</span>: <span class="hljs-string">&quot; Coverage follows the car. Example 1: If you were given a car (loaned) and the car has no insurance, you can buy insurance on the car and your insurance will be primary. Another option, someone helped you to buy a car. For example your credit score isn&#x27;t good enough to finance, so a friend of yours signed under your loan as a primary payor. You can get insurance under your name and even list your friend on the policy as a loss payee. In this case, we always suggest you get a loan gap coverage: the difference between the car&#x27;s actual cash value and the amount still owned on it. Example 2: The car you are loaned has insurance. You can buy a policy under your name, list the car on that policy and in case of the accident, your policy will become a secondary or excess. Once the limits of the primary car insurance are exhausted, your coverage would kick in and hopefully pay for the rest. I specifically used the word hopefully, because each accident is unique and it&#x27;s hard to interpret the coverage without the actual claim scenario. And even with a given claim scenario, sometimes there are 2 possible outcomes of a claim.&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="加工语料"><a href="#加工语料" class="headerlink" title="加工语料"></a>加工语料</h4><blockquote><p>使用原始语料，还需要做很多工作才能进入机器学习的模型，比如分词，去停用词，去标点符号，添加label标记。所以，在原始语料的基础上，，insuranceqa-corpus-zh提供了一个使用HanLP分词和去标，去停，添加label的数据集，这个数据集完全是基于原始语料</p></blockquote><p>加工语料的目录是：<code>corpus/pairs</code></p><p><strong>词表</strong><br><code>vocab_data</code> 包含<code>word2id</code> (dict, 从word到id), <code>id2word</code> (dict, 从id到word),<code>tf</code> (dict, 词频统计)和 <code>total</code> (单词总数)。 其中，未登录词的标识为 <code>UNKNOWN</code>，未登录词的id为0。</p><p><strong>数据格式</strong><br>train、test、valid中的数据格式一直。示例中 <code>qid</code> 对应原始语料中问题的 <code>id</code>。 <code>question</code> 中的数值表示分词后，该词对应的<code>id</code>，即 <code>word2id</code> 的查表结果。<code>utterance</code> 是回复，<code>label</code> 如果是 <code>[1,0]</code> 代表回复是正确答案，<code>[0,1]</code> 代表回复不是正确答案，所以 <code>utterance</code> 包含了正例和负例的数据。每个问题含有10个负例和1个正例。该项目并没有说明负样本的采集方式。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;qid&quot;</span>:<span class="hljs-string">&quot;344&quot;</span>,<br>    <span class="hljs-attr">&quot;question&quot;</span>:[<br>        <span class="hljs-number">2462</span>,<span class="hljs-number">3206</span>,<span class="hljs-number">8878</span>,<span class="hljs-number">17449</span>,<span class="hljs-number">11331</span><br>    ],<br>    <span class="hljs-attr">&quot;utterance&quot;</span>:[<br>        <span class="hljs-number">8878</span>,<span class="hljs-number">17449</span>,<span class="hljs-number">11331</span>,<span class="hljs-number">3206</span>,<span class="hljs-number">9757</span>,<span class="hljs-number">21338</span>,<span class="hljs-number">4757</span>,<span class="hljs-number">11331</span>,<span class="hljs-number">13381</span>,<span class="hljs-number">10310</span>,<span class="hljs-number">10114</span>,<span class="hljs-number">6069</span>,<span class="hljs-number">5231</span>,<span class="hljs-number">13346</span>,<span class="hljs-number">4185</span>,<span class="hljs-number">12750</span>,<span class="hljs-number">6568</span>,<span class="hljs-number">5425</span>,<span class="hljs-number">3206</span>,<span class="hljs-number">10114</span>,<span class="hljs-number">11705</span>,<span class="hljs-number">6194</span>,<span class="hljs-number">13402</span>,<span class="hljs-number">23991</span>,<span class="hljs-number">11273</span>,<span class="hljs-number">8231</span>,<span class="hljs-number">490</span>,<span class="hljs-number">10299</span>,<span class="hljs-number">9757</span>,<span class="hljs-number">9843</span>,<span class="hljs-number">18157</span>,<span class="hljs-number">13334</span>,<span class="hljs-number">23611</span>,<span class="hljs-number">1907</span>,<span class="hljs-number">10099</span>,<span class="hljs-number">6568</span>,<span class="hljs-number">7344</span>,<span class="hljs-number">1704</span>,<span class="hljs-number">16818</span>,<span class="hljs-number">2311</span>,<span class="hljs-number">6683</span>,<span class="hljs-number">12268</span>,<span class="hljs-number">7197</span>,<span class="hljs-number">9757</span>,<span class="hljs-number">11869</span>,<span class="hljs-number">23800</span>,<span class="hljs-number">10617</span>,<span class="hljs-number">1134</span>,<span class="hljs-number">22430</span>,<span class="hljs-number">23810</span>,<span class="hljs-number">9843</span>,<span class="hljs-number">14297</span>,<span class="hljs-number">10227</span>,<span class="hljs-number">14005</span>,<span class="hljs-number">5526</span>,<span class="hljs-number">12360</span>,<span class="hljs-number">13467</span>,<span class="hljs-number">16917</span>,<span class="hljs-number">22724</span>,<span class="hljs-number">22086</span>,<span class="hljs-number">24346</span>,<span class="hljs-number">20333</span>,<span class="hljs-number">12268</span><br>    ],<br>    <span class="hljs-attr">&quot;label&quot;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="语料统计"><a href="#语料统计" class="headerlink" title="语料统计"></a>语料统计</h3><div class="table-container"><table><thead><tr><th>语料集</th><th>类别（Q/A）</th><th>最大长度</th><th>平均长度</th></tr></thead><tbody><tr><td>train</td><td>Q</td><td>42</td><td>5</td></tr><tr><td>train</td><td>A</td><td>878</td><td>162</td></tr><tr><td>test</td><td>Q</td><td>33</td><td>5</td></tr><tr><td>test</td><td>A</td><td>878</td><td>161</td></tr><tr><td>valid</td><td>Q</td><td>31</td><td>5</td></tr><tr><td>878</td><td>A</td><td>878</td><td>165</td></tr></tbody></table></div><h2 id="Baseline复现"><a href="#Baseline复现" class="headerlink" title="Baseline复现"></a>Baseline复现</h2><h3 id="环境准备-训练"><a href="#环境准备-训练" class="headerlink" title="环境准备+训练"></a>环境准备+训练</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">// git <span class="hljs-built_in">clone</span><br>git <span class="hljs-built_in">clone</span> git@github.com:chatopera/insuranceqa-corpus-zh.git<br><br>// 安装环境依赖<br>pip install -r Requirements.txt<br><br>// 更新数据处理的代码<br>pip install --upgrade insuranceqa_data<br><br>// 模型训练<br>python3 deep_qa_1/network.py<br></code></pre></td></tr></table></figure><p>训练的过程中可能会出现以下错误：</p><ol><li>ssl.SSLError 问题<ul><li>原因是 insuranceqa_data 加载数据的时候，读取数据的路径是绝对路径，读不到数据文件，触发下载，需要修改 insuranceqa_data 中的加载路径为：<code>curdir = os.getcwd()</code> </li><li>本质原因是 Python3 请求https时，会对ssl进行校验，要么安装证书，要么关闭校验，具体方法百度即可。</li></ul></li><li>ImportError: Python is not installed as a framework. <ul><li>mac 下使用matplotlib画图可能会出现这个问题。根据报错提示，在涉及画图的代码中加上 <code>import matplotlib; matplotlib.use(&#39;TkAgg&#39;)</code> 即可</li></ul></li></ol><h3 id="训练结果"><a href="#训练结果" class="headerlink" title="训练结果"></a>训练结果</h3><p><strong>主要训练参数</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">hidden_layers</span> = [<span class="hljs-number">100</span>, <span class="hljs-number">50</span>]<br><span class="hljs-attr">question_max_length</span> = <span class="hljs-number">20</span><br><span class="hljs-attr">utterance_max_length</span> = <span class="hljs-number">99</span><br><span class="hljs-attr">lr</span> = <span class="hljs-number">0.001</span><br><span class="hljs-attr">epoch</span> = <span class="hljs-number">50</span><br><span class="hljs-attr">batch_size</span> = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p><strong>准确率</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/insuranceqa_baseline_accuracy.png" alt="accuracy"></p><p><strong>loss变化</strong></p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/insuranceqa_baseline_loss.png" alt="loss"></p><p>可以看到，准确率到了0.9之后几乎就不变了，loss开始下降的很快，之后在0.8附近剧烈波动，说明这个时候再进行更多的迭代训练并不会对准确率的提升有显著的效果，baseline的方法已经到了极限，需要寻找更好的算法了。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>至此，baseline 已经复现完毕。接下来的文章准备以此为基础，不断优化算法，在此基础之上尽可能的提高准确率。</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>财务自由实证#0——自由能实现吗?</title>
    <link href="/2020/07/18/invest-pratice-0/"/>
    <url>/2020/07/18/invest-pratice-0/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>受公众号 <code>【也谈钱】</code> 的影响，以及互联网加班的摧残，觉得有必要早早的开始梳理家庭的财务状况，并且制定财务自由的目标和方案，为自由而奋斗。</p><h2 id="财务自由的目标"><a href="#财务自由的目标" class="headerlink" title="财务自由的目标"></a>财务自由的目标</h2><p>设置 <strong>财务自由</strong> 的目标前，首先需要知道财务自由的定义，明确自己需要实现的是哪种等级的财务自由，才能以此为依据，制定出切实可行的计划，并开始行动。</p><p>这里我拍脑袋定了一个目标：</p><ul><li><strong>目标</strong>：500万（流动性资产）</li><li><strong>期限</strong>：25年</li></ul><p>下面详细解释下这个脑袋是怎么拍的。</p><h3 id="什么是财务自由？"><a href="#什么是财务自由？" class="headerlink" title="什么是财务自由？"></a>什么是财务自由？</h3><p>经常能看到一些标题党文章如 <a href="https://www.sohu.com/a/309461248_120139549">2.9亿？！《2019北京财务自由等级图鉴》出炉！</a> 等等，看完之后瞬间觉得财务自由此生无望。。。</p><p><strong>实际上</strong></p><blockquote><p>财务自由是指你无需为生活开销而努力为钱工作的状态。简单地说，你的资产产生的被动收入必须至少要等于或超过你的日常开支。—<a href="https://zh.wikipedia.org/wiki/%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1">wikipedia</a></p></blockquote><p>根据上面的定义，实现了被动收入大于日常开支就能实现财务自由。听起来很简单有没有~~</p><p>被动收入的等级无法衡量，但是日常支出是可以衡量的。结合近几年财务自由越来越丰富的内涵，财务自由的等级可以戏分如下：</p><ul><li>外卖自由</li><li>打车自由</li><li>商场自由</li><li>租房自由</li><li>旅游自由</li><li>辞职自由</li><li>买车自由</li><li>买房自由<br>……</li></ul><p>我这里使用的并且希望达到的目标就是财务自由最原本的定义，即日常生活开销的自由。</p><h2 id="财务自由的可行性"><a href="#财务自由的可行性" class="headerlink" title="财务自由的可行性"></a>财务自由的可行性</h2><p>理论上被动收入没有上限，但是实现的难度也成指数上升，因此这里通过对日常生活开销的预估来倒推需要多少被动收入。</p><h3 id="日常开销预估"><a href="#日常开销预估" class="headerlink" title="日常开销预估"></a>日常开销预估</h3><p>因为实现财务自由一定是很多很多年后，我们需要根据当前的生活水平来推断20年甚至30年之后的日常开支水平。下面尝试通过一些数据的分析来预估25年后的日常开销。</p><h4 id="通货膨胀"><a href="#通货膨胀" class="headerlink" title="通货膨胀"></a>通货膨胀</h4><p>一说到财务自由的具体目标，很多小伙伴都会想到通货膨胀，说你现在定这么一个目标，多少年之后，钱早就不值钱了，有什么用？</p><p>确实，通货膨胀的因素不能不考虑。</p><blockquote><p>在实践中，一般不直接、也不可能计算通货膨胀率，而是通过价格指数的年增长率来间接表示。</p><p>由于居民消费价格是反映商品经过流通各环节形成的最终价格，它最全面地反映了商品流通对货币的需要量，因此，居民消费价格指数是最能充分、全面反映通货膨胀率的价格指数。目前，世界各国基本上均用居民消费价格指数，也就是CPI来反映通货膨胀的程度。</p></blockquote><p>看下几个主要国家居民消费价格指数(CPI)年率（同比）数据。</p><p><strong>中国居民消费价格指数年率</strong><br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/China_cpi_year.png" alt="中国居民消费价格指数年率"></p><p><strong>日本居民消费价格指数年率</strong><br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/Japan_cpi_year.png" alt="日本居民消费价格指数年率"></p><p><strong>美国居民消费价格指数年率</strong><br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/USA_cpi_year.png" alt="美国居民消费价格指数年率"></p><p><strong>英国居民消费价格指数年率</strong><br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/UK_cpi_year.png" alt="英国居民消费价格指数年率"></p><p><strong>德国居民消费价格指数年率</strong><br><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/German_cpi_year.png" alt="德国居民消费价格指数年率"></p><p>对比5个国家发现，中国在2000年前，CPI年率有过两次高峰，2012年后，CPI年率基本稳定在3%附近，2020年初则是因为疫情的影响又高了起来。</p><p>其它4个国家都是发达国家，日本在1995年后，CPI年率一直稳定在1.3%下面，2015附近年有过一次波峰，和2010附近的波谷正好抵消。美国自1993年之后，CPI年率一直在3%下面，但整体高于日本；英国自1993年之后，CPI年率基本在3%下面，但是它的波动较大，其中一半的时间CPI年率都在2%下面；德国1996年之后绝大部分时间都在2%下面。</p><p>中国由于改革开放，造就了此后30年经济的高速增长，这也是工资、物价飞速增长的30年。但是近些年，我们能明显的感受到，经济的增长速度慢了下来，嗯，也叫经济新常态。之后还可能会进一步降低，降低到和老牌发达国家一样的低增速水平，这也意味着在接下来的一个较长的时期内，CPI年率会一直处于3%以下，并且大部分时间都达不到3%的水平。</p><p>假设当前的物价是1，那么以3%的CPI年率计算，25年后，物价是2.1，翻了一倍，也就是说，同等数量的钱，25年后购买力降低了一半。</p><h4 id="支出项预估"><a href="#支出项预估" class="headerlink" title="支出项预估"></a>支出项预估</h4><p>上面从宏观层面分析了未来20、30年物价可能出现的增长情况，这部分是我们作为个体所无法控制或者较难控制的。我们唯一能控制的就是日常支出。</p><p>然而这一部分也是最难预估的一部分。就目前而言，每月固定开销就有房租、房贷、保险、日常消费等，再过几年还会会有小孩的教育费用等各种无法预料的支出。</p><p>日常开支里，日常生活开销的其实占比很小，大头还是房贷、教育支出等。因此这部分思路如下：将人生分为两个阶段，目标完成前和目标完成后，分别考虑支出。</p><div class="table-container"><table><thead><tr><th>支出项</th><th>25年期间</th><th>25年之后</th></tr></thead><tbody><tr><td><strong>房贷</strong></td><td>有（较大）</td><td>无（房贷25年）</td></tr><tr><td><strong>子女教育支出</strong></td><td>有（较大）</td><td>无</td></tr><tr><td><strong>大病支出</strong></td><td>保险覆盖</td><td>保险覆盖</td></tr><tr><td>赡养</td><td>有（较低）</td><td>有（稍大）</td></tr><tr><td>保险支出</td><td>有</td><td>少量</td></tr><tr><td>日常家庭开支</td><td>有</td><td>有</td></tr><tr><td>其它</td><td>有</td><td>有</td></tr></tbody></table></div><p>这里面真正大头的是房贷、子女教育支出和大病支出。除掉这三块之后，其它的其实没有多少。也就是说，相同的钱，在这25年里和25年后，所带来的幸福感是完全不同的。</p><p>那么在一线城市，25年后，在没有房贷和子女教育费用的情况下，一年需要需要多少收入能过的比较幸福呢？</p><p>我的答案是50万。</p><p>换算到现在，依据当前物价水平，在年被动收入25万且没有房贷和子女教育支出的情况下可以过的的比较幸福。一般消费都能支撑的起，还能偶尔奢侈一把。</p><p>考虑到25年后，自己可能还在工作，或者领取退休金，所以实际的生活幸福感会更高。</p><p><strong>注：这里不考虑疾病支出是因为这部分的支出可以通过一个完备的保险计划来覆盖掉。关于如何配置好家庭保险，之后会单独拎出来介绍。</strong></p><h3 id="500万的目标是否合理"><a href="#500万的目标是否合理" class="headerlink" title="500万的目标是否合理"></a>500万的目标是否合理</h3><h4 id="500万够不够？"><a href="#500万够不够？" class="headerlink" title="500万够不够？"></a>500万够不够？</h4><p>根据上面的拍脑袋，25年后被动收入50万就能完全覆盖家庭的日常开支。</p><p>每年50万的被动收入，本金500万的情况下，需要的年化收益率是10%。这个收益率的要求是比较高的，因为那个时候，我们对资产配置的要求已经从获取超额收益变成了获取稳定收益，能承受的风险水平大大降低，相应的收益率水平也会降低。</p><p>但是假设25年后，立即退休，开始领取养老金，社保交25年对应的养老金的替代率能达到50%，有这笔收入作为补充，需要实现的稳定收益率会大大降低，大约6%-7%附近，还是可行的。</p><p>这么一看，500万的目标是合理的。</p><h4 id="能不能通过工资实现？"><a href="#能不能通过工资实现？" class="headerlink" title="能不能通过工资实现？"></a>能不能通过工资实现？</h4><p>同居民消费价格指数一样，未来20、30年，在不出现科技突破导致生产力水平再一次突飞猛进的情况下，工资水平大概率会以一个较低的增长率水平缓慢增长。</p><p>以美国为例，看一下1990年-2018年这28年间 <a href="https://www.statista.com/statistics/200838/median-household-income-in-the-united-states/">美国家庭收入中位数</a> 的变化，最低是1993年的52334，最高是2018年63179，也就是说，这28年间工资的最大增幅才20%。</p><p>当然，如果再去看一下1990年-2018年间 <a href="https://www.ceicdata.com/zh-hans/indicator/united-states/annual-household-income-per-capita">美国家庭人均收入</a> 的变化，你会惊讶的发现其呈稳定增长趋势。结合上面的美国家庭收入中位数几乎不变的事实，可以得出这样一个结论：美国的贫富差距正在迅速扩大。</p><p>中国大概率也会进入这样的状态，当然，考虑到未来一段时间内，中国的经济增长水平仍然会维持在一个中低速增长的水平，因此工资水平还是会有一段时间的中低速的增长，只是不可能会像改革开放之后30年内，出现隔一段时间就翻一番的场景了。</p><p>低速增长的工资水平和物价水平相抵消，意味着很难通过工资实现资本的快速积累，但同时这也意味着在相当长的一段时间内，我们可以维持一个相对稳定的储蓄率。</p><h4 id="能不能攒到500万？"><a href="#能不能攒到500万？" class="headerlink" title="能不能攒到500万？"></a>能不能攒到500万？</h4><p>假设初始金额为0，目标500万，不同期限下每月投入金额和需要的年化收益率的对应关系如下：</p><div class="table-container"><table><thead><tr><th>每月投入金额</th><th>年复合收益率（15年）</th><th>年复合收益率（20年）</th><th>年复合收益率（25年）</th><th>年复合收益率（30年）</th></tr></thead><tbody><tr><td>500</td><td>47.141%</td><td>31.252%</td><td>22.936%</td><td>17.879%</td></tr><tr><td>1000</td><td>39.033%</td><td>25.719%</td><td>18.724%</td><td>14.469%</td></tr><tr><td>1500</td><td>34.374%</td><td>22.492%</td><td>16.243%</td><td>12.445%</td></tr><tr><td>2000</td><td>31.095%</td><td>20.198%</td><td><strong>14.467%</strong></td><td>10.987%</td></tr><tr><td>2500</td><td>28.561%</td><td>18.411%</td><td>13.075%</td><td>9.840%</td></tr><tr><td>3000</td><td>26.493%</td><td>16.943%</td><td>11.926%</td><td>8.890%</td></tr><tr><td>5000</td><td>20.693%</td><td>12.772%</td><td>8.632%</td><td>6.143%</td></tr></tbody></table></div><p>综合考虑自己的个人情况，认为每月投入2000，实现15%的年化收益率这种方案比较适合自己。这里面每月投入2000很简单，但是实现15%的收益率不太容易，需要持续不断的投入精力学习各种理财知识。</p><p>那么实现接近15%的年化收益率，难度高吗？这里以沪深300指数为例，沪深300指数基日是2004年12月31日，基点是1000点，2020年1月3号是4144点，折算成年化收益率是9.941%。如果配合一定的策略，完全是可以获取更高的收益率水平的。</p><p>因此，如何构建自己的投资体系，实现15%的超额收益，也是<code>【财务自由实证系列】</code>的一个目标之一。</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>本篇算是 <code>【财务自由实证系列】</code> 的一个序，之后这个系列会定期公开自己财务自由计划的进展，记录自己在实现这个目标过程中的点点滴滴，同时证明这样的一个财务自由计划是完全有可能实现的。</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="公众号二维码"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>财务自由实证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Modules 简介</title>
    <link href="/2020/06/27/Go-Modules-md/"/>
    <url>/2020/06/27/Go-Modules-md/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>In Go 1.14, module support is considered ready for production use, and all users are encouraged to migrate to modules from other dependency management systems.</p></blockquote><p>在go1.14中，模块支持被认为已经可以在生产环境中使用，因此鼓励所有用户将项目中的依赖管理系统都迁移到Go Mudules中。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="Go-版本升级"><a href="#Go-版本升级" class="headerlink" title="Go 版本升级"></a>Go 版本升级</h3><p><strong>查看Go版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go env<br></code></pre></td></tr></table></figure><p>如果显示版本低于1.14，则需要升级。</p><p><strong>下载Go最新版本</strong></p><p>官网地址：<a href="https://golang.org/dl/">https://golang.org/dl/</a> ，下载对应版本。这里以 <code>go1.14.4.darwin-amd64.tar.gz</code> 为例。</p><p><strong>删除旧版本</strong></p><ul><li>通过 <code>go env</code> 获取安装路径（即 <code>GOROOT</code> ），一般是 <code>/usr/local/go</code> 。</li><li><code>rm -rf /usr/local/go</code> </li></ul><p><strong>安装新版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo tar -C /usr/<span class="hljs-built_in">local</span> -xzf go1.14.4.darwin-amd64.tar.gz<br></code></pre></td></tr></table></figure><p>至此，Go1.14 升级完成，so easy~</p><h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><p>由于一些原因，下载Go的各种依赖包的时候，速度很慢，通过一些镜像网站下载的话，可以获得如丝滑般的下载体验。</p><p><strong>常见的Go Modules镜像网站：</strong><br>1、<a href="https://proxy.golang.org/">https://proxy.golang.org/</a><br>GOPROXY 的默认值，这是一个在大陆无法访问的地址。。<br>2、<a href="https://goproxy.io/">https://goproxy.io/</a><br>一个开源的为 Go Modules 而生的全球代理。国内开发者使用的较多，维护者是个人。<br>3、<a href="https://goproxy.cn/">https://goproxy.cn/</a><br>Goproxy 中国，最初开发者是 <a href="https://aofeisheng.com/">@盛傲飞</a>，目前是七牛云托管和维护。你甚至可以像 goproxy.baidu.com 一样将该服务用作上游代理。</p><p><strong>如何设置</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">go env -w GO111MODULE=on<br>go env -w GOPROXY=https://goproxy.cn,direct<br></code></pre></td></tr></table></figure></p><p><strong>趣闻</strong>：<a href="https://github.com/goproxy/goproxy.cn/issues/61">goproxy.io 和 goproxy.cn 是什么关系?</a></p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><blockquote><p>如果使用 Go Modules 来管理依赖，那么你的项目就没有必要在 <code>GOPATH</code> 中了。</p></blockquote><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>1、随便创建一个项目目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir -p /tmp/scratchpad/repo<br><span class="hljs-built_in">cd</span> /tmp/scratchpad/repo<br></code></pre></td></tr></table></figure><p>2、go mod 准备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go mod init xxx/repo<br></code></pre></td></tr></table></figure><p>其中 <code>xxx</code> 是你项目托管的目录。如果是在github上，则是 <code>github.com/yourname/repo</code> 。</p><p>3、测试代码</p><p>repo 下 main.go 中添加如下测试代码</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-string">&quot;github.com/labstack/echo&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>e := echo.New()<br>e.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c echo.Context)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> c.String(http.StatusOK, <span class="hljs-string">&quot;Hello, World!&quot;</span>)<br>&#125;)<br>e.Logger.Fatal(e.Start(<span class="hljs-string">&quot;:1323&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>4、go mod xxx 相关命令</p><div class="table-container"><table><thead><tr><th>xxx</th><th>解释</th></tr></thead><tbody><tr><td>download</td><td>download modules to local cache</td></tr><tr><td>edit</td><td>edit go.mod from tools or scripts</td></tr><tr><td>graph</td><td>print module requirement graph</td></tr><tr><td>init</td><td>initialize new module in current directory</td></tr><tr><td>tidy</td><td>add missing and remove unused modules</td></tr><tr><td>vendor</td><td>make vendored copy of dependencies</td></tr><tr><td>verify</td><td>verify dependencies have expected content</td></tr><tr><td>why</td><td>explain why packages or modules are needed</td></tr></tbody></table></div><h3 id="日常工作流程"><a href="#日常工作流程" class="headerlink" title="日常工作流程"></a>日常工作流程</h3><p>使用 go mod 之后，你的<strong>日常工作流程</strong>应该是这样：</p><ol><li>在代码文件中写好 <code>import</code> 语句</li><li>执行 <code>go run</code> or <code>go build</code> or <code>go test</code>，或者一些其它的标准命令时，会自动下载依赖以及更新 <code>go.mod</code> 文件。</li><li>当你需要指定依赖的版本的时候，你可以使用命令 <code>go get foo@v1.2.3</code>， <code>go get foo@master</code> ，<code>go get foo@e3702bed2</code> 直接下载指定版本（这些命令都会直接更新go.mod），或者直接修改 go.mod 文件。</li></ol><p>一些你可能会用到的其它功能：</p><ol><li><code>go list -m all</code> — 查看全部直接或者间接的依赖</li><li><code>go list -u -m all</code> — 查看全部直接或者间接的依赖版本及最新版本</li><li><code>go get -u ./...</code> or <code>go get -u=patch ./...</code> ,，更新全部直接或者间接依赖到最新 <code>minor</code> 版本或者 <code>patch</code> 版本</li><li><code>go build ./...</code> or <code>go test ./...</code></li><li><code>go mod tidy</code> 精简不必要的依赖，同时增加任何必要的依赖。</li><li><code>go mod vendor</code> — 创建 vendor 目录，并复制依赖到其中。 </li></ol><h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><blockquote><p>A module is a collection of related Go packages that are versioned together as a single unit.</p></blockquote><p>仓库（repository）、模块（module）和 包（package）之间的关联：</p><ul><li>一个仓库包含了一个或多个 Go Modules</li><li>每个模块包含了一个或多个 Go Packages</li><li>每个包 包含了某个路径下的一个或多个 Go Source 文件</li></ul><p>Modules 必须被语义版本化 （遵循 <a href="https://semver.org/">semver</a> 协议），其版本描述格式如 <code>v(major).(minor).(patch)</code> </p><blockquote><ol><li>major (主版本号)：当你做了不兼容的 API 修改，</li><li>minor (次版本号)：当你做了向下兼容的功能性新增</li><li>patch (修订号)：当你做了向下兼容的问题修正</li></ol></blockquote><h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h3><p><code>go.mod</code> 文件中有4个命令：<code>module</code>， <code>require</code>，<code>replace</code>，<code>exclude</code>。</p><p><strong>example</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang">module github.com/my/thing<br><br>require (<br>    github.com/some/dependency v1<span class="hljs-number">.2</span><span class="hljs-number">.3</span><br>    github.com/another/dependency/v4 v4<span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>)<br></code></pre></td></tr></table></figure><p><code>module</code> 命令声明了当前模块的名称以及导入路径。</p><p><code>require</code> 命令标明了当前模块所依赖的模块。</p><p><code>replace</code> 和 <code>exclude</code> 命令仅对当前模块生效，即 build 主模块时，其它依赖模块中的 <code>replace</code> 和 <code>exclude</code> 命令都会被忽略掉。</p><h3 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h3><p>如果当前模块依赖的一个模块名是 M，当你还没有将 M 添加到 <code>go.mod</code> 中的时候，如果执行 <code>go build</code> 或者 <code>go test</code> 等命令，会自动拉取 M 并将其添加到 <code>go.mod</code> 中，拉取规则如下：</p><ul><li>拉取 M 最新的发行版本 v1.2.3，如果没有发行版本，则拉取最新的master的commit</li><li>如果当前模块中的依赖 A 依赖 M v1.0.0，B 依赖 M v1.2.3，那么会选择 M v1.2.3 (最小版本选择算法)</li></ul><h3 id="语义导入版本控制"><a href="#语义导入版本控制" class="headerlink" title="语义导入版本控制"></a>语义导入版本控制</h3><p>这里说的是导入模块的时候，包的路径应该与模块版本相符。</p><p>具体规则如下：</p><ul><li>模块的版本命令应该遵从 <a href="https://semver.org/">semver</a> 协议。</li><li>如果该模块的版本是 v2 或者更高，那么 <code>go.mod</code> 中声明该模块的时候，需要加上 <code>/v2</code> 的后缀，如 <code>module github.com/my/mod/v2</code> 或者 <code>require github.com/my/mod/v2 v2.0.1</code>。这种用法也被用在 <code>go get</code> 命令中，如 <code>go get github.com/my/mod/v2@v2.0.1</code></li></ul><h2 id="FAQs"><a href="#FAQs" class="headerlink" title="FAQs"></a>FAQs</h2><p><strong>1、go.mod 中模块被标记成 <code>incompatible</code> 是什么意思</strong></p><p><strong>答：</strong> 如果 <code>Module</code> 的名字没有遵循 Golang 的规范，即在模块名中附带版本信息，那这就是一个不规范的模块，就会提示 <code>incompatible</code>。以 <code>github.com/labstack/echo</code> 为例，如果其当前版本是 <code>v3.3.10</code> ，那么 go.mod 中会这样显示：<code>github.com/labstack/echo v3.3.10+incompatible</code> 。</p><p>想象一下，如果 <code>github.com/labstack/echo</code> 更新到了 <code>v4.1.1</code> ，如果你的模块依赖它，并且执行了更新全部依赖的命令会怎么样？ <code>github.com/labstack/echo</code> 会更新到 <code>v4.1.1</code>，但是根据 <a href="https://semver.org/">semver</a> 协议，v4 是不兼容 v3 的，这个时候你的模块就会出问题。如果依赖符合规范，如 <code>github.com/labstack/echo/v3</code> ，那你更新全部依赖后，也只是将版本更新到 <code>v3.9.9</code> 或者小于 <code>v4</code> 的最大一个版本，不会出现兼容性的问题。</p><p>当模块的版本小于等 v1 的时候，模块名默认不需附带版本信息。</p><p><strong>2、为什么 <code>go mod tidy</code> 会记录 <code>inderect</code> （非直接）依赖和测试依赖？</strong></p><p><strong>答：</strong> <code>go mod dity</code> 会尽可能的反应出所需要的全部环境下（有可能是系统、处理器架构或者build tags）的依赖，而 <code>go build</code> 和 <code>go test</code> 仅仅是更新 <code>go.mod</code> ，添加当前环境的依赖。</p><p><strong>3、如何在不支持 Module 的模块 A 中导入支持 Module 的 v2+ 的 模块 B?</strong></p><p><strong>答：</strong> 这需要看 module B 是如何发布 v2+ module 的。</p><ol><li>如果是在主分支，在 go.mod 中通过 <code>module</code> 声明 <code>/v3</code> <ul><li>模块 A 中不需要修改导入路径 （即使改了编译的时候也会忽略路径中的版本信息），在 <code>GOPATH</code> 模式下运行的时候，会选择 <code>GOPATH</code> 中的模块 B 的版本编译。</li></ul></li><li>如果 B 是在 子目录中创建了一个 <code>./v3</code> 目录，然后将 <code>go.mod</code> 文件放在 <code>./v3</code> 中<ul><li>A 中使用 <code>import github.com/xxx/B/v3</code> 是没有问题的。</li></ul></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://github.com/golang/go/wiki/Modules">Go Modules 官方文档</a></li><li><a href="https://juejin.im/post/5d8ee2db6fb9a04e0b0d9c8b">干货满满的 Go Modules 和 goproxy.cn</a></li><li><a href="https://rainbowmango.gitbook.io/go/chapter12/3-foreword/3.7-module-incompatible">Go 专家编程-incompatible</a></li></ol><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go Modules</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL之索引</title>
    <link href="/2020/06/21/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/"/>
    <url>/2020/06/21/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么需要索引"><a href="#为什么需要索引" class="headerlink" title="为什么需要索引"></a>为什么需要索引</h2><p>索引就像书籍的目录一样，可以更快的查找数据。</p><h2 id="常见的索引模型"><a href="#常见的索引模型" class="headerlink" title="常见的索引模型"></a>常见的索引模型</h2><blockquote><p>innodb 索引模型选用B+树是由MySQL的应用场景（等值区间查找、插入删除等操作频繁）及机械磁盘的特点（寻址耗时）决定的。像Redis等一些Nosql数据库，他们的索引模型就是哈希表、跳表等。</p></blockquote><ul><li>数组<ul><li>等值查询很快（数组有序排列的情况下，二分查找）</li><li>区间查询很快</li><li>数据的插入删除很慢</li></ul></li><li>哈希表<ul><li>等值查询极快</li><li>插入删除极快</li><li>区间查询很慢（只能一个个的查找）</li></ul></li><li>搜索树（链表）<ul><li>二叉搜索树<ul><li>等值查询、区间查询很快，效率等于数组的二分查找</li><li>插入删除效率logN，需要树的再平衡，再平衡的效率也是logN</li></ul></li><li>多叉搜索树树<ul><li>相比于二叉树，多叉树一次寻址能取出更多的数据，能大大减少寻址次数</li><li>一个节点下面，叶子节点的个数取决于硬盘上数据块的大小</li></ul></li></ul></li></ul><p>MySQL的应用场景中，等值查询和区间查询是很高频的场景，插入删除操作也十分频繁，因此综合考虑，搜索树最适合作为底层的存储引擎。又因为机械硬盘时代，磁盘寻址的时间成本很高，因此 innodb 底层的那存储引擎选用的索引模型是B+树。</p><p>本文后续主要介绍innodb的索引。</p><h2 id="Innodb中的索引"><a href="#Innodb中的索引" class="headerlink" title="Innodb中的索引"></a>Innodb中的索引</h2><h3 id="主键索引和非主键索引"><a href="#主键索引和非主键索引" class="headerlink" title="主键索引和非主键索引"></a>主键索引和非主键索引</h3><p><strong>主键索引：</strong> 主键索引的叶子结点（最后一层）存储的是数据库的行数据。</p><p><strong>非主键索引：</strong> 非主键索引的叶子节点（最后一层）存储的是主键索引。</p><p>对于一个查询操作，查询条件如果是主键索引，则直接返回结果；如果是非主键索引，则先返回主键，然后根据主键查询主键索引树，再返回结果。</p><p><em>查询原则：尽量使用主键索引查询。</em></p><h3 id="索引类别"><a href="#索引类别" class="headerlink" title="索引类别"></a>索引类别</h3><p>innodb中不同索引类别的特点如下：</p><ul><li>普通索引<ul><li>没有任何限制</li></ul></li><li>唯一索引<ul><li>索引列的值唯一</li><li>允许有空值</li><li>组合索引，列值必须唯一</li></ul></li><li>主键索引<ul><li>只能作用于一个列上</li><li>键值唯一</li><li>不能为空</li></ul></li></ul><p>业务上，如果只有一个索引，并且是唯一索引，可以直接用该字段建立索引（<strong>尽量使用主键索引查询原则</strong>）</p><h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>插入数据或者删除数据，都涉及到索引表的调整。</p><p>插入数据的时候，有可能会导致叶子节点数据的挪动，也可能导致数据页的分裂。(对性能的影响需要结合B+树的增删改查操作)</p><p>删除数据的时候，一般只是对数据标记下删除，并不会立即调整索引树，除非索引树中被删除的数据过多，浪费了大量的空间，则需要重建索引树。</p><p><strong>自增主键的优势</strong></p><ul><li>主键自增，索引树不需要维护主键的有序性</li><li>自增ID占空间较小，非主键索引树占用的空间更小</li></ul><p>索引从性能和存储上考虑，自增ID都是更好的选择。</p><blockquote><p>想象以下，一个用户信息表，如果索引选择身份证号码，那每次新增一条数据，为了保证索引有序，都有可能导致一个数据块上数据重新排列，也能导致一个数据块分裂，显然更耗时。</p><p>如果这个用户信息表还有其它非主键索引树，那它的叶子节点存储的都是18位的身份证号码，显然消耗的空间相较于自增ID要更多</p></blockquote><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><blockquote><p>覆盖索引只是一种场景，或者一种现象，构造出这种现象有利于提高查询性能。</p></blockquote><p>先看一个查询的例子。如果我们有如下的一张表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table T (<br>ID int primary key,<br>k int NOT NULL DEFAULT 0, <br>s varchar(16) NOT NULL DEFAULT &#x27;&#x27;,<br>index k(k))<br>engine=InnoDB;<br><br>insert into T values(100,1, &#x27;aa&#x27;),(200,2,&#x27;bb&#x27;),(300,3,&#x27;cc&#x27;),(500,5,&#x27;ee&#x27;),(600,6,&#x27;ff&#x27;),(700,7,&#x27;gg&#x27;);<br></code></pre></td></tr></table></figure><p>如果执行如下语句，需要查询几次？</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> k <span class="hljs-keyword">between</span> <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>答：查询非主键索引树3次，回表2次。</p><p>同样如果执行下面的语句，需要查询几次？<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select <span class="hljs-built_in">id</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> k <span class="hljs-keyword">between</span> <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><br>答：查询非主键索引树3次，不需要回表。</p><p>如果索引树的查询结果已经包含了我们需要的结果，不需要回表，这种情况就称为覆盖索引。<strong>覆盖索引</strong>是常用的一种性能优手段。</p><h3 id="联合索引和最左前缀原则"><a href="#联合索引和最左前缀原则" class="headerlink" title="联合索引和最左前缀原则"></a>联合索引和最左前缀原则</h3><p>联合索引和最左前缀原则并没有什么必然的联系，这里放在一起讨论是因为联合索引的查找过程会应用到最左前缀原则。</p><h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><blockquote><p>B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</p></blockquote><p>查询的时候，如果查询条件是索引的最左N个字段，或者最左N个字符，都能用上索引，加快查询速度。</p><h4 id="如何安排联合索引的顺序"><a href="#如何安排联合索引的顺序" class="headerlink" title="如何安排联合索引的顺序"></a>如何安排联合索引的顺序</h4><p>联合索引是按照索引项的顺序建立索引的，如（A，B），建立索引的时候，是先按A排序，然后对同一个A，再按B排序，检索的顺序也是如此，先检索A，再检索B。所以建立联合索引的时候，一定要考虑索引的复用 程度。复用程度越高，越要放前面。</p><p>显然如果建立了联合索引（A，B），索引A是不需要单独建立索引的。</p><p>回到之前的覆盖索引，如果有个高频的需求是根据用户的身份证查询姓名，那有必要建立身份证号和姓名的联合索引吗？答案是不考虑索引维护的成本下是有必要的。</p><p>建立了身份证和姓名的联合索引之后，只需要查询联合索引树，就能直接返回查询结果而不需要回表，大大提高查询性能。</p><p>当然，索引的维护是有代价的。因此建立冗余的索引来实现覆盖索引就需要权衡考虑了。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p><strong>题目</strong>：对于如下表，由于历史原因，联合索引（a, b）是必须的，那这里面有不必要的索引吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `geek` (<br>  `a` int(11) NOT NULL,<br>  `b` int(11) NOT NULL,<br>  `c` int(11) NOT NULL,<br>  `d` int(11) NOT NULL,<br>  PRIMARY KEY (`a`,`b`),<br>  KEY `c` (`c`),<br>  KEY `ca` (`c`,`a`),<br>  KEY `cb` (`c`,`b`)<br>) ENGINE=InnoDB;<br></code></pre></td></tr></table></figure><p><strong>答</strong>：ca是不必要的索引。</p><p>对于联合索引（a，b），其内部的组织是先根据a排序，再根据b排序，因此索引树c的内容其实是cab，即先根据c排序，再根据a排序，再根据b排序的一个B+数据。索引树（c，a）的叶子节点实际上是b，树的内容也是cab，和索引树c是一致的，因此ca索引树是不必要的。</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL之事务的隔离性</title>
    <link href="/2020/05/31/mysql%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7/"/>
    <url>/2020/05/31/mysql%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>一提到事务，我们就会想到事务的4个特性ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性和持久性）。本篇文章，主要讲的就是隔离性。</p><p>mysql里面并不是所有的存储引擎都支持事务，因此本文中针对事务的讨论都是基于存储引擎innodb。</p><h2 id="一、隔离级别"><a href="#一、隔离级别" class="headerlink" title="一、隔离级别"></a>一、隔离级别</h2><h3 id="1-1-“隔离级别”的概念"><a href="#1-1-“隔离级别”的概念" class="headerlink" title="1.1 “隔离级别”的概念"></a>1.1 “隔离级别”的概念</h3><blockquote><p>脏读（dirty read）: A 事务可以读到B事务未提交的数据，就叫脏读。<br>不可重复读（no-repeatable read）: 事务A开始时只能看到其它事务已经提交的修改。换句话说，事务A的两次查询可能看到不同的结果。（其它事务中途提交修改）。不可重复读针对的是单条记录。<br>幻读（phantom read）:当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）。</p></blockquote><p>当数据库上有多个事务 <strong>并行执行</strong> 的时候，会出现脏读（dirty read）、不可重复读（no-repeatable read）、幻读（phanton read)的问题，为了解决这些问题，就出现了”隔离级别”的概念。</p><h3 id="1-2-不同的隔离级别"><a href="#1-2-不同的隔离级别" class="headerlink" title="1.2 不同的隔离级别"></a>1.2 不同的隔离级别</h3><p>在谈隔离级别之前，我们首先要直到，你隔离的越严实，效率就会越低。因此很多时候，我们需要在二者之间寻找一个平衡点。</p><p>标准的事务隔离级别有以下几种：</p><ol><li><strong>读未提交</strong>（read uncommited）: 一个事务还没提交时，它做的变更就能被别的事务看到。</li><li><strong>读提交</strong>（read commited）: 一个事务提交之后，它做的变更才会被其他事务看到。</li><li><strong>可重复读</strong>（repeatable read）: 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li><strong>串行化</strong>（sirializable）: 对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ol><h3 id="1-3-隔离级别的修改"><a href="#1-3-隔离级别的修改" class="headerlink" title="1.3 隔离级别的修改"></a>1.3 隔离级别的修改</h3><p><strong>隔离级别的查看</strong><br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; show variables like &quot;%transaction_isolation%&quot;;</span><br><span class="hljs-section">+-----------------------+-----------------+</span><br><span class="hljs-section">| Variable_name         | Value           |</span><br><span class="hljs-section">+-----------------------+-----------------+</span><br><span class="hljs-section">| transaction_isolation | REPEATABLE-READ |</span><br><span class="hljs-section">+-----------------------+-----------------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure></p><p><strong>隔离级别的修改</strong><br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">set</span> [ <span class="hljs-keyword">global</span> | <span class="hljs-keyword">session</span> ] <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">isolation</span> <span class="hljs-keyword">level</span> [ <span class="hljs-keyword">Read</span> <span class="hljs-keyword">uncommitted</span>  | <span class="hljs-keyword">Read</span> <span class="hljs-keyword">committed</span> | <span class="hljs-keyword">Repeatable</span> <span class="hljs-keyword">read</span> | <span class="hljs-keyword">Serializable</span> ];<br></code></pre></td></tr></table></figure><br>注：<code>[]</code> 表示可选。</p><h3 id="1-4-可重复读隔离级别的演示"><a href="#1-4-可重复读隔离级别的演示" class="headerlink" title="1.4 可重复读隔离级别的演示"></a>1.4 可重复读隔离级别的演示</h3><p>由于mysql默认的隔离级别是可重复读，因此这里就以可重复读为例进行演示，其它情况可通过修改隔离级别模拟。</p><p>步骤1：创建测试表，插入测试数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> T(c <span class="hljs-type">int</span>) engine<span class="hljs-operator">=</span>InnoDB;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> T(c) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></p><p>步骤2：起2个事务模仿并发的情况，以下是两个事务中不同操作的执行顺序。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/repeatable%20read.png" alt="可重复读"></p><p>从图中可以看到，右边的事务无论是执行 update 操作，还是提交事务，左边的事务都是看不到的。当左边的事务提交之后，再次查询，才能看到更新之后的数据。完美契合可重复读的定义：事务执行期间看到数据可事务开启时看到的数据一致。</p><p>其它隔离级别读者可自行实验。</p><p><strong>提示</strong> </p><ul><li>如果是读未提交，那在上图第5步的时候，会发现数据发生变化</li><li>如果是读提交，那在上图第7步的时候，会发现数据发生变化</li><li>如果是串行化，那在执行第4步的时候，会失败，必须等左边的事务提交，右边的事务才能继续执行。</li></ul><h3 id="1-5-事务隔离的实现"><a href="#1-5-事务隔离的实现" class="headerlink" title="1.5 事务隔离的实现"></a>1.5 事务隔离的实现</h3><p>实现上，数据库会创建一个视图，访问的时候以视图的逻辑结果为准（<strong><em>注：此视图实为一致性读视图 consistend read view，不是MySQL中特指查询结果的那个视图</em></strong>）。不同时刻启动的事务，会有不同的视图，这意味着不同视图里面的同一条数据会有不同的版本，这就是数据库多版本并发控制（MVCC）。</p><p>“读未提交”隔离级别下，直接读取的最新数据，没有视图的概念；”读提交”隔离级别下，事务中每次执行查询语句前，都会新建一个视图；”可重复读”隔离级别下，事务启动的时候，会创建一个视图，整个事务执行期间都用这个视图；”串行化”隔离级别下，直接用加锁的方式来避免并行访问。</p><p><strong>以可重复读为例:</strong></p><p>在可重复读隔离级别下，不同事务在启动的时候，就拍了不同的”快照”: 一个基于整个库的快照。我们先来看下这个快照是怎么实现的。</p><p>Innodb中每个事务都有一个transaction id，这个id是在事务开始的时候向系统申请的，是按申请顺序严格递增的。</p><p>数据库中的每行数据有多个版本，每一个版本都是和一个transaction id绑定的。比如分别有事务trx_id_1，trx_id_2，trx_id_3 对某行数据进行更新，更新过程中该行数据产生了3个版本v1，v2，v3，记录的时候就会这样记：（v1, trx_id_1），（v2, trx_id_2），（v3, trx_id_3）。实际存储的时候，数据库只会记录最新的记录（v3, trx_id_3）,之前的记录则是通过undo日志计算出来的。</p><p>有了transaction id和多版本的概念，快照的实现方式可以这样描述：</p><ol><li>InnoDB 为每个事务构造了一个<strong>数组</strong>，用来保存这个事务启动瞬间，当前正在<strong>活跃</strong>的所有事务 ID。“活跃”指的就是，启动了但还没提交。</li><li>数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。(<strong>注意：这里的ID的最大值是已经创建过的所有事务ID的最大值</strong>)</li></ol><p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p><p>数据版本的可见性规则，就是基于数据的 trx_id 和这个一致性视图的对比结果得到的。</p><p>假设数据版本对应的事务id为trx_id，则可见性规则如下：</p><ol><li>如果trx_id小于低水位，则数据可见。</li><li>如果trx_id大于高水位，则数据不可见</li><li>如果trx_id在高低水位之间，有两种可能：<ol><li>如果trx_id在数组里，则数据不可见</li><li>如果trx_id不在数组里，则数据可见</li></ol></li></ol><p><strong>此外，如果是这个事务自己更新的数据，它自己还是要认的。</strong> </p><p>假设事务A启动的时候，当前系统中活跃的事务ID为[trx_id_1, trx_id_2, trx_id_3]，最小事务ID为trx_id_1，系统里已经创建过的事务ID的最大值加1为trx_id_max，当前数据版本为（V4，trx_id_x4）。</p><p>如果trx_id_x4 &gt; trx_id_max，就认为当前V4不可见，数据版本根据undolog回退到上一个版本（V3，trx_id_x3），如果trx_id_x3在高低水位之间，并且在数组里面，仍然认为V3不可见，在根据undolog回退到上一个版本(V2，trx_id_x2)，如果trx_id_x2小于低水位，认为数据可见。那么当前事务A在整个事务期间看到的这一行数据的版本都是V2。</p><p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p><ul><li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li><li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li></ul><p>InnoDB 正是利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</p><h3 id="1-5-不同隔离级别的应用场景"><a href="#1-5-不同隔离级别的应用场景" class="headerlink" title="1.5 不同隔离级别的应用场景"></a>1.5 不同隔离级别的应用场景</h3><h2 id="二、事务到底是隔离的还是非隔离的"><a href="#二、事务到底是隔离的还是非隔离的" class="headerlink" title="二、事务到底是隔离的还是非隔离的"></a>二、事务到底是隔离的还是非隔离的</h2><p>上面介绍的不同的隔离级别下看到的数据版本针对的是当前事务的操作是纯读的情况，如果当前事务事务中存在更新操作，那会是什么情况呢？</p><p>当然，串行化的隔离级别下，无论读写，都会加锁，并等待锁的释放，所以这种情况下和原来一样。其它三种级别下，事务执行过程中，如果出现update操作，就会应用这样一条规则：</p><p><strong>更新数据都是先读后写的，而这个读，只能读当前最新版本的值，称为当前读（current read）</strong></p><p>读未提交隔离级别下，一直都是读的最新版本值，所以这条规则实际影响的是 <strong>读提交</strong> 和 <strong>可重复读</strong>。</p><p>在可重复读的事务过程中，如果出现了update操作，会等其它事务的update完成，释放行锁，然后读取当前值，在执行update语句。在这之后的select语句的执行结果都是更新后的值，因为1.5中：</p><p><strong>此外，如果是这个事务自己更新的数据，它自己还是要认的。</strong> </p><h2 id="三、尽量避免使用长事务"><a href="#三、尽量避免使用长事务" class="headerlink" title="三、尽量避免使用长事务"></a>三、尽量避免使用长事务</h2><p>事务的隔离中用到一致性视图，而一致性视图需要用到回滚日志undolog。那回滚日志什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p><p>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 read-view 的时候。</p><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。</p><p>因此建议总是使用 set autocommit=1, 通过显式语句的方式来启动事务(<strong>这样之前挂起的事务会被隐式提交</strong>)。</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020年度规划</title>
    <link href="/2020/05/06/2020%E5%B9%B4%E5%BA%A6%E8%A7%84%E5%88%92/"/>
    <url>/2020/05/06/2020%E5%B9%B4%E5%BA%A6%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>临近春节，工作上没有那么忙了，正好把2020年的年度计划整理下，定上几个小目标。</p><p>为了提高计划的完成度，下面制定计划的时候，会尽可能的给出相应的时间节点和比较可行的操作步骤。</p><h3 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h3><p>19年在专业技能上的完成度比较差，所以这一部分先列出来，以体现其重要性。</p><p>对于目前的自己来说，有两个方向，一个是后端开发，另一个是算法（NLP方向）。从行业的发展来看，后端开发的需求量大，技术更新迭代较快，但是在企业，绝大部分的开发内容都是业务逻辑实现，可替代性较强，且工作强度较大，不利于工作和生活的平衡；算法（NLP方向）的数学基础要求较高，门槛高，可替代性较弱，但是随着各种开发工具的完善，算法模型的实现难度在迅速下降，并且NLP发展到今天，已经达到了一个瓶颈，距离真正的自然语言理解还很遥远。</p><p>考虑到自己的兴趣点，以及2-3年之后的职业规划，我在专业技能上的目标是成为一个具有较强的开发能力的自然语言处理算法工程师（算法工程师）。</p><p>以此为基准，2020年的专业技能提升计划如下：</p><ul><li>开发<ul><li>Redis深度历险：核心原理与应用实践<ul><li>目标：完成该书的重读和总结</li><li>时间：Q1季度结束之前</li><li>完成形式：至少三篇技术博客</li></ul></li><li>Go语言编程<ul><li>目标：完成该书的阅读</li><li>时间：Q2季度结束之前</li><li>完成形式：至少四篇技术博客</li></ul></li><li>mysql<ul><li>目标：完成极客时间的mysql实战</li><li>时间：Q2季度之前</li><li>完成形式：至少4篇技术博客</li></ul></li><li>其它相关知识<ul><li>目标：完成工作上一些技术设计的总结</li><li>时间：全年</li><li>完成形式：至少4篇技术博客</li></ul></li></ul></li><li>算法（NLP）<ul><li>自然语言处理入门<ul><li>目标：每月完成一章</li><li>时间：2020年</li><li>完成形式：完整的阅读完，并且能针对其中部分章节形成4-5篇技术博客</li></ul></li><li>机器学习实战<ul><li>目标：完成整本书的代码实现</li><li>时间：2020年</li><li>完成形式：每月完成一个章节算法的github提交</li></ul></li><li>数据结构、算法与应用<ul><li>目标：用Python和Go实现相应的数据结构及算法</li><li>时间：2020年</li><li>完成形式：每2周一篇技术博库</li></ul></li><li>其它<ul><li>leetcode刷题<ul><li>目标：完成200道题目，每周4道题</li><li>时间：2020年</li><li>完成形式：200道题目过关</li></ul></li></ul></li></ul></li></ul><h2 id="非核心能力"><a href="#非核心能力" class="headerlink" title="非核心能力"></a>非核心能力</h2><h3 id="投资"><a href="#投资" class="headerlink" title="投资"></a>投资</h3><h4 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h4><ul><li>逃不开的经济周期</li><li>哈利·布朗的永久投资组合</li></ul><h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><ul><li>投资实证公开</li><li>专业知识整理汇总，逐步形成自己系统的投资知识体系</li><li>开始研究量化投资，争取完成相关代码的开发</li></ul><h3 id="欧洲史"><a href="#欧洲史" class="headerlink" title="欧洲史"></a>欧洲史</h3><p>为明年去欧洲旅行提前做准备，哈哈~~</p><h4 id="阅读-1"><a href="#阅读-1" class="headerlink" title="阅读"></a>阅读</h4><ul><li>极简欧洲史</li><li>企鹅欧洲史</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>之前写2020年规划的时候，才刚过完年来北京。回过头去看，当时指定的目标绝大部分都没有按计划执行。果然自己的自制力还是比较差。今天重新回顾了了下之前的计划，并对其中的部分内容做了删减，感觉又有动力了！</p><hr><p><strong>一个月后见进展~~</strong></p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>年度规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 日志之 redolog</title>
    <link href="/2020/04/13/mysql%E4%B9%8Bredolog/"/>
    <url>/2020/04/13/mysql%E4%B9%8Bredolog/</url>
    
    <content type="html"><![CDATA[<h2 id="一、redolog-概述"><a href="#一、redolog-概述" class="headerlink" title="一、redolog 概述"></a>一、redolog 概述</h2><p><code>mysql</code> 有多种日志，每种日志都有其特定的用途。 <code>redolog</code> 是 <code>mysql</code> 存储引擎为 <code>innodb</code> 时，特有的日志。 <code>innodb</code> 是 <code>mysql</code> 最常用的存储引擎，它的事务的持久性就是通过 <code>redolog</code>保证的。</p><h2 id="二、redolog-介绍"><a href="#二、redolog-介绍" class="headerlink" title="二、redolog 介绍"></a>二、redolog 介绍</h2><p>为了更清晰的将 <code>redolog</code> 讲清楚，本文会围绕以下几个方面逐层展开。</p><ul><li><code>redolog</code> 是什么？</li><li><code>redolog</code> 存储形式</li><li><code>redolog</code> 是怎么产生的？</li><li><code>redolog</code> 的格式</li><li>为什么用 <code>redolog</code> 来保证事务的持久性？</li></ul><h3 id="2-1-redolog-是什么"><a href="#2-1-redolog-是什么" class="headerlink" title="2.1 redolog 是什么"></a>2.1 redolog 是什么</h3><p><code>redolog</code> 是存储引擎 <code>innodb</code> 特有的、在引擎层生成的（ <code>binlog</code> 是在 <code>server</code> 层产生的，不管用任何引擎都会生成），用于保证事务持久性的日志。 <code>redolog</code> 采用了 <code>WAL</code> ( <code>Write-Ahead Logging</code> ) 机制，即日志优先落盘，也就是说，一个事务发生之后， <code>innodb</code> 会先将数据页的变动写到 <code>redolog</code> 中，而不是实际的数据文件中，一旦 <code>redolog</code> 写入完成，就认为这个事务的操作记录完成了。之后mysql会有一套更新机制，定期的将 <code>redolog</code> 中的内容写入到数据文件中。</p><p>在 <code>mysql</code> 中， <code>redolog</code> 不会用来做物理上的主从复制，它主要的应用场景是 <code>crash-recovery</code> (崩溃恢复).</p><p>无论mysql有没有发生异常，重新启动的时候，mysql都会通过 <code>redolog</code> 恢复，确保数据没有问题。</p><h3 id="2-2-redolog-的存储形式"><a href="#2-2-redolog-的存储形式" class="headerlink" title="2.2 redolog 的存储形式"></a>2.2 redolog 的存储形式</h3><p>我们可以执行如下 <code>mysql</code> 命令查看 <code>redolog</code> 相关的部分信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &quot;%innodb_log%”;<br></code></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+------------------------------------+----------+<br>|<span class="hljs-string"> Variable_name                      </span>|<span class="hljs-string"> Value    </span>|<br>+------------------------------------+----------+<br>|<span class="hljs-string"> innodb_log_buffer_size             </span>|<span class="hljs-string"> 16777216 </span>|<br>|<span class="hljs-string"> innodb_log_checksums               </span>|<span class="hljs-string"> ON       </span>|<br>|<span class="hljs-string"> innodb_log_compressed_pages        </span>|<span class="hljs-string"> ON       </span>|<br>|<span class="hljs-string"> innodb_log_file_size               </span>|<span class="hljs-string"> 50331648 </span>|<br>|<span class="hljs-string"> innodb_log_files_in_group          </span>|<span class="hljs-string"> 2        </span>|<br>|<span class="hljs-string"> innodb_log_group_home_dir          </span>|<span class="hljs-string"> ./       </span>|<br>|<span class="hljs-string"> innodb_log_spin_cpu_abs_lwm        </span>|<span class="hljs-string"> 80       </span>|<br>|<span class="hljs-string"> innodb_log_spin_cpu_pct_hwm        </span>|<span class="hljs-string"> 50       </span>|<br>|<span class="hljs-string"> innodb_log_wait_for_flush_spin_hwm </span>|<span class="hljs-string"> 400      </span>|<br>|<span class="hljs-string"> innodb_log_write_ahead_size        </span>|<span class="hljs-string"> 8192     </span>|<br>+------------------------------------+----------+<br></code></pre></td></tr></table></figure><p>一些参数的解释：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">innodb_log_buffer_size:</span> redolog缓存区的大小，即<span class="hljs-number">16</span>m<br><span class="hljs-symbol">innodb_log_file_size:</span> redolog文件的大小，即<span class="hljs-number">48</span>m<br><span class="hljs-symbol">innodb_log_files_in_group:</span> 日志文件组中文件数量<br><span class="hljs-symbol">innodb_log_group_home_dir:</span> 日志文件组路径即 mysql/data<br></code></pre></td></tr></table></figure></p><p>如果 <code>mysql</code> 的安装路径是默认路径，那么：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/mysql<br>ls data<br></code></pre></td></tr></table></figure></p><p>形如 <code>ib_logfile0</code>、 <code>ib_logfile1</code> 之类的文件就是 <code>redolog file</code>。为什么这里会出现两个 <code>ib_logfile</code> ？这是因为 <code>redolog file</code> 其实指的是一个文件组，由多个 <code>ib_logfile</code> 合并起来共同表示。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/redolog_checkpoint.png" alt="redolog checkpoint"></p><p><code>redolog</code> 的大小是在配置中设置好的，不能无限制写入。 <code>innodb</code> 采用了循环写入的方式，图中 <code>checkpoint</code> 和 <code>writepos</code> 就是用来区分哪些数据已经从日志文件中刷新到数据文件中。<code>writepos</code> -&gt; <code>checkpoint</code> 之间的数据是已经写入到数据文件中的，是可以删除的，<code>checkpoint</code> -&gt; <code>writepos</code> 之间的数据是已经写入到日志文件中，但是还没有写入到数据文件中，是不可以擦除的。</p><p>如果有新的数据写入到日志文件上，<code>writepos</code> 的位置就会顺时钟挪动，如果发现超过了 <code>checkpoint</code> 的位置，就会强制将一部分 <code>checkpoint</code> 右边的数据刷如磁盘中的数据文件上，然后将 <code>checkpoint</code> 顺时针移动一定的位置。</p><h3 id="2-3-redolog-是怎么产生的"><a href="#2-3-redolog-是怎么产生的" class="headerlink" title="2.3 redolog 是怎么产生的"></a>2.3 redolog 是怎么产生的</h3><h4 id="2-3-1-事务的执行引起-redolog-的更新"><a href="#2-3-1-事务的执行引起-redolog-的更新" class="headerlink" title="2.3.1 事务的执行引起 redolog 的更新"></a>2.3.1 事务的执行引起 redolog 的更新</h4><p><code>redolog</code> 更新的依据是事务的执行。每一次事务执行完毕之后，所引起的数据页的变化都会先写到 <code>redolog</code> 中（当然，如果事务中是先 <code>insert</code> 再 <code>delete</code>，实际不对数据页做出改变的话， <code>redolog</code> 是不会更新的）。</p><p><em>注：<code>innodb</code> 中 <code>insert</code> 或者 <code>update</code> 语句默认都是事务。</em></p><h4 id="2-3-2-redolog-的写入流程"><a href="#2-3-2-redolog-的写入流程" class="headerlink" title="2.3.2 redolog 的写入流程"></a>2.3.2 redolog 的写入流程</h4><p>并不是事务一执行，数据页就被写入到 <code>redolog</code> 中。 <code>redolog</code> 本身是文件，频繁的写文件，会导致性能的降低，所以 <code>redolog</code> 的写入流程如下，以一个 update 操作为例：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/redolog_wiriting_process.png" alt="redolog 刷新流程"></p><p>在最后一步，将数据从缓存刷入文件的时候，其实中间还有一步，缓存中的数据会先刷到 <code>linux</code> 的文件缓存中，然后才会再被刷入到日志文件中。如果 <code>Linux</code> 机器忽然重启，就有可能丢失这部分数据， <code>redolog file</code> 就会更新失败。</p><p><code>redolog buffer</code> 何时刷入日志文件，是否需要强制刷新 <code>Linux</code> 文件缓存？ <code>innodb</code> 主要通过下面这两个参数控制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">+--------------------------------+-------+<br>| Variable_name                  | Value |<br>+--------------------------------+-------+<br>| innodb_flush_log_at_timeout    | 1     |<br>| innodb_flush_log_at_trx_commit | 1     |<br>+--------------------------------+-------+<br></code></pre></td></tr></table></figure><p><code>innodb_flush_log_at_trx_commit</code> 配置的详细说明如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Controls <span class="hljs-keyword">the</span> balance between strict ACID compliance <span class="hljs-keyword">for</span> commit operations <span class="hljs-keyword">and</span> higher performance that is possible when commit-related I/O operations are rearranged <span class="hljs-keyword">and</span> done <span class="hljs-keyword">in</span> batches. You can achieve better performance <span class="hljs-keyword">by</span> changing <span class="hljs-keyword">the</span> default <span class="hljs-built_in">value</span> but <span class="hljs-keyword">then</span> you can lose transactions <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span> crash.<br>* The default setting <span class="hljs-keyword">of</span> <span class="hljs-number">1</span> is required <span class="hljs-keyword">for</span> full ACID compliance. Logs are written <span class="hljs-keyword">and</span> flushed <span class="hljs-built_in">to</span> disk <span class="hljs-keyword">at</span> <span class="hljs-keyword">each</span> transaction commit.<br>* With <span class="hljs-keyword">a</span> setting <span class="hljs-keyword">of</span> <span class="hljs-number">0</span>, logs are written <span class="hljs-keyword">and</span> flushed <span class="hljs-built_in">to</span> disk once per <span class="hljs-keyword">second</span>. Transactions <span class="hljs-keyword">for</span> which logs have <span class="hljs-keyword">not</span> been flushed can be lost <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span> crash.<br>* With <span class="hljs-keyword">a</span> setting <span class="hljs-keyword">of</span> <span class="hljs-number">2</span>, logs are written <span class="hljs-keyword">after</span> <span class="hljs-keyword">each</span> transaction commit <span class="hljs-keyword">and</span> flushed <span class="hljs-built_in">to</span> disk once per <span class="hljs-keyword">second</span>. Transactions <span class="hljs-keyword">for</span> which logs have <span class="hljs-keyword">not</span> been flushed can be lost <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span> crash.<br>* For settings <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">2</span>, once-per-<span class="hljs-keyword">second</span> flushing is <span class="hljs-keyword">not</span> <span class="hljs-number">100</span>% guaranteed. Flushing may occur more frequently due <span class="hljs-built_in">to</span> DDL changes <span class="hljs-keyword">and</span> other internal InnoDB activities that cause logs <span class="hljs-built_in">to</span> be flushed independently <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> innodb_flush_log_at_trx_commit setting, <span class="hljs-keyword">and</span> sometimes less frequently due <span class="hljs-built_in">to</span> scheduling issues. If logs are flushed once per <span class="hljs-keyword">second</span>, up <span class="hljs-built_in">to</span> <span class="hljs-literal">one</span> <span class="hljs-keyword">second</span> <span class="hljs-keyword">of</span> transactions can be lost <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span> crash. If logs are flushed more <span class="hljs-keyword">or</span> less frequently than once per <span class="hljs-keyword">second</span>, <span class="hljs-keyword">the</span> amount <span class="hljs-keyword">of</span> transactions that can be lost varies accordingly.<br>* Log flushing frequency is controlled <span class="hljs-keyword">by</span> innodb_flush_log_at_timeout, which allows you <span class="hljs-built_in">to</span> <span class="hljs-built_in">set</span> <span class="hljs-built_in">log</span> flushing frequency <span class="hljs-built_in">to</span> N <span class="hljs-built_in">seconds</span> (where N is <span class="hljs-number">1</span> ... <span class="hljs-number">2700</span>, <span class="hljs-keyword">with</span> <span class="hljs-keyword">a</span> default <span class="hljs-built_in">value</span> <span class="hljs-keyword">of</span> <span class="hljs-number">1</span>). However, <span class="hljs-keyword">any</span> mysqld <span class="hljs-built_in">process</span> crash can erase up <span class="hljs-built_in">to</span> N <span class="hljs-built_in">seconds</span> <span class="hljs-keyword">of</span> transactions.<br>* DDL changes <span class="hljs-keyword">and</span> other internal InnoDB activities flush <span class="hljs-keyword">the</span> <span class="hljs-built_in">log</span> independently <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> innodb_flush_log_at_trx_commit setting.<br>* InnoDB crash recovery works regardless <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> innodb_flush_log_at_trx_commit setting. Transactions are either applied entirely <span class="hljs-keyword">or</span> erased entirely.<br></code></pre></td></tr></table></figure><p>根据上面的解释，<code>innodb_flush_log_at_trx_commit = 1</code> 时， <code>logbuffer</code> 实时刷入，且系统缓存也会实时刷入文件，此时数据库的四大特性：ACID 能够严格保证。 <code>innodb_flush_log_at_trx_commit</code> 等于其它值的时候，可以通过 <code>innodb_flush_log_at_timeout</code> 来控制缓存刷新的频率。</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_flush_log_at_timeout">相关配置的详细解释</a></p><h3 id="2-4-redolog-文件格式"><a href="#2-4-redolog-文件格式" class="headerlink" title="2.4 redolog 文件格式"></a>2.4 redolog 文件格式</h3><h4 id="2-4-1-redolog-文件存储地址"><a href="#2-4-1-redolog-文件存储地址" class="headerlink" title="2.4.1 redolog 文件存储地址"></a>2.4.1 redolog 文件存储地址</h4><p>根据上文中 <code>innodb_log</code> 的配置 <code>innodb_log_group_home_dir = ./</code> (这里的当前目录即mysql的数据文件目录，如果你是安装在默认路径，一般数据文件目录为 <code>/usr/local/mysql/data</code> )，文件目录如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Shell">drwxr-x---   12 _mysql  _mysql       384 Mar 13 00:31 #innodb_temp<br>drwxr-x---    3 _mysql  _mysql        96 Apr  4 22:10 appengine_common<br>-rw-r-----    1 _mysql  _mysql        56 Aug 28  2019 auto.cnf<br>-rw-r-----    1 _mysql  _mysql      7062 Mar  6 20:58 binlog.000014<br>-rw-r-----    1 _mysql  _mysql       178 Mar  7 01:47 binlog.000015<br>-rw-r-----    1 _mysql  _mysql       178 Mar  7 02:10 binlog.000016<br>-rw-r-----    1 _mysql  _mysql       178 Mar  7 02:34 binlog.000017<br>-rw-r-----    1 _mysql  _mysql       178 Mar 12 11:24 binlog.000018<br>-rw-r-----    1 _mysql  _mysql       178 Mar 12 12:25 binlog.000019<br>-rw-r-----    1 _mysql  _mysql       178 Mar 13 00:31 binlog.000020<br>-rw-r-----    1 _mysql  _mysql  51286298 Apr  4 22:26 binlog.000021<br>-rw-r-----    1 _mysql  _mysql       128 Mar 13 00:31 binlog.index<br>-rw-------    1 _mysql  _mysql      1680 Aug 28  2019 ca-key.pem<br>-rw-r--r--    1 _mysql  _mysql      1112 Aug 28  2019 ca.pem<br>-rw-r--r--    1 _mysql  _mysql      1112 Aug 28  2019 client-cert.pem<br>-rw-------    1 _mysql  _mysql      1680 Aug 28  2019 client-key.pem<br>-rw-r-----    1 _mysql  _mysql      4110 Mar 13 00:31 ib_buffer_pool<br>-rw-r-----    1 _mysql  _mysql  50331648 Apr  4 22:26 ib_logfile0<br>-rw-r-----    1 _mysql  _mysql  50331648 Apr  4 22:26 ib_logfile1<br>-rw-r-----    1 _mysql  _mysql  12582912 Apr  4 22:26 ibdata1<br>-rw-r-----    1 _mysql  _mysql  12582912 Mar 13 00:31 ibtmp1<br>drwxr-x---    8 _mysql  _mysql       256 Nov  8 23:52 mysql<br>-rw-r-----    1 _mysql  _mysql  24117248 Apr  4 22:26 mysql.ibd<br>-rw-r-----    1 _mysql  _mysql     19195 Mar 13 00:31 mysqld.local.err<br>-rw-r-----    1 _mysql  _mysql         4 Mar 13 00:31 mysqld.local.pid<br>drwxr-x---  105 _mysql  _mysql      3360 Nov  8 23:52 performance_schema<br>-rw-------    1 _mysql  _mysql      1680 Aug 28  2019 private_key.pem<br>-rw-r--r--    1 _mysql  _mysql       452 Aug 28  2019 public_key.pem<br>-rw-r--r--    1 _mysql  _mysql      1112 Aug 28  2019 server-cert.pem<br>-rw-------    1 _mysql  _mysql      1676 Aug 28  2019 server-key.pem<br>drwxr-x---    3 _mysql  _mysql        96 Nov  8 23:52 sys<br>drwxr-x---    3 _mysql  _mysql        96 Mar 30 23:15 test<br>-rw-r-----    1 _mysql  _mysql  12582912 Apr  4 22:26 undo_001<br>-rw-r-----    1 _mysql  _mysql  12582912 Apr  4 22:26 undo_002<br></code></pre></td></tr></table></figure><p>其中前缀是 <code>ib_logfile</code> 的文件就是。</p><p>如果你想看一下文件中的具体内容，可以通过命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">strings ib_logfile0<br></code></pre></td></tr></table></figure><p>大概感知一下。在文件中，我们能搜到诸如 <code>thread_id</code>，<code>space_id</code> 之类的字段。</p><h4 id="2-4-2-redolog-格式简介"><a href="#2-4-2-redolog-格式简介" class="headerlink" title="2.4.2 redolog 格式简介"></a>2.4.2 redolog 格式简介</h4><p>尽管一个 <code>redolog</code> 有多个文件，但是每个文件的格式是一致的，只是有一些数据只会存在第一个文件中。</p><p>第一个文件 <code>ib_logfile0</code> 的格式如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/indb_file0_overview.png" alt="ib_logfile0"></p><p>从图中可以看到，日志文件中包含了文件头信息和具体的日志信息，这些日志信息分别写在每一个日志块中。</p><p>其它文件 <code>ib_logfile*</code> 的格式如下：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/indb_file1_overview.png" alt="ib_logfile*"></p><p>其它的日志文件内容格式基本一样，主要区别在 <code>checkpoint</code> 信息（ <code>checkpoint</code> 记录的是已经更新到数据文件中的 LSN）。</p><p>在深刻理解 <code>checkpoint</code> 的含义前，首先需要理解 <code>LSN</code>（ <code>og sequence number</code> ）的概念。</p><p><strong>什么是LSN？</strong></p><p><code>LSN</code> 表示日志记录创建开始到特定的日志记录已经写入的字节数。 <code>mysql</code> 通过 <code>LSN</code> 来判断是否需要刷新 <code>buffer</code> 到 <code>redolog</code> 上以及是否需要将 <code>redolog</code> 写到磁盘上。<code>LSN</code> 是单调递增的。</p><p>以我本地的数据库为例。</p><p>第一步，查看 <code>innodb</code> 的状态：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show engine innodb status\G;<br></code></pre></td></tr></table></figure><br>部分结果如下(后面的数据就是 <code>LSN</code> )：<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">---</span><br><span class="hljs-keyword">LOG</span><br><span class="hljs-comment">---</span><br><span class="hljs-keyword">Log</span> <span class="hljs-keyword">sequence</span> number          <span class="hljs-number">85755920</span><br><span class="hljs-keyword">Log</span> buffer assigned up <span class="hljs-keyword">to</span>    <span class="hljs-number">85755920</span><br><span class="hljs-keyword">Log</span> buffer completed up <span class="hljs-keyword">to</span>   <span class="hljs-number">85755920</span><br><span class="hljs-keyword">Log</span> written up <span class="hljs-keyword">to</span>            <span class="hljs-number">85755920</span><br><span class="hljs-keyword">Log</span> flushed up <span class="hljs-keyword">to</span>            <span class="hljs-number">85755920</span><br>Added dirty pages up <span class="hljs-keyword">to</span>      <span class="hljs-number">85755920</span><br>Pages flushed up <span class="hljs-keyword">to</span>          <span class="hljs-number">85755920</span><br>Last <span class="hljs-keyword">checkpoint</span> at           <span class="hljs-number">85755920</span><br></code></pre></td></tr></table></figure></p><p>然后我删除了 <code>MySQL</code> 中的一个数据库，再次查看 innodb 的状态，如下：<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">---</span><br><span class="hljs-keyword">LOG</span><br><span class="hljs-comment">---</span><br><span class="hljs-keyword">Log</span> <span class="hljs-keyword">sequence</span> number          <span class="hljs-number">85755974</span><br><span class="hljs-keyword">Log</span> buffer assigned up <span class="hljs-keyword">to</span>    <span class="hljs-number">85755974</span><br><span class="hljs-keyword">Log</span> buffer completed up <span class="hljs-keyword">to</span>   <span class="hljs-number">85755974</span><br><span class="hljs-keyword">Log</span> written up <span class="hljs-keyword">to</span>            <span class="hljs-number">85755974</span><br><span class="hljs-keyword">Log</span> flushed up <span class="hljs-keyword">to</span>            <span class="hljs-number">85755974</span><br>Added dirty pages up <span class="hljs-keyword">to</span>      <span class="hljs-number">85755974</span><br>Pages flushed up <span class="hljs-keyword">to</span>          <span class="hljs-number">85755920</span><br>Last <span class="hljs-keyword">checkpoint</span> at           <span class="hljs-number">85755920</span><br></code></pre></td></tr></table></figure><br>可以看到， <code>buffer</code> 中的 <code>LSN</code> 已经更新了，<code>redolog</code> 中日志记录的 <code>LSN</code> 也已经更新到最新，但是 <code>checkpoint</code> 还是之前的记录，因为 <code>checkpoint</code> 小于 <code>redolog</code> 最新的 <code>LSN</code> ，所以 <code>mysql</code> 认为需要将 <code>checkpoint</code> 之后的数据继续更新到数据文件中。</p><p>继续查看 <code>innodb</code> 的状态，如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">LOG</span><br><span class="hljs-comment">---</span><br><span class="hljs-keyword">Log</span> <span class="hljs-keyword">sequence</span> number          <span class="hljs-number">85755974</span><br><span class="hljs-keyword">Log</span> buffer assigned up <span class="hljs-keyword">to</span>    <span class="hljs-number">85755974</span><br><span class="hljs-keyword">Log</span> buffer completed up <span class="hljs-keyword">to</span>   <span class="hljs-number">85755974</span><br><span class="hljs-keyword">Log</span> written up <span class="hljs-keyword">to</span>            <span class="hljs-number">85755974</span><br><span class="hljs-keyword">Log</span> flushed up <span class="hljs-keyword">to</span>            <span class="hljs-number">85755974</span><br>Added dirty pages up <span class="hljs-keyword">to</span>      <span class="hljs-number">85755974</span><br>Pages flushed up <span class="hljs-keyword">to</span>          <span class="hljs-number">85755974</span><br>Last <span class="hljs-keyword">checkpoint</span> at           <span class="hljs-number">85755974</span><br></code></pre></td></tr></table></figure><p>这次可以看到，<code>checkpoin</code>t 已经更新成最新的 <code>LSN</code> 了，这表明之前没来的及更新到数据文件中 <code>redolog</code> 也已经更新进去了。所以最终全部的 <code>LSN</code> 是保持一致的。</p><p>再细的日志格式就不在这里展开了，我看的也不深，如果你想更深入的了解，一是可以去参考 <code>mysql</code> 的源码，或者参考下面的这两篇文章。</p><p><strong>注</strong>：这一节内容主要参考了文章 <a href="https://blog.51cto.com/wangwei007/2287431">MySQL InnoDB redo Log 浅析</a> 和 <a href="http://mysql.taobao.org/monthly/2017/09/07/">MySQL · 源码分析 · Innodb 引擎Redo日志存储格式简介</a>。</p><h3 id="2-5-为什么用-redolog-来保证事务的持久性？"><a href="#2-5-为什么用-redolog-来保证事务的持久性？" class="headerlink" title="2.5 为什么用 redolog 来保证事务的持久性？"></a>2.5 为什么用 redolog 来保证事务的持久性？</h3><blockquote><p>事务的持久性是指事务一旦提交就会永久生效</p></blockquote><p><code>redolog</code> 采用的机制是 <code>WAL</code> (Write-Ahead Logging) 机制，因此事务的持久性是通过日志的持久性实现的，即每次事务提交，在持久化一个数据页的时候，首先将数据页内容持久化到日志中。</p><p>为什么要采用 <code>WAL</code> 机制？因为将数据页写到日志中的时间要远远快于写到数据存储文件中。我们知道，<code>innodb</code> 底层的存储实现是 <code>B+Tree</code>，对数据页的寻址是通过指针决定的。如果执行多条 <code>update</code> 语句，影响的数据页在不同的磁盘块上，那么对计算机来说磁盘块的寻址会消耗很多时间；而如果是将这些数据页的变动直接写到日志文件中，因为是顺序写入，消耗的时间远远小于前者。</p><p>从 IO 次数来说，<code>WAL</code> 刷新是少量 IO，DaTa 刷新是大量 IO， <code>WAL</code> 刷新次数少得多；<br>从 IO 花销来说， <code>WAL</code> 刷新是连续IO，Data 刷新是随机IO， <code>WAL</code> 刷新花销小得多.</p><p>因此WAL机制在保证事务持久性和数据完整性的同时，成功地提升了系统性能。</p><p><strong>Tips</strong></p><p>redolog 除了用来保证事务的持久性，它所采用的 <strong>两阶段提交</strong> 机制也保证了事务的一致性。<strong>两阶段提交</strong> 涉及到 <code>binlog</code>，后续讲 <code>binlog</code> 的时候，会重点讲解下。</p><p>参考课程：<a href="https://time.geekbang.org/column/intro/100020801?code=rNEW29DDq73FD01HP-2AEicuNieaJ24KUQ9tYhCk1Ow%3D">https://time.geekbang.org/column/intro/100020801?code=rNEW29DDq73FD01HP-2AEicuNieaJ24KUQ9tYhCk1Ow%3D</a></p><h2 id="三、结语"><a href="#三、结语" class="headerlink" title="三、结语"></a>三、结语</h2><p>相信经过上面的讲解，你应该对 <code>redolog</code> 的概念、用处有了一个清晰的认识，并且能根据不同的生产环境对相关的配置做出合适的调整。如果你希望对 <code>redolog</code> 的具体格式以及实现有更深入的理解，可以结合上文提到文章和源码继续深入了解。</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openssl升级教程</title>
    <link href="/2020/01/09/openssl%E5%8D%87%E7%BA%A7%E6%95%99%E7%A8%8B/"/>
    <url>/2020/01/09/openssl%E5%8D%87%E7%BA%A7%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>openssl版本号的含义</strong></p><blockquote><p>OpenSSL version numbers are formatted as n1.n2.n3x, where n1-3 are numbers and x, if present, is one or more letters. These can change depending on the release type:</p><p>Major releases that change one/both of the first two digits, which can break compatibility with previous versions</p><p>Minor releases that change the last digit, e.g. 1.1.0 vs. 1.1.1, can and are likely to contain new features, but in a way that does not break binary compatibility. This means that an application compiled and dynamically linked with 1.1.0 does not need to be recompiled when the shared library is updated to 1.1.1. It should be noted that some features are transparent to the application such as the maximum negotiated TLS version and cipher suites, performance improvements and so on. There is no need to recompile applications to benefit from these features.</p><p>Letter releases, such as 1.0.2a, exclusively contain bug and security fixes and no new features.</p></blockquote><p>后面的字母表示bug的修复记录，那显然选字母越靠后，版本越稳定。</p><h2 id="openssl升级步骤"><a href="#openssl升级步骤" class="headerlink" title="openssl升级步骤"></a>openssl升级步骤</h2><h4 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h4><p><a href="https://www.openssl.org/source/">下载地址</a></p><h4 id="解压编译"><a href="#解压编译" class="headerlink" title="解压编译"></a>解压编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xzf openssl-1.1.1d.tar.gz<br><span class="hljs-built_in">cd</span> openssl-1.1.1d<br><span class="hljs-comment"># --prefix是安装路径，--openssl是配置文件路径</span><br>./config shared --prefix=/opt/openssl --openssldir=/usr/<span class="hljs-built_in">local</span>/ssl -D_GNU_SOURCE<br>make clean<br>make<br>make install<br></code></pre></td></tr></table></figure><p><code>-D_GNU_SOURCE</code>并不是必须的，只有当出现错误提示 <code>&#39;pthread_mutex_recursive&#39; undeclared (first use in this function)</code> 才需要带上，这个一般是因为系统太老。(<a href="https://github.com/openssl/openssl/issues/2261">相关问题链接</a>)</p><h4 id="检查动态链接"><a href="#检查动态链接" class="headerlink" title="检查动态链接"></a>检查动态链接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ldd /opt/openssl/bin/openssl<br></code></pre></td></tr></table></figure><p><strong>如果提示</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">libssl.so.1.1 =&gt; not found<br>libcrypto.so.1.1 =&gt; not found<br>libdl.so.2 =&gt; /lib64/libdl.so.2 (0x0000003f0b300000)<br>libpthread.so.0 =&gt; /lib64/tls/libpthread.so.0 (0x0000003f0b900000)<br>libc.so.6 =&gt; /lib64/tls/libc.so.6 (0x0000003f0b000000)<br>/lib64/ld-linux-x86-64.so.2 (0x0000003f0ae00000)<br></code></pre></td></tr></table></figure><br>说明 <code>libssl.so.1.1</code> 等没有链接上，执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ln -s /opt/openssl/lib/libssl.so.1.1 /usr/lib64/libssl.so.1.1<br>sudo ln -s /opt/openssl/lib/libcrypto.so.1.1 /opt/openssl/lib/libcrypto.so.1.1<br></code></pre></td></tr></table></figure></p><h4 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h4><p>执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/opt/openssl/bin/openssl version<br></code></pre></td></tr></table></figure><br>显示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">OpenSSL 1.1.1d  10 Sep 2019<br></code></pre></td></tr></table></figure></p><h2 id="PHP下升级openssl"><a href="#PHP下升级openssl" class="headerlink" title="PHP下升级openssl"></a>PHP下升级openssl</h2><p><strong>php下添加openss扩展有两种方式</strong></p><ol><li>PHP源码编译安装的时候，带上 <code>--with-openssl[=DIR]</code> ,</li><li>如果php已经安装完成了，不支持openssl，但是又不想重新编译，可以下载对应版本的php源码，解压进入到php/ext/openssl目录，执行 php/bin/phpize，生成configure文件，然后指定编译配置 <code>./configure --with-openssl[=DIR] --with-php-config=/php/bin/php-config</code>，<code>make</code>编译，生成 openssl.so，再在php.ini中开启即可。</li></ol><h2 id="PHP如何实现SM3签名算法？"><a href="#PHP如何实现SM3签名算法？" class="headerlink" title="PHP如何实现SM3签名算法？"></a>PHP如何实现SM3签名算法？</h2><blockquote><p>SM2、SMS3等加密签名算法是国密算法，openssl从1.1.1版本开始支持</p></blockquote><p>由于希望能在PHP中实现<code>SM3</code>算法，想着能否通过升级openssl的方式实现，调研了一天发现，仅通过<code>openssl</code>的升级，无法快速实现。</p><p><strong>原因如下</strong></p><blockquote><p>openssl1.1.1d的安装只是说在系统层面增加了openssl这个工具，安转完之后即可通过命令行的方式实现各种加密算法</p><p>php实现openssl扩展，其原理是通过php/ext/openssl下面的源码，编译实现从openssl工具到php中使用的加密函数的一个映射，检查php/ext/openssl下面的openssl.c文件发现，并没有包含openssl源码中实现SMS3等算法的头文件，所以不管怎么编译，生成的php下的openssl扩展都没有SM3函数</p></blockquote><p><strong>那如何实现在PHP中使用SMS3算法？</strong></p><ol><li>修改php/ext/openssl下面的代码，增加SM3等算法的映射，重新编译生成openssl.so （工程量较大，需要熟悉源码）</li><li>使用openssl的一个分支版本Gmssl。Gmssl在openssl的基础上实现了对一般国密算法的支持，同时提供了用于编译openssl.so的php/ext/openssl源码，编译生成openssl.so即可 (<strong>该方法尚未验证成，怀疑和PHP版本有关</strong>)</li><li>安装完openssl工具后，在PHP代码中直接执行linux命令：<code>echo -n &quot;abc&quot; | /opt/openssl/bin/openssl dgst -SM3</code> </li></ol><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>openssl</tag>
      
      <tag>sm3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>价值投资的关键</title>
    <link href="/2020/01/06/%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9A%84%E5%85%B3%E9%94%AE/"/>
    <url>/2020/01/06/%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9A%84%E5%85%B3%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="投资中最重要的事"><a href="#投资中最重要的事" class="headerlink" title="投资中最重要的事"></a>投资中最重要的事</h2><p><strong>认知和格局</strong></p><p>你能看到多么大的趋势，就能看到多少机会。你接触的人和信息，决定你有着怎样的视野，以及你看到的是怎样的一个世界。</p><p><strong>逻辑驱动买入，逻辑驱动卖出</strong></p><p>不要有偏见，一切以数据、和数据推演出的逻辑为准。以前涨不涨和以后涨不涨没关系，关注涨跌背后的逻辑，不要被个股波动的表象所影响。</p><h2 id="能力圈原则"><a href="#能力圈原则" class="headerlink" title="能力圈原则"></a>能力圈原则</h2><p><strong>清楚自己的能力圈</strong></p><p>围绕真正了解的企业画一个圈，排除不合格的企业。</p><p><strong>能力圈在精不在多</strong></p><p>对自己的能力圈拉爱说，最重要的不是能力圈的范围大小，而是你如何能够确定能力圈的便捷所在。</p><p><strong>坚守能力圈</strong></p><p>明白自己到底不知道什么，固收于自己相信和了解的公司。</p><p><strong>如何践行能力圈原则</strong></p><ol><li>清楚自己的状态</li><li>把自己变成行业专家</li><li>识别哪些是自己看得懂的机会（时长有时候是疯狂的，但不代表我们看不懂的东西都是疯狂的）</li></ol><p>具体而言，即：</p><ol><li>清楚自己能圈而行业知识和周期（均值回归，在股票市场上的应用，就是股价长期围绕价值中暑波动，涨多了跌，跌多了涨）</li><li>坚持一种风格</li><li>左做减法（三五个行业，十几家公司）</li><li>坚持自己的交易准则</li></ol><h2 id="完美的投资体系"><a href="#完美的投资体系" class="headerlink" title="完美的投资体系"></a>完美的投资体系</h2><ol><li>正确的方向和理念</li><li>寻找和听取能力圈公司的各种负面问题（好的公司、以及诚实的管理层非常稀缺，对于重仓持有的公司，我们尤其要挺别人的犀利观点，尤其是那些不看好的、负面的）</li></ol><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>价值投资训练营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>two sum问题(-)</title>
    <link href="/2020/01/05/two-sum(%E4%B8%80)/"/>
    <url>/2020/01/05/two-sum(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>两数之和问题，简而言之就是从数组中找到两个数的和等于某个特定的值，考察的主要思想是空间换时间。同时它还有许多变种，如三数之和、四数之和问题。</p></blockquote><h2 id="题目集合"><a href="#题目集合" class="headerlink" title="题目集合"></a>题目集合</h2><p><strong>two sum及其变种如下</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:center">题目</th><th style="text-align:center">难度等级</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://leetcode.com/problems/two-sum/">two sum</a></td><td style="text-align:center">easy</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">Two Sum II - Input array is sorted</a></td><td style="text-align:center">easy</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><a href="https://leetcode.com/problems/two-sum-iii-data-structure-design/">Two Sum III - Data structure design</a></td><td style="text-align:center">easy</td><td style="text-align:center">要订阅，暂时放弃。。。</td></tr><tr><td style="text-align:center"><a href="https://leetcode.com/problems/subarray-sum-equals-k/">Subarray Sum Equals K</a></td><td style="text-align:center">medium</td></tr><tr><td style="text-align:center"><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/">Two Sum IV - Input is a BST</a></td><td style="text-align:center">easy</td></tr><tr><td style="text-align:center"><a href="https://leetcode.com/problems/two-sum-less-than-k/">Two Sum Less Than K</a></td><td style="text-align:center">easy</td></tr></tbody></table></div><h3 id="1、经典原题-two-sum"><a href="#1、经典原题-two-sum" class="headerlink" title="1、经典原题: two sum"></a>1、经典原题: two sum</h3><blockquote><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p></blockquote><p><strong>Example</strong></p><blockquote><p>Given nums = [2, 7, 11, 15], target = 9,</p><p>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p></blockquote><h4 id="解法一：暴力破解"><a href="#解法一：暴力破解" class="headerlink" title="解法一：暴力破解"></a>解法一：暴力破解</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(nums); j++ &#123;<br>            <span class="hljs-keyword">if</span> nums[i]+nums[j] == target &#123;<br>                <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;i, j&#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>runtime distribution</strong></p><blockquote><p>Runtime: 36 ms, faster than <strong>31.90%</strong> of Go online submissions for Two Sum.</p></blockquote><p><strong>memory distribution</strong></p><blockquote><p>Memory Usage: 3 MB, less than <strong>100.00%</strong> of Go online submissions for Two Sum.</p></blockquote><p><strong>思考</strong></p><blockquote><p>暴力破解是最容易想到的方法，它的时间复杂度是O(n^2)。虽然很多时候我们都对暴力解法嗤之以鼻，但是从上面的时间分布和内存分布看，优点还是很明显的，即内存消耗很小。</p><p>在计算机里面，增加内存的成本远远小于提高计算能力的成本，所以我们需要考虑如何通过空间来换时间。</p></blockquote><h4 id="解法二：哈希表法"><a href="#解法二：哈希表法" class="headerlink" title="解法二：哈希表法"></a>解法二：哈希表法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">var</span> numsMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        numsMap[nums[i]] = i<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        j, ok := numsMap[target - nums[i]]<br>        <span class="hljs-keyword">if</span> ok &amp;&amp; j != i &#123;<br>            <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;i, j&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>runtime distribution</strong></p><blockquote><p>Runtime: 4 ms, faster than <strong>95.00%</strong> of Go online submissions for Two Sum.</p></blockquote><p><strong>memory distribution</strong></p><blockquote><p>Memory Usage: 3.8 MB, less than <strong>11.54%</strong> of Go online submissions for Two Sum.</p></blockquote><p>如果把代码中numsMap的定义改成：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> numsMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(nums))<br></code></pre></td></tr></table></figure><p><strong>memory distribution</strong></p><blockquote><p>Memory Usage: 3.4 MB, less than <strong>42.31%</strong> of Go online submissions for Two Sum.</p></blockquote><p><strong>思考</strong></p><blockquote><p>暴力解法中，比较耗时的操作是第二个for循环，第二个for循环的作用是判断第二个数加第一个数是不是等于目标值，这是一个凑数的过程。如果我们反过来想，在已知第一个数的情况下，判断我们需要找的数是不是在剩下的数的集合里面，时间复杂度就变成了O(1)。</p><p>从时间分布看，超过了95%的人(说明还能继续优化)；从内存分布看，只超过了11.54%的人。但是如果在初始化numsMap的时候指定了长度，消耗的内存就会少0.4M，由此可见，Go中map类型数据指定长度初始化是有必要的。</p><p>这里面需要注意的是，如果数组中有两个元素一致，那哈西表中存的索引就是第二个元素的索引值。但是因为我们是从前往后遍历的，所以结果不影响。至于有三个及以上的元素相同的情况是不用考虑的，因为题目说只有唯一解。</p></blockquote><h4 id="解法三：哈希表法升级版"><a href="#解法三：哈希表法升级版" class="headerlink" title="解法三：哈希表法升级版"></a>解法三：哈希表法升级版</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    numsMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(nums))<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> pre, ok := numsMap[target - v]; ok &#123;<br>            <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;pre, i&#125;<br>        &#125;<br>        numsMap[v] = i<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>runtime distribution</strong></p><blockquote><p>Runtime: 4 ms, faster than <strong>95.00%</strong> of Go online submissions for Two Sum.</p></blockquote><p><strong>memory distribution</strong></p><blockquote><p>Memory Usage: 3.4 MB, less than <strong>48.08%</strong> of Go online submissions for Two Sum.</p></blockquote><p><strong>思考</strong></p><blockquote><p>解法二中，出现了两个遍历，一次是numsMap赋值的时候，一次是查找的时候。但实际上这两次是可以合并的，即一边赋值，一边查找。</p><p>至于为什么runtime排名还是小于<strong>95%</strong>，应该是网站的bug，时间最少的那个人的耗时是0ms，显然不可能。测试发现，如果重复提交多次，有可能出现这种情况。</p></blockquote><h3 id="2、变种一：Two-Sum-II-Input-array-is-sorted"><a href="#2、变种一：Two-Sum-II-Input-array-is-sorted" class="headerlink" title="2、变种一：Two Sum II - Input array is sorted"></a>2、变种一：Two Sum II - Input array is sorted</h3><blockquote><p>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.</p><p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</p></blockquote><p><strong>Note:</strong></p><blockquote><p>Your returned answers (both index1 and index2) are not zero-based.</p><p>You may assume that each input would have exactly one solution and you may not use the same element twice.</p></blockquote><p><strong>Examples</strong></p><blockquote><p><strong>Input:</strong> numbers = [2,7,11,15], target = 9<br><strong>Output:</strong> [1,2]<br><strong>Explanation:</strong> The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.</p></blockquote><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(numbers []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    i := <span class="hljs-number">0</span><br>    j := <span class="hljs-built_in">len</span>(numbers) - <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">for</span> i &lt; j &#123;<br>        <span class="hljs-keyword">if</span> numbers[i] + numbers[j] == target &#123;<br>            <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>&#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> numbers[i] + numbers[j] &gt; target &#123;<br>            j--<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思考</strong></p><blockquote><p>这个变种比较简单，数据按升序排好，只需要使用双指针，向中间靠拢即可</p></blockquote><h3 id="变种二：Two-Sum-IV-Input-is-a-BST"><a href="#变种二：Two-Sum-IV-Input-is-a-BST" class="headerlink" title="变种二：Two Sum IV - Input is a BST"></a>变种二：Two Sum IV - Input is a BST</h3><blockquote><p>Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.</p></blockquote><p><strong>Example:</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">Input</span>: <span class="hljs-string"></span><br>    <span class="hljs-attr">5</span><br>   <span class="hljs-meta">/</span> <span class="hljs-string">\</span><br><span class="hljs-string">  3   6</span><br> <span class="hljs-meta">/</span> <span class="hljs-string">\   \</span><br><span class="hljs-string">2   4   7</span><br><br><span class="hljs-attr">Target</span> = <span class="hljs-string">9</span><br><br><span class="hljs-attr">Output</span>: <span class="hljs-string">True</span><br></code></pre></td></tr></table></figure><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(root *TreeNode, k <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>list := printTree(root)<br>hashSet := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(list); i++ &#123;<br>except := k - list[i]<br><span class="hljs-keyword">if</span> hashSet[except] == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>        hashSet[list[i]] = <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 层序遍历</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printTree</span><span class="hljs-params">(root *TreeNode)</span> []<span class="hljs-title">int</span></span> &#123;<br>queue := <span class="hljs-built_in">make</span>([]*TreeNode, <span class="hljs-number">0</span>)<br>queue = <span class="hljs-built_in">append</span>(queue, root)<br>list := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>list = <span class="hljs-built_in">append</span>(list, queue[<span class="hljs-number">0</span>].Val)<br>left := queue[<span class="hljs-number">0</span>].Left<br>right := queue[<span class="hljs-number">0</span>].Right<br><span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, left)<br>&#125;<br><span class="hljs-keyword">if</span> right != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, right)<br>&#125;<br>queue = queue[<span class="hljs-number">1</span>:]<br>&#125;<br><span class="hljs-keyword">return</span> list<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Runtime distribution</strong></p><blockquote><p>Runtime: 24 ms, faster than 86.52% of Go online submissions for Two Sum IV - Input is a BST.</p></blockquote><p><strong>memory distribution</strong></p><blockquote><p>Memory Usage: 7.6 MB, less than 50.00% of Go online submissions for Two Sum IV - Input is a BST.</p></blockquote><p><strong>思考</strong></p><blockquote><p>通过层序遍历，将二叉搜索树转成数组，然后再通过哈希表法判断是否存在两个数的和等于目标值</p></blockquote><h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2019年个人总结</title>
    <link href="/2020/01/04/2019-review/"/>
    <url>/2020/01/04/2019-review/</url>
    
    <content type="html"><![CDATA[<p>2019年已经过去3天了，再不写个人总结，2020年怕是又要稀里糊涂的过去了。</p><p>如果给过去的这一年打个分，自认为能打到70分，算是部分满意。此外，2019年也是我从学校到工作过渡的一年，我是年初1月23号拿的毕业证，直接入职，到年底正好工作一整年。这一年，无论是工作内还是工作外，都有太多值得记录的事情。</p><h2 id="回顾2019年初的目标"><a href="#回顾2019年初的目标" class="headerlink" title="回顾2019年初的目标"></a>回顾2019年初的目标</h2><hr><p>大方向上，主要有下面几个：</p><ul><li>给自己和家人配置保险</li><li>开始自己的投资规划</li><li>学英语（这算是一个执念吧）</li><li>练字</li><li>提高自己的专业技能</li></ul><h3 id="给自己和家人配置保险"><a href="#给自己和家人配置保险" class="headerlink" title="给自己和家人配置保险"></a>给自己和家人配置保险</h3><p>一直以来就对保险充满了好感，觉得没有保险的人生是没有安全感的。对保险有好感的原因比较多，首先，我这个人比较怕死。这么多年，无论是亲身经历的，还是从电视新闻上看到的一些和生死相关的事情，都让我对死亡充满了敬畏。很多时候，生命远比我们想象的要脆弱。而保险，能让生命在最脆弱的时候，保留一份基本的尊严；其次是刚买房，家里也没什么积蓄，爸妈年纪都大了，我才刚开始工作，整个家庭的风险承受能力很低。所以，刚工作不到两个月，我就开始不断的看保险相关的知识，比对不同的保险。看的焦头烂额的时候，正好实验室的一个师姐也在了解保险，她的一个高中同学就是大都会的保险代理人。这期间通过这个代理人，了解了医疗险和重疾险的区别，再结合自身的实际情况，配置了如下的保险：</p><p><strong>自己</strong>：医疗险+重疾险+恶性肿瘤医疗险（全球版）<br><strong>媳妇</strong>：医疗险+重疾险<br><strong>父母</strong>：好医保-住院医疗险</p><p>医疗险是现在比较火的百万医疗险，报销型，保额足够了。重疾险是一份终身10万保额叠加20年期40万保额，一共50万保额。由于实在是担心自己得癌症，自己又加了一份恶性肿瘤医疗险（全球版），两个人全年保费8000左右。父母因为已经到51周岁，年级大了，不适合买重疾险，就再支付宝上买了好医保-住院医疗险，两个人全年保费1500左右。大都会的保险相比其他家的是偏贵了，之所以还选择他们家，是因为保险附带的增值服务比较多。</p><p>因为刚开始工作，也没什么积蓄，暂时就先配置这些年，短期内不再变动。等以后收入增加了，再把重疾险的额度配置上去。</p><h3 id="开始自己的投资规划"><a href="#开始自己的投资规划" class="headerlink" title="开始自己的投资规划"></a>开始自己的投资规划</h3><p>年初的时候看了不少公众号文章，都在宣传躺着赚钱，财务自由这些让人心里痒痒的观点，再加上之前自己胡乱投资基金、p2p这些，狠狠的踩了几趟雷，决定系统的开始自己的投资之路，万一走着走着就自由了呢？</p><p>我的投资学习路径是两部分：</p><ul><li><strong>理论学习</strong></li><li><strong>投资实践</strong></li></ul><p><strong>理论学习</strong>方面，主要包括财富观的培养、投资基础知识的学习。这一年，完成了以下书籍：</p><ul><li>傻瓜式投资</li><li>穷爸爸和富爸爸</li><li>小狗钱钱</li><li>指数基金投资指南</li><li>解读基金：我的投资观与实践</li><li>漫步华尔街</li></ul><p>未完成书籍：</p><ul><li>聪明的投资者</li><li>共同基金常识</li><li>逃不开的经济周期</li></ul><p>这几本书比较硬核，看的比较慢，2020年继续。</p><p><strong>投资实践</strong>方面，从抄作业开始，跟投E大的长赢计划，中途配置了教育基金和自己的养老基金，主要定投沪深300和中证500这两个指数基金。</p><p>2019年收益率16%左右，基本是抄作业的功劳，比较满意，所以已有部分继续跟投，同时继续完善理论知识，完成自己的投资体系的建立，然后实现躺尸的同时，躺赢，哈哈~~</p><h3 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h3><p>这部分进行的一般。由于工作上的变动，从算法转到了开发，自然语言处理和机器学习的学习就彻底搁置了下来。后端开发能力上，跟着业务，狠狠的补了下基础知识。主要的能力提升是对后端开发有了一个整体的认识：后端开发围绕的是数据的存储和在业务逻辑上的处理。</p><p>关于后端开发知识，主要的提升在对nginx的了解、redis的了解上，其它的一些提升比较零碎，不成体系。</p><h3 id="学英语"><a href="#学英语" class="headerlink" title="学英语"></a>学英语</h3><p>学英语是一直以来的执念，也没有什么具体的目标，就是想学，但是每次都是半途而废。</p><p>19年，在水滴上完成了《人性的弱点》和《人性的优点》两本英文原著的半精读，其它就没有了。</p><p>20年需要好好梳理下学英语到底是为了什么，需要达到一个什么样的目标，然后再重新定个计划，好好执行。</p><h3 id="练字"><a href="#练字" class="headerlink" title="练字"></a>练字</h3><p>想练一手好字。。。19年一直处于想的状态。20年需要定个轻松易行的计划，争取每年提高一些。</p><p>以上是19年年初规划的完成情况，整体看，喜忧参半。家庭规划上的完成情况比较满意，但是技能提升相关的规划完成度较差，这部分需要重新梳理一遍，并且制定出一个松紧有度的20年年度计划，希望20年结束的时候，能够完美的交出一份对的起自己的答卷。</p><h2 id="2019年感触比较深的几件事"><a href="#2019年感触比较深的几件事" class="headerlink" title="2019年感触比较深的几件事"></a>2019年感触比较深的几件事</h2><hr><h3 id="人生大事"><a href="#人生大事" class="headerlink" title="人生大事"></a>人生大事</h3><p>人生大事方面，完成了买房和领证。</p><h4 id="买房"><a href="#买房" class="headerlink" title="买房"></a>买房</h4><p>媳妇还在上学，之前研究生入学的时候，没有意识到户口的重要性，就没有把户口转到学校，幸好18年政策变化，除了入学那一次可以迁户口，每年秋季开学也可以迁户口了，就赶紧办理，到19年初户口就下来了。户口下来之后，迅速的把房子给买了。现在回想买房的过程，觉得有点太草率了，有必要记录一下买房的过程，让自己在以后做类似买房这种重大决定的时候，不要被情绪左右。</p><p>决定买房之前，和媳妇讨论要买什么样的房子，为了能买到预算范围内最合适的房子，我们首先列出了一系列的考虑因素，最终决定重点看<code>交通</code>，<code>医疗资源</code>，<code>菜市场</code>，<code>公园</code>，<code>商业配套</code> 这几个因素，由于我们都还年轻，再加上预算只有200左右（主要原因），就没有考虑学区房。交通方面，主要是地铁，所以我们以地铁线为基准，列出地铁线上每一站附近的<code>医院</code>，<code>商业配套</code>，<code>公园</code>，<code>学校</code>以及附近<code>房价</code>等情况，并以此筛选出候选站点。我们花了2个星期左右的时间，统计了1、2、3、4、5、6、9这几条地铁线，标出了一些候选，并决定每周末考察两个地铁站。</p><p>在4月初的一个周末，我们开始了考察。首先去的是1号线终点附近的几个站点，找了链家的一个中介，带着我们看了附近的几个小区，整体看下来，这一片都是居民区，小区质量一般，配套还行，生活气息浓厚，商业气息差了些，不太满意。晚上临走的时候中介推荐了5号线附近一个新开的楼盘，说是性价比很高，强烈建议我们去看看。我们其实是不太想去的，一是当时有点晚，二是本身也不着急，奈何中介极力推荐，就说第二天去看看。</p><blockquote><p>我们常常在小钱上斤斤计较，如买菜和买衣服，而在大钱上冲动无比，如买房</p></blockquote><p>第二天跟着中介到了售楼处，好家伙，里面人声鼎沸，导购介绍和签合同的场景到处都是。在经过了导购员的讲解之后，对楼盘有了个整体印象。一共是两个小区，一大一小，大的小区靠着一个正在建的永旺商场，小的隔的远了些，靠着一个正在建的市民广场。附近就是外环和高速入口，地铁站1公里左右。交通不错，商业配套和生活配套也不错，缺点是都在规划中。价格和预算一致。两个人都比较满意，这个时候导购一直在强调，最近三天搞活动，预付定金，给2个点优惠。两个人都没啥定力，被导购这么一说，再加上对房子确实很满意，都开始犹豫要不要先交定金。和家里商量了下（家里没意见，也都不懂，说只要我们觉得满意就行，唉。。。），又咨询了一个在德佑的亲戚的意见，觉得还行，两个人就在晕乎乎的情况下，交定金了。</p><p>晚上回去后，两个人都觉得草率了，但是因为本身对房子比较满意，没有发现什么地方有问题，就商量着真正交首付的时候，一定要仔细的比对合同，同时问明白一些关键指标，如果有什么地方不行，哪怕定金要不回来也不能买。付首付的时候，果然还是出问题了。一是我们发现这个房子没有阳台。当时看房型的时候，都觉得房型很好，方方正正，南北通透，愣是把阳台给漏了。二是问了下公摊，这一问，才知道公摊高达35%，105的房子套内面积才70，瞬间不想定了。后来和在德佑的那个亲戚沟通，他说这个公摊确实是很高了，但是套内面积70的三居也还行，其实套内面积差个2平米根本就感觉不出来。他这么一说，再加上内心清楚，这个房子吸引我的地方有很大一部分原因是旁边正在规划的市民广场，市民广场的规划里面有图书馆，电影院等，这个实在太吸引我了。所以和媳妇商量了好一会，犹豫再三，最终还是付了首付。</p><p>进入2020年，回过头来看，买的房子单价降了近2000，市民广场的规划发生变动，广场的一半改成商业配套。房价下降这件事情，4月份其实是有预期的，当时看了很多文章，都在说19年的政策是强调房住不炒，而且目前国家经济处于转型的过程中，经济形式不好，未来一段时间内房价肯定会下跌，所以买房不用着急，但是并没深入的去研究论据，自己只是表面相信，所以在售楼处导购员反复推销的时候，我是如此的不堪一击；另外有一个观点是如果是刚需，随时可以上车。因为4月份的房价相比18年的顶点是降了不少的。现在想来，刚需随时可以上车这句话是理解错了。对当时的自己而言，其实买房并不是刚需，媳妇21年夏天才毕业，我在北京工作，我们暂时是没有住房需求的。市民广场规划发生变化这件事，就是买期房的风险了，幸好规划变化还能接受，希望未来没有大的变动。</p><h4 id="领证"><a href="#领证" class="headerlink" title="领证"></a>领证</h4><p>因为买房用的是媳妇的户口，还贷款是我，加上父母不可能同意只以媳妇的名义买房，所以两个人就需要在签贷款合同前领证。由于买房这个决策太突然，导致领证这件事也变的很赶。两个人匆匆忙忙的去拍了结婚照，又急急忙忙的去民政局领了证。</p><p>领证的当天，早上8点多就到了民政局。时间比较早，有点冷清，交了材料后，等了一小会，就轮到我们了。填了些材料，不一会，鲜红的两个结婚证就出来了。两个人拿到结婚证后，坐在沙发上缓了好一会，都觉得有点不真实。但因为下午还要赶紧去办贷款，缓过来之后又急急忙忙的去了售楼处。领证的过程就这么匆忙的结束了，都没来的及吃顿饭庆祝一下。</p><p>回想起和媳妇相处的这几年，除了最开始的一年里面摩擦较多，后来磨合的越来越好，也不知当初两个人怎么就互相认定了。随着时间的推移，越发能体会到媳妇的好，也越发为自己当时的眼光感到得意。</p><p>希望接下来的日子里，两个人能走的越来越好，把我们的小日子过的有滋有味。</p><h3 id="工作波折"><a href="#工作波折" class="headerlink" title="工作波折"></a>工作波折</h3><h4 id="部门变动和线上事故"><a href="#部门变动和线上事故" class="headerlink" title="部门变动和线上事故"></a>部门变动和线上事故</h4><p>18年底到19年中这段时间，从实习转成了正式。这段时间里面，先是最初的业务被停掉，换了新业务，之后是部门换掉，从大搜到了手百，再就是经理也换了。中间由于各种原因，指导人换了又换，我也从最初的算法转到了开发。</p><p>换到新部门和新业务期间，指导人被重新指定。这段时间里，我刚接手的项目对当时的我来说，难度系数较高。开发的过程中，费了很大劲才能勉强跟上进度。中间有个任务，因为一些原因，需要迁移。由于开始没有能和指导人C有一个比较好的沟通，设计方案做的比较差，线上运行的时候，出了严重的事故。</p><p>之后复盘过程中，C不断的指出方案上的不足，告诉我哪些地方需要多加注意，代码评审的时候，也是一行行的过代码，前后评审10多次。短短的几天内，我学到了很多，也很感激。</p><p>后来C由于个人发展上的考虑，去了部门内的其他组。我的指导人也从C变成了组内的S。偶尔会想，如果开始的时候，C就能像最后那样，我是不是就不会经历后来的转正风波，当然也就不会迅速认识到工作和学校学习的不同和及时适应身份上的一个转变。凭良心说，C的业务能力很强，人品也没问题，可能是我的性格和他实在不搭，再加上初期的自己确实也有一些问题，导致两个人没能沟通好，这一点比较遗憾。</p><h4 id="转正风波"><a href="#转正风波" class="headerlink" title="转正风波"></a>转正风波</h4><p>由于指导人C给的评价不好，给新经理留下一个很差的印象。试用期过了一大半的时候，新的指导人S通知我说我的转正比较危险，让我做好心里准备。当时听到这个，心里顿时一沉。指导人S说他也是第一次遇到这种事情，也不知道怎么处理，建议我做两手准备，而他接下来也会尽量把任务分给我一些，希望我能多一些产出。</p><p>后来我主动找经理沟通了下我当前的状态，经理指出了我身上的一些不足，并且说给我一个月左右的观察期，同时指定了一些任务指标，希望我好好表现。这一个月里面，刚好业务上特别忙，又要准备那些任务指标，压力很大。天天晚上都是11点、12多才回去。工作日没有时间完成那些任务指标，只能周六日来弄。</p><p>这期间十分感谢指导人S的尽心指导，使得我的业务能力有了很大的提高，从而顺利的通过了转正，以后有机会一定要好好的感谢他；也非常感谢媳妇，在这段时间里面没有给我任何压力，并且不断的鼓励我，让我没有其它的后顾之忧。</p><p>转正风波这段期间，虽然说是压力很大，但是也仅此而已。首先是我和媳妇的感情很稳定，其次是虽然有房贷，但是两个人手上有一些钱足够支撑一年，经济上也没有太大压力，再次家里也很和谐。可以说这几个因素是我能顺利通过转正的坚实基础。</p><p>工作上的这两件事给刚出学校我很大的冲击，让我迅速的认识到学校学习和社会工作的不同，及时调整自己，同时尽早开始思考自己的人生规划，为将来做准备。可以说是因祸得福。希望以后的自己能不断的提高，能自信的面对任何变化，让自己成为家人坚实的依靠。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><hr><p>2019年已经过去，这一年无论发生了什么，都变成了过去时，只有成长留了下来。人生短暂，希望接下来的日子里，能和时间做朋友，在未来，成为更好的自己！</p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>证券投资的本质</title>
    <link href="/2019/07/07/%E8%AF%81%E5%88%B8%E6%8A%95%E8%B5%84%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <url>/2019/07/07/%E8%AF%81%E5%88%B8%E6%8A%95%E8%B5%84%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="A股是赌场吗？"><a href="#A股是赌场吗？" class="headerlink" title="A股是赌场吗？"></a>A股是赌场吗？</h3><p>不同的想法和理念代入到交易中，就有不同的反馈。</p><blockquote><p>资本市场是一个高度复杂的生态系统，所以从不同的角度观察，就会有不同的看法</p></blockquote><h4 id="如果把A股看成赌场"><a href="#如果把A股看成赌场" class="headerlink" title="如果把A股看成赌场"></a>如果把A股看成赌场</h4><p>赌场有个显著的特点：总价值不变，有赢就有输。</p><p>如果把A股看成赌场，双方博弈的对象就是股票的价格，看涨的买入，看跌的卖出。</p><p>如果把A股看成赌场，A股有80%的公司都是没有价值的公司(牌本身没有价值，只有在比大小的时候才有相对价值。所以公司是没有价值的，猜股票的涨跌才是有价值的。当然还是有20%的公司无法忽略，他就是有价值的）</p><p>不建议用赌场的观念看待A股：垃圾股的估值整体处在一个向下回归的过程中，这时候进行纯粹的博弈就不行了。</p><h4 id="如果认为A股不是赌场"><a href="#如果认为A股不是赌场" class="headerlink" title="如果认为A股不是赌场"></a>如果认为A股不是赌场</h4><p>A股依然有很多公司在为投资者创造价值。那么可以通过分享上市公司的增长获得价值的增值。</p><h3 id="格雷厄姆的看法"><a href="#格雷厄姆的看法" class="headerlink" title="格雷厄姆的看法"></a>格雷厄姆的看法</h3><p>投资是一种通过认真分析研究，有希望保本和获得满意收益的行为，不满足这些条件的行为就是投机。</p><h4 id="内在价值"><a href="#内在价值" class="headerlink" title="内在价值"></a>内在价值</h4><p>要根据公司的内在价值来投资，而不是根据市场的波动来投资。股票应该是公司的部分所有权，而不应该是日常价格变动的证明。</p><p>证券投资, 买的是企业所有权的一部分，买的是企业未来盈利的一部分。</p><p>内在价值不能简单的看做是公司的资产总额减去负债总额，还包括这些资产未来所能产生的收益。</p><h4 id="市场先生"><a href="#市场先生" class="headerlink" title="市场先生"></a>市场先生</h4><p>市场先生如果过于乐观，就会报出一个特别高的价格，如果过于悲观，就会报出一个特别低的价格。</p><p>市场先生从不害怕无人理会，如果今天他的报价无人理会，那么明天，他就会报出一个更低的价格。相反，如果理会的人太多，那么第二天，他就会报出一个更高的价格。</p><p>市场先生的情绪越是狂躁抑郁，对你越有利。如果你的情绪受到他的左右，那么后果不堪设想。</p><p>对我们有用的，是市场先生口袋里的报价单，而不是他的智慧。如果你不能确定远比市场先生更了解而且更能估价你的企业，那么你就没有资格玩这个游戏。</p><p><em>格雷厄姆的选股方法：三分之二市净率和低市盈率，倾向于找便宜的公司</em><br><em>需要注意这种方法的时代背景：1929年的大萧条，便宜的公司遍地都是</em></p><h4 id="安全边际"><a href="#安全边际" class="headerlink" title="安全边际"></a>安全边际</h4><p>投资者应该在他愿意付出的价格和他估计出的股票价值之间保持一个较大的差价，这个差价就叫做安全边际。</p><h3 id="巴菲特对格雷厄姆价值投资理论的发展"><a href="#巴菲特对格雷厄姆价值投资理论的发展" class="headerlink" title="巴菲特对格雷厄姆价值投资理论的发展"></a>巴菲特对格雷厄姆价值投资理论的发展</h3><h4 id="继承部分"><a href="#继承部分" class="headerlink" title="继承部分"></a>继承部分</h4><ul><li>持有股票即持有公司</li><li>投资和投机的定义和区别</li><li>市场先生</li><li>安全边际</li><li>各种套利方法和捡烟蒂理论</li></ul><h4 id="抛弃部分"><a href="#抛弃部分" class="headerlink" title="抛弃部分"></a>抛弃部分</h4><ul><li>55股债平衡理论</li><li>用市净率和市盈率等简单指标去买一堆看似便宜的公司</li><li>只依据财报看资产价值而不看未来价值</li></ul><h4 id="发展部分"><a href="#发展部分" class="headerlink" title="发展部分"></a>发展部分</h4><ul><li>护城河、能力圈、管理层等结合概率思维预测公司前景的准确性</li><li>好公司普通价格优于普通公司好价格</li><li>按机会成本行事</li><li>内在价值等于未来现金流折现</li><li>伯克希尔模式，充分发挥资本的边际效应</li><li>利用保险公司的低成本</li></ul><p><em>巴菲特的看法：价格公道的伟大企业要比价格低廉的普通企业要好得多</em></p><h3 id="几种定义方式和理解"><a href="#几种定义方式和理解" class="headerlink" title="几种定义方式和理解"></a>几种定义方式和理解</h3><p>价格低于价值情况，所有的投资都应该叫做价值投资</p><p>相对于成长股而言，买的公司要有相应的资产，利润，和现金流，而不是靠未来成长的可能性来支撑起价值。（更为现在的投资者所接受）</p><p>价值投资是资产管理者的信仰，趋势交易等理念更多的是作为一种投资工具在使用。择时已经被成熟的市场所抛弃，大量产品禁止择时。</p><p>在中国，价值投资的便签已经被滥用。有人股票被套了，就说自己是长期持有，价值投资；有人买了消费股，买了大蓝筹，大盘股，行业龙头，就说自己是价值投资；有人认为，只有买低市盈率、市净率的股票才是价值投资。</p><p>一种观点：是不是价值投资，重点看投资回报的来源是哪？如果是企业的持续盈利增长，投资人去分享红利，这才是价值投资的方式，才是基于基本面的投资.</p><h4 id="涉及到的一些概念"><a href="#涉及到的一些概念" class="headerlink" title="涉及到的一些概念"></a>涉及到的一些概念</h4><ul><li>低估值、高回报<ul><li>价值投资不等于长期持有，</li></ul></li><li>短、中、长期的有趣定义<ul><li>用时间划分长短没错，但是没有意义，持有期限是结果，不是目的，要根据操作内涵来理解</li><li>短线就是尊重市场，顺势而为，重点是不亏损，盈利没有要求</li><li>中线需要对基本面有很高的掌握，对价格估值系统有充分的认识，他的标的物是那些经营相对稳定，没有大起大落的企业，讲究的是低买高卖，预期盈利目标到20%才可入场，8%的止损位</li><li>长线的要求最高，要求对企业有很深的认识，对自己有严格的控制，清楚把握企业未来发展的趋势，以投资的心态分享企业未来的成长。他的投资标的物是千里挑一，他对利润的要求是数以十倍计，在这样的机会面前，他不会惧怕任何亏损，不会设置除基本面以外的任何止损指标</li></ul></li><li>看长做短<ul><li>A股由于波动较大，常常3个月把三年的涨幅都涨完，这种情况就大大透支了企业的基本面，这种时候就需要及时兑现利润。适合A股的一种策略就是看长做短，但是这个短一定是作为结果，而不是作为目的。看长的意思是，你买入的行业或者板块，一定要有一年以上，偏中长期的投资逻辑，而不能是仅仅几个月的利好，持有计划应该是一年以上，做短是如果短期上涨太快，要注意止盈。</li></ul></li></ul><p><strong>仅以时间作为策略区分标准的一定会走入误区，决定策略的仅应该是股票本身的不同和投资者自身的素质</strong></p><h3 id="理论基础的重要性"><a href="#理论基础的重要性" class="headerlink" title="理论基础的重要性"></a>理论基础的重要性</h3><pre><code>1. 价值投资：知和行的关系2. 胜者为王，宁可错过，不要做错3. 做好价值投资，保持健康</code></pre><p><strong>投资是艺术，不是科学</strong></p><p><strong><a href="https://pc-shop.xiaoe-tech.com/appCRApuVG28915/video_details?id=v_5c4142617c5d9_e6jBxu1Y">视频地址</a></strong> </p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>投资理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>价值投资训练营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>https升级教程</title>
    <link href="/2019/06/26/https%E5%8D%87%E7%BA%A7%E6%95%99%E7%A8%8B/"/>
    <url>/2019/06/26/https%E5%8D%87%E7%BA%A7%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="升级前准备"><a href="#升级前准备" class="headerlink" title="升级前准备"></a>升级前准备</h2><p>上一章详细讲解了https的原理之后，本章节将以本博客为对象，实践https升级。</p><p><strong>升级准备工作</strong></p><ol><li>CA 选择： <a href="https://letsencrypt.org/">Let’s Encrypt</a></li><li>安装工具选择：<a href="https://certbot.eff.org/">certbot</a></li><li>实践对象：本博客: <a href="www.afreecoder.cn">www.afreecoder.cn</a></li><li>博客托管的vps配置：<ol><li>OS：CentOs 6, x86_64</li><li>RAM: 0.5G</li></ol></li><li>确保有ssh权限，即能通过ssh远程访问你的web host</li></ol><p><strong><a href="https://letsencrypt.org/">Let’s Encrypt</a>是电子前哨基金会EFF为了推广https协议，提供的免费的、自动化的和开放的CA(Certificate Authority)。<a href="https://letsencrypt.org/">Let’s Encrypt</a>的一个贡献是ACME协议，ACME协议旨在确保域名验证、发布和管理方法是完全自动化、一致、符合合规性和安全的。</strong></p><p><strong>支持ACME协议的工具有很多(<a href="https://letsencrypt.org/docs/client-options/)，本文选择的推荐的[certbot](https://certbot.eff.org/">https://letsencrypt.org/docs/client-options/)，本文选择的推荐的[certbot](https://certbot.eff.org/</a>)</strong>。</p><h2 id="升级教程"><a href="#升级教程" class="headerlink" title="升级教程"></a>升级教程</h2><p><strong>首先，进入<a href="https://certbot.eff.org/">certbot</a>网站，选择对应的web服务器软件（nginx，apache等）和操作系统版本（CentOs 6）,网站会给出对应的操作指令</strong></p><p><strong>1. 获取cerbot执行脚本</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://dl.eff.org/certbot-auto<br></code></pre></td></tr></table></figure><br><code>certbot-auto</code> 实际上是一个shell执行脚本</p><p><strong>2. 放到习惯的路径下</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mv certbot-auto /usr/<span class="hljs-built_in">local</span>/bin/certbot-auto<br></code></pre></td></tr></table></figure></p><p><strong>3. 修改执行脚本的所有者</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo chown root /usr/<span class="hljs-built_in">local</span>/bin/certbot-auto<br></code></pre></td></tr></table></figure><br>由于certbot需要验证你就是改域名的持有者，所以3、4两步都需要在root权限下进行</p><p><strong>4. 修改执行脚本的权限</strong><br><code>sudo chmod 0755 /usr/local/bin/certbot-auto</code></p><p><strong>5. 自动获取证书，同时修改nginx配置文件</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo /usr/<span class="hljs-built_in">local</span>/bin/certbot --nginx --nginx-server-root=/usr/<span class="hljs-built_in">local</span>/nginx/conf<br></code></pre></td></tr></table></figure></p><p>这里有个坑，网站给出的命令是 <code>sudo /usr/local/bin/certbot --nginx</code>，这条命令默认ngxin安装在/etc/nginx，所以有可能会报错：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">nginx: [emerg] <span class="hljs-keyword">open</span>() <span class="hljs-string">&quot;/etc/nginx/nginx.conf&quot;</span> failed (2: <span class="hljs-keyword">No</span> such <span class="hljs-keyword">file</span> or directory)<br>nginx: configuration <span class="hljs-keyword">file</span> /etc/nginx/nginx.<span class="hljs-keyword">conf</span> <span class="hljs-keyword">test</span> failed<br></code></pre></td></tr></table></figure><br>所以需要用 <code>--nginx-server-root</code> 指定nginx.conf的路径</p><p>接下来的操作，按照提示操作即可。</p><p><strong>6、添加定时任务</strong><br><a href="https://letsencrypt.org/">Let’s Encrypt</a>证书的有效期是90天，90天之后就需要重新更新证书，因此需要设置一个定时任务自动更新证书<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;0 0,12 * * * root python -c &#x27;import random; import time; time.sleep(random.random() * 3600)&#x27; &amp;&amp; /usr/local/bin/certbot-auto renew&quot;</span> | sudo tee -a /etc/crontab &gt; /dev/null<br></code></pre></td></tr></table></figure><br>上面这行命令是网站提供的，意思是每天12点和0点自动更新证书。至于为什么需要time.sleep(random.random() * 3600)，猜测是为了让大家错开时间，降低证书请求的压力</p><p><strong>相关配置文件</strong><br>新的配置文件目录, 同之前的nginx.conf目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/<span class="hljs-built_in">local</span>/nginx/conf/vhost/<br></code></pre></td></tr></table></figure><br>证书目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/etc/letsencrypt/<br></code></pre></td></tr></table></figure></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html">HTTPS 升级指南</a></p><p><a href="https://zhuanlan.zhihu.com/p/29507417">Linux下使用acme.sh申请和管理Let’s Encrypt证书</a></p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>https原理</title>
    <link href="/2019/06/05/https%E5%8E%9F%E7%90%86/"/>
    <url>/2019/06/05/https%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="1、为什么要有https？"><a href="#1、为什么要有https？" class="headerlink" title="1、为什么要有https？"></a>1、为什么要有https？</h3><p>http协议被用于客户端和服务端之间传递消息，但是这个传输过程是以明文的方式发送内容，http协议不提供任何方式的数据加密。如果有人获取了浏览器和服务器之间的传输保报文，就可以直接读取其中的信息。因此，http协议不适合传输一些个人敏感信息，比如：个人账户密码、支付信息等。</p><p>由于http协议的安全缺陷，需要有一种协议来保证客户端和服务端通信的安全，于是就有了https。</p><h3 id="2、https主要解决了什么问题？"><a href="#2、https主要解决了什么问题？" class="headerlink" title="2、https主要解决了什么问题？"></a>2、https主要解决了什么问题？</h3><p><strong>i. 确保你想访问的对象是你希望访问的对象</strong></p><p>网络世界里，真正决定你地址的是IP。平时我们所访问的网址如 <code>www.baidu.com</code> 都需要由DNS（域名转换系统）服务商将网址翻译成对应的IP地址，也就是说我们要访问的对象实际上是一个IP地址。如果中间网址到域名的转换关系被恶意的修改（也就是DNS劫持），我们的访问请求就会打到修改之后的恶意IP上，</p><p>https首先解决了身份认证的问题，即确保你要访问的对象就是你希望访问的对象。现实生活中，如果我们和某个人A交易，为了确保交易的安全性，首先需要确认A的身份。通常我们会检查A的身份证信息，资质信息等。确认了A的身份之后，我们才开始与对方交易。</p><p>https的身份认证过程也是如此。Server端上线之初，会向权威的第三方的CA（Certificate Authority, 证书颁发机构）申请证书，然后第三方会通过线上线下核查的方式确认Server的信息，核查完之后，会给Server颁发一个证书，这个证书中记录了颁发机构的信息和Server的身份信息。</p><p>初次请求https的时候，服务端首先会返回一个证书，这个证书中包含了访问对象的身份信息，客户端验证了证书之后发现，证书中的信息就是访问对象的信息，接下来就可以正常通信了。</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B.png" alt="认证过程"></p><p>有的同学可能会有疑惑，如果我伪造一个证书，客户端怎么知道呢？比如我是A，但我非要在证书里写我是B，那你怎么知道呢，就像现实中伪造的各种证书一样？CA颁发的证书有个特性是不可修改。这个涉及到非对称加密的知识了，简单来说就是CA把公司的信息通过特定的摘要算法如MD5生成一段签名，再用私钥对签名进行加密。客户端拿到证书之后，根据证书中的摘要算法对证书中的信息计算出一个签名，然后用CA的公钥对密文进行解密，对比计算出的签名和解密出的签名，如果一致，就证明证书没有被修改过。</p><p>下面是 <code>www.baidu.com</code>的证书信息（谷歌浏览器点地址栏的那个小锁）：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/baidu_https_cert.png" alt="百度的证书"></p><p>从图中可以看到百度相关的信息，签发者相关的信息，签名算法（这里的签名算法是SHA-256）以及百度的公钥。</p><p><strong>ii. 确保通过过程中的数据安全</strong></p><p>解决了如何证明你就是你的问题之后，就需要解决如何保证通信过程中你们的通信内容不被窃取到。</p><p>还是刚刚那个交易场景。你确认了和你交易的A的身份之后，你们开始放心的交易了。如果你们的交易内容是你想花大价钱从A受手里买一个产品的配方，有了这个配方之后，你就能财源滚滚，走上人生巅峰了，所以这个配方千万不能泄露出去。为了和网络通信的过程保持一致，我们假设你们不直接交易，而是需要一个传信的人帮你们传递这个配方。在原来http的协议下，这个配方就是明文传输的，如果有人劫持了这个信件就能获取到这个配方。所以就不能明文传递这个配方，得加密。那加密方式怎么选择呢？</p><blockquote><p>对称加密：对称加密指的的是采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密<br>非对称加密：非对称加密算法是一种密钥的保密方法。 非对称加密算法需要两个密钥：公开密钥（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。 公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。</p></blockquote><p>考虑到为了模拟真实的通信过程，你们是不能见面的，也就是说你不能通过耳语把你要用的密钥告诉A，所以你们否决了开始就用对称加密的方式，因为怎么把密钥传给对方是个问题。如果在传输密钥的过程中密钥泄露了，这就和明文传输配方没什么区别了。所以如何把密钥传给A？传输过程有以下几步：</p><ol><li>首先生成用于对称加密的密钥s</li><li>利用证书中A传过来的公钥，对密钥s进行加密，传给A</li><li>A利用自己的私钥，对传过来的密文进行解密，解密出密钥s</li><li>接下来双方通过密钥s来加密通信内容，互相传输</li></ol><p>再回到https的通信过程中，具体流程如下图所示：</p><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/https_communication.png" alt="https通信过程"></p><p><strong>以上就是https原理的简介。至于如何从http升级到https，下一篇将以本博客为例，示范升级过程。</strong></p><hr><p><img src="https://tjjsjwhj-blog.oss-cn-beijing.aliyuncs.com/2021/05/06/gongzhonghaopic.jpeg" alt="gongzhonghaopic"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
